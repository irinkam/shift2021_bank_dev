class PR_CRED;

/**
@comment
Операция "Открыть договор"
Операция регистрации в системе нового кредитного договора.
Контрагент (кредитуемая организация) привязывается к договору из списков клиентов банка, и потому  он должен быть предварительно зарегистрирован в системе. 
Выполняемые функции: 
Пользователю предлагается экранная форма операции (окно), позволяющая  ввести параметры договора и  подтвердить или отменить вызов операции (выбором соответствующей "кнопки" экранной формы). Ввод параметров договора выполняется через заполнение значениями соответствующих полей экранной формы. При отказе от выполнения операции новый договор не создаётся, а введенные данные игнорируются.
Экранная форма операции.
Предлагает ввести следующие пункты договора:
·	Клиент договора, обязательный для заполнения пункт
·	Сумма кредита ? для кредитных линий - лимит выдач
·	Лимит задолженности
·	Валюта  кредита,  значение по умолчанию ? национальная валюта.
·	Дата начала кредитного договора, значение по умолчанию ? дата текущего операционного дня.
·	Дата окончания кредитного договора
·	Вид кредита ? возможен выбор значения из справочника "Виды кредитов"
·	Плата за открытие лимита ? можно указать плату за открытие лимита в виде суммы или процента от суммы договора
·	Цель кредитования - возможен выбор значения из справочника "Объекты кредитования".
·	Проценты по кредиту -  процентная схема текущего кредитного договора.
·	Параметры планирования  ?  есть возможность изменить сформированные по умолчанию параметры планировая операций выдачи, гашения кредита и гашения процентов, затем сформиророванные плановые операции откорректирвать или внести вручную.
·	Условия востребования  ?  если новый договор является договором до востребования (стоит флажок "До востребования" на первой закладке), то условия востребования можно указать на соответствующей закладке
·	Примечания
Элементы управления
·	ОК ? "кнопка" подтверждения удаления текущего договора
·	Отмена ? "кнопка" отказа от выполнения удаления


*/
@import_plsql(true)
@this(create_on_start:=true)
@name('S226. Открыть договор')
@tag('COPIED')
constructor S226_NEW_DOG is

@name('Класс кредита')
public V_CR_CLASS [STRING_100];
@name('Класс клиента')
public CL_CLASS [STRING];
@name('Заявка на получение кредита')
public DECL_ON_CRED_REF [DECL_ON_CRED_REF];
@name('Генеральное соглашение по кредитным линиям')
public V_GEN_AGR [GEN_AGREEM_F_REF];
@name('Подписать сразу')
public P_SIGN_UP [BOOLEAN];
@name('Лимит остатка ссудной задолженности')
public V_LIMIT_SALDO [SUMMA];
@name('Процентная ставка за кредит')
public V_PRC_RATE [NUM_16_8];
@name('История правил начисления процентов')
public V_CREDIT_ARR [ARR_ARC_SCH_PRC];
@name('Дата выдачи')
public V_DATE_GIVE [DATE];
@name('Сумма прописью')
public V_SUM_STR [STRING_1000];
@name('Кредит верхнего уровня')
public P_HIGH_LEVEL_CR [PR_CRED_REF];
@name('Открыть счета')
public P_OPEN_ACC [BOOLEAN];
@name('Аннуитетный платеж')
public V_ANNUITET [BOOLEAN];
@name('Однодневный кредит')
public V_ONE_DAY [BOOLEAN];
@name('Лимит кредитования')
public V_LIMIT_CR [SUMMA];
@name('Условия востребования')
public V_INVOICE_COND table of [PARAM_FOR_PLAN];
@name('Индекс таблицы условий востребования')
public V_INVOICE_IDX [STRING_32];
@name('До востребования')
public V_INVOICE [BOOLEAN];
@name('Параметр планирования')
public V_PARAM_FOR_PLAN [PARAM_FOR_PLAN];
@name('Валюта платы за откр. лимита')
public P_FOR_OPEN_FN [FT_MONEY_REF];
@name('Счет транша')
public P_ACCOUNT [AC_FIN_REF];
@name('Id счетов')
public ACCs_ID [STRING_32000];
@name('Параметр планирования, ссылка')
public V_PARAM_FOR_PLAN_REF [PARAM_FOR_PL_REF];
@name('Параметры планирования, массив')
public V_PARAM_FOR_PLAN_A [PARAM_FOR_PL_ARR];
@name('Плановые операции (массив)')
public V_LIST_PLAN_PAY_ARR [PLAN_OP];
@name('Вид операции')
public V_VID_OPER [VID_OP_KRED_REF];
@name('Планировать все')
public V_PLAN_ALL [BOOLEAN];
@name('Состояние записи')
public V_STATUS [STRING_1];
@name('Срок линии распространять на транш')
public V_COPY_TO_TRANSH [BOOLEAN];
@name('Имя класса клиента')
public CL_CLASS_NAME [STRING];
@name('Обеспечение')
public V_ZALOG_CHOICE [ZALOG_REF];
@name('Код ОКОНХ')
public V_OKONH [OKONH_REF];
@name('Командная строка валидатора')
public V_DEST_STR [STRING_32000];
@name('Тип проекта')
public V_PRJ_KIND_CRED [KIND_PROJECT_REF];
@name('Созаемщики')
public V_DEBTORS [DEBTORS_ARR];
@name('Условия досрочного погашения')
public V_EARLY_PAY [EARLY_PAY_REF];
@name('Дополнительные свойства')
public V_PROPERTIES [PROPERTIES_ARR];
@name('Кредитный инспектор')
public V_CRED_INSP [STRING_100];
@name('Пути выдачи кредита')
public V_WAY_OUT_CODE [STRING_2];
@name('Максимальная дата окончания')
public V_DATE_ENDING_MAX [DATE];
@name('Коды подразделений')
public V_STRING_DEPARTS [STRING_32000];
@name('Дополнительное условие по классу')
public V_ADD_CLASS [STRING_100];
@name('Счета клиента')
public V_PRC_DEP_TURN_ACC_LIST [CL_ACC_NEW_ARR];
@name('Схемы зависимостей')
public V_PRC_DEP_TURN_PRC_DEP_SCHEME [PRC_DEP_TURN_ARR];
@name('Банк обслуживания кредита')
public V_BOK [CRDIT_BANK_REF];
@name('Сумма гашения')
public V_SUMMA_PAY [SUMMA];
@name('Список комиссий')
public V_COMISS_TBL table of [DEBT_COMISS_PRC];
@name('Список процентных схем')
public V_PRC_SCH_TBL table of [VIEW_PRC_SCH];
@name('Информация о базовой схеме')
public V_PRC_ADD [STRING_100];
@name('Основной объект кредитования')
public V_OBJ_CRED [OBJ_KRED_REF];
@name('Предоставлять информацию в БКИ')
public V_TO_BKI [BOOLEAN];
@name('Таблица параметров планирования')
public V_P4P_GRID table of [PARAM_FOR_PL_REF];
@name('Индекс таблицы параметров планирования')
public V_P4P_IDX [STRING_32];
@name('Карточный договор')
public V_IS_FOR_CRED_CARD [BOOLEAN];
@name('Открыть депозитный договор')
public V_OPEN_DEP [BOOLEAN];
@name('Максимальный лимит задолженности')
public V_MAX_LIMIT_SALDO [SUMMA];
@name('Вариант обновления схем')
public V_SCHM_CHANGE [SHORT1];
@name('Процентные схемы для правил расчета')
public V_SCHM_FOR_RULE [STRING_2000];
@name('Вид реструктуризации')
public V_RESTR_KIND [CHANGE_KIND_REF];
@name('Минимальный платеж')
public V_RESTR_MIN_PAY [SUMMA];
@name('Выбранный календарь')
public V_CALENDAR [REFERENCE];
@name('Копировать ПП из КВУ')
public V_COPY_HL_PP [BOOLEAN];
@name('Условие реструктуризации')
public V_CHANGE_RULE [CHANGE_RULE_REF];
@name('Настройка универсального конструктора')
public V_RT_NUK [RT_NUK_REF];
@name('Профиль гашения')
public V_DISTR_PROFILE [CR_DISTR_PRO_REF];
@name('Настройки ежемесячных платежей')
public V_FACTOR_MP [FACTOR_MP_REF];
@name('Ежемесячные платежи')
public V_FACTOR_MP_ARR [FACTOR_MP_REC_AR];
@name('Размер платежа в первый год')
public V_SUM_PAYMENT [SUMMA];
@name('Ежемесячные платежи (для просмотра)')
public V_FACTOR_MP_VIEW_ARR [FACTOR_MP_REC_AR];
@name('Прочие условия')
public V_OTHERS_TERM table of [PROPERTY_PROD];
@name('Индекс таблицы прочих условий')
public V_OTHERS_TERM_IDX [STRING_32];
@name('Ссылка на свойство')
public V_REF_PROP [PROPERTY_PRO_REF];
@name('Возможность изменять ставку')
public V_CAN_PRC_SCH [SHORT1];
@name('Индекс списка процентных схем')
public V_PRC_SCH_TBL_IDX [SHORT7];
@name('Согласие на продажу договора')
public V_DO_FACTORING [BOOLEAN];
@name('Срок транша. Количество периодов')
public V_TRANSH_PERIOD_NUM [DIG_6];
@name('Срок транша. Единица измерения периода')
public V_TRANSH_PERIOD_UNIT [REF_UNIT_OF_TIME];
@name('Дополнительные параметры')
public V_ADDS [STRING_32000];
@name('Конструктор планирования')
public V_USE_PLAN_RULE [BOOLEAN];
@name('Плановые операции по кредиту')
public V_LIST_PLAN_PAY [PLAN_OPER_REF];
@name('Кредит для всех плановых операций')
public V_PL_CRED [PR_CRED_REF];
@name('Параметры планирования. конструктор планирования')
public V_P4P_PLAN_RULE [PARAM_FOR_PL_ARR];
@name('Результат изменения индивидуальных настроек планирования')
public V_SET_TUNE_CR_CHANGE [STRING_1000];
@name('Ссылка на кредитный договор для скрипта')
public V_CRED_VBS [PR_CRED_REF];
@name('Признак вызова сброса')
public V_NEED_DROP [BOOLEAN];
@name('График уплаты затрат')
public V_LIST_EXP_PAY_ARR [PLAN_OP];
/*
 * Дата     Автор       BFS         Описание
 * --------	-----------	-----------	---------------------------------------------------------------------------------------
 * 15.04.02	Maxlime					Создание операции
 * 15.01.07	Akil		BFS00024912	При включенной настройке мультивалюты для HL_CREDIT допускается смена валюты транша
 * 16.01.07	VFedoseev	BFS00029664	При установке крыжика "% годовых" контрол, предназначенный для указания валюты платы
 * 17.01.07	VFedoseev	BFS00028471	Если установлена настройка "Создавать копии процентных схем для траншей", а в КВУ установлен признак "Условия линии
 * 18.01.07	VFedoseev	BFS00029749	При очистке массива комиссий и процентных схем, выполняемой при смене вида кредита, очищаются также
 * 22.01.07	JBokhan		BFS00029539 Добавлен контроль на непустое значение реквизита "Правило учета".
 * 24.01.07	AFrantsuzov	BFS00029592 При выборе заявки добавлен вызов функции validate_form. На ЭФ поле "Срок" ограничено 4 символами.
 * 26.01.07	VFedoseev	BFS00030291	В процедуре CALC_NUM_DOG в реквизит HIGH_LEVEL_CR проставляем ссылку на КВУ не только в случае,
 * 07.02.07	VFedoseev	BFS00030936	Для корректной установки флагов "Планировать даты" и "Планировать суммы" после
 * 09.02.07	VFedoseev	BFS00031365	На закладке "Дополнительно" ЭФ вместо ИНН клиента банка выведен его регистрационный код.
 * 21.02.07	VFedoseev	BFS00030875	При смене вида кредита валюта заполняется по виду кредита, а если она там не указана - указываем нац.валюту.
 * 07.03.07 Judge       BFS00027409 Добавлена логика определения эталонных условий досрочного погашения аналогично операции редактирования кредита METH PR_CRED EDIT_LAST
 * 07.06.07	VFedoseev	BFS00035280	При смене вида кредита (и отсутствии ген.соглаш. по кред.лин.) валюта заполняется
 * 10.07.07	AEliseev	BFS00033403	В процедуре recalc_summ_ann теперь в дополнительные параметры прописываем класс продукта
 * 17.07.07	AEliseev	BFS00035549	Запрещено для прямого редактирования грид параметров планирования
 * 24.07.07	AEliseev	BFS00037105	Корректно отрабатывается пересчет суммы аннуитета
 * 09.08.07	Pononarev	BFS00033049 На экранную форму на закладку "Дополнительно" добавлен массив "Информация из БКИ"
 * 24.09.07	Horoshun	BFS00039366 Для транша "клиент" и "счет" из группы "Реквизиты клиента для расчетов по кредиту" не заполняются данными кредитной линии.
 * 22.01.08	AEliseev	BS00061254	Очищаем сумму лимита для простых договоров
 * 04.03.08	Horoshun	BS00032826  Удалена процедура расчета суммы аннуитета.
 * 26.03.08	Horoshun	BS00065670	Удалена функция validate_vek, в которой была жесткая зависимость от кода вида кредита с кодом "2". Только для него разрешалось
 * 									заполнение ссылки на договор продажи векселей.
 * 08.04.08	Horoshun	BS00065597  Добавлено сохранение реквизитов в экземпляр создаваемого договора при выборе кредита верхнего уровня.
 * 05.05.08	anya		BS00070694	В функциях find_acc_by_prd и locate_product, которые используются для определения договора и счета, по которому предоставлен овердрафт
 * 									помимо обработки депозитов физ лиц, добавлена обработка депозитов юр лиц
 * 02.06.08	Horoshun	BS00067876	В секцию глобальных описаний вынести процедуру копирования процентных схем в транши
 * 									procedure copy_prc_sch_for_tranche.
 * 04.08.08	JBokhan		BF00075964	1. Вместо обращения к удаленному реквизиту [OVER_ON_PROD] таблицы [OVERDRAFTS]
 * 									выполнено обращение к новому реквизиту [OVER_ON_PROD] таблицы [PR_CRED].
 * 									2. Для карточных договоров сделаны доступным для изменения продукт и счет, по которому выдается кредитный договор.
 * 15.08.08	JBokhan		BS00076590	1. Добавлена переменная на форму операции V_OPEN_DEP и ее обработка.
 * 									2. Доработан функционал для договоров до востребования.
 * 26.11.08	Horoshun	BS00081825	Реализован корректный расчет дополнительных параметров до говора при
 * 									создании кредита по заявке.
 * 28.11.08	Ponomarev	BS00085335	В определение кода новой %схемы добавлен id вида задолженности
 * 18.12.08	Horoshun	BS00088230	Добавлен фильтр по валюте на условия досрочного погашения.
 * 23.03.09	Horoshun	BS00096748	Клиент-скриптом выполнено ограничение на максимальное кол-во вводимых символов через
 * 									глобальную константу [PAYER_NAME].[LIB].gcn_LENGTH.
 * 18.05.09	Ponomarev	BS00101811	Изменена максимальная размерность количества дней в периоде = 6
 * 01.09.09	Evmenov		BS00114117	Удалено заполнение реквизитов [PR_CRED].[NOT_AUTO_PLAN] и [OVERDRAFTS].[NOT_AUTO_GASH]
 * 15.09.09	Akil		BS00110457	При формировании таблицы процентных схем учитывается реквизит "Копировать из КВУ"	
 * 30.09.09	Dmiv		BS00110460	Добавлена работа с реквизитом MAX_LIMIT_SALDO	
 * 22.10.09 Azaikov		BS00116571	Убрана процедура adjust_plan
 * 08.12.09 Akil		BS00120654	Копирование %% схем по новой технологии, передавать в транш, условия линии заменено на срок передавать в транш
 * 18.01.10 Ponomarev	BS00125880	Для договоров, по которым могут открываться транши, в гриде процентных схем отображаем колонку "В транш", при изменении сохраняем
 * 04.02.10 Dmiv		BS00128102	Замена получение остатка по счету учета лимита, на сумму задолженности ЛИМИТ
 * 									В функцию check_gen_agreem_frame передается параметр P_KIND_CREDIT.
 * 12.03.10 Akil		BS00129905	При указании/изменении КВУ копируется срок и дата окончания.
 * 05.04.10 Akil		BS00133282	locate_over_by_product проверяет кредиты по мультивалютным депозитам физлиц
 * 28.04.10 Nesterenko	BS00135391	Добавлено упорядочевание записей в гридах Процентные схемы (V_PRC_SCH_TBL), Список комиссий (V_COMISS_TBL),	Параметры планирования (V_P4P_GRID).
 * 28.05.10 Akil		BS00133278	При указании заявки на выдачу, копирование схем КВУ с учетом признаков "передавать в транш"
 * 01.06.10 Nesterenko	BS00133030	При создании процентной схемы, схема создается в валюте договора.
 * 03.06.10	Nesterenko	BS00133979	Добавлена работа с правилами расчета плавающих ставок
 * 09.07.10 Ponomarev	BS00141296	Реквизиты клиента в валидации из договора верхнего уровня копируются полностью
 * 22.09.10 Azaikov     BS00147027  Изменения в связи с рефакторингом расчёта процентов
 * 01.10.10	Azaikov		BS00140573	Добавлен вывод итоговой %-ставки
 * 11.10.10 Jbokhan		BS00147936	Удалена функцию find_acc_by_prd.
 *									Вместо вызова find_acc_by_prd(P_PRODUCT) сделан вызов P_PRODUCT.[GET_ACC_PROD], в которую передается ссылка на тип счета "MAIN_PROD_ACOUNT".
 * 27.09.10 Nesterenko	BS00140713  Добавлена возможность использования технологии "Урегулирование резерва в другом филиале".
 * 22.11.10	Nesterenko	BS00144998	При изменении на ЭФО Вида кредита происходит безусловное обновление Типа проекта.
 * 23.11.10	Akil		BS00144987	Создание схем по реквизитам заявки, исправлено копирование схем при указании заявки на получение кредита
 * 29.11.10 AGanin		BS00150781	Добавлено копирование ограничений PRC_MIN, PRC_MAX при копировании процентной схемы
 * 14.01.10 AGanin		BS00149547	Использование системного флага CR_REZ_LN заменено на одноименную настройку
 * 20.01.11	Akil		BS00158671	Контролы для условий реструктуризации в начале договора. Проверка и сохранение условий если контролы заполнены
 * 10.02.11 AGanin		BS00158020	Добавлена передача класса и подразделения при создании процентной ставки
 * 28.02.11 Jbokhan		BS00161065	При добавлении/редактировании реквизитов клиента для расчетов - реквизиты сохраняются в справочнике LIST_REQ_CLIENT
 *									("Кредиты. Расчетные счета клиентов") с приоритетом 1.
 * 31.03.11 Jbokhan		BS00162259	При копировании процентных схем из вида кредита копируется классификатор % схемы.
 * 19.04.11 AGanin		BS00162480	При смене типа проекта, вида кредита запрос о варианте изменения %%схем выводится только если они заполнены и выбран непустой вид кредита
 * 05.05.11 Ponomarev	BS00165490	Блокируется контрол "Предоставлять информацию в БКИ" если нет прав на KB_FORM_EVENT
 * 22.06.11	Ponomarev	BS00168802	Действия при смене вида кредита вынесены в отдельную процедуру.
 * 22.08.11 Ponomarev	BS00167431	Исправлены фильтры на выбор типа проекта и вида кредита. Вызов операций через интерфейсы
 * 29.08.11	Tkach		BS00163265	Добавлена обработка реквизита CALENDAR_NAME
 * 11.09.11 Pyshkin		BS00174100	Исправлен фильтр для реквизита "Виды кредитов": в представление попадают только экземпляры, у которых признак "Архивный" либо не установлен, либо false.
 * 11.09.11 Pyshkin		BS00174400	Исправлен фильтр для реквизита "Кредит верхнего уровня": в представление попадают только кредиты в состоянии "Работает" или "Ожидает подтверждения".
 * 07.10.11 Pyshkin     BS00175554  Исправлен фильтр для реквизита "Кредит верхнего уровня"
 * 17.10.11 Ponomarev	BS00176681	Реквизиты договора сохраняются перед поиском ПОС в настройке
 * 26.10.11 Pyshkin     BS00176625  Реквизит "Номер договора" сделан недоступным к изменению после подписания
 * 06.12.11 Pyshkin		BS00180629	Исправлена ситуация с копированием лишних процентных схем.
 * 22.12.11 Madyarov	BS00183270	Исправлена процедура set_kind_kred для подтягивания ПОСа с вида кредита
 * 23.01.12 Banas 		BS00184914  Обеспечено копирование значения реквизита "Календарь" из КВУ в транш
 * 27.01.12	Ponomarev	BS00185816	на форму операции добавлена кнопка для установки индивидуальных настроек
 * 15.02.12	Banas		BS00187375 	Добавлен вызов копирования р/c с КВУ в транш copy_accs_to_transh
 * 01.03.12 AGanin		BS00185808	Добавлена возможность копирования ПП из КВУ
 * 01.03.12 Iljushevich	BS00189002	Добавлена переменная P_PERIOD_WD, P_TURNOVER_WD и логика ее обработки при определении сроков договора
 * 22.03.12 Banas		BS00187976  Добавлен вызов операции CALC_DEBT_PRIOR. При копировании списка задолженностей из вида кредита копируются индивидуальные приоритеты по типу счета
 * 30.03.12 Iljushevich	BS00191407	Сделана инициализация переменных P_PERIOD_WD и P_TURNOVER_WD
 * 30.03.12	Timofeev	BS00188580	Вызовы NewSchemPrcUp переписаны на вызовы NewSchemPrc
 * 03.04.12 Pyshkin		BS00190618	Оптимизирован фильтр реквизита "Вид кредита"
 * 10.04.12	SOmelchenko	BS00192288  В процедуру CALC_NUM_DOG добавлено заполнение реквизита договора OVER_ON_PROD
 * 19.04.12 Iljushevich BS00192680  Изменен алгоритм выбора способа выдачи кредита, в связи с изменением структуры справочника WAY_KRED. Теперь в справочнике возможно только одно значение записи для конкретного кода.
 * 29.05.12 Evmenov		BS00195852	В процедуре FillPrcTable не заполняются строки таблицы процентных схем для задолженностей с кодами НЕУЧТЕН_ПРОЦЕНТЫ_НАЛ и ПРЦ_КРЕД_НАЛВ_112 при отключенном приложении "Определение ставки в зависимости от способа выдачи денежных средств"
 * 07.06.12 Iljushevich	BS00201736	Добавлена обработка нового реквизита "Последний платеж"
 * 05.07.12	Drozhzhin	BS00202031	Добавлен контрол на ЭФ "Индивидуальные настройки для лимита..."
 * 06.07.12 Zheleznov	BS00186322	Добавлен вызов операции редактирования индивидуальных курсов по продукту
 * 23.08.12 Boychuk		BS00305562	Изменено условие выборки в процедуре get_def_prc_schemes. Добавлен nvl по валюте.
 									В секции проверки при изменении валюты договора перед вызовом процедуры get_def_prc_schemes
									добавлено очищение массива комиссий и % схем открываемого договора.
 * 19.10.12 Anaumov		BS00463567	Изменен тип суммы договора
 * 26.10.12 Zheleznov	BS00462488	Добавлена установка срока по умолчанию из вида кредита
 * 30.10.12 Guseynov	BS00463475	Добавлено блокирование поля на ЭФ "Максимальная дата окончания" для овердрафтов
 * 14.10.12 Anaumov		BS00464407	Добавлено объявление параметра P_SUMMA в процедуре on_change_kind_credit для правильной отработки ТЯ2
 * 30.11.12 Guseynov	BS00466717	Добавлен вызов хука CRED_CALC_BAL, для расчета размера последнего платежа договоров с Balloon
 * 04.02.13 sfedorischenko	BS00471471	При копировании процентной схемы в вызов NewSchemPrc добавлена передача ссылки
 * 13.05.13 Iljushevich	BS00477230	Конструктор реструктуризации (kabakov, guseinov)
 * 23.05.13 Iljushevich	BS00480037 	Добавлено удаление условия реструктуризации в начале договора при нажатии на cancel
 * 05.06.13 Reznik		BS00481274	Для приложения 1B290204 "Автоматическое досрочное гашение" добавлен параметр P_EARLY_PAY - ссылка на виды заявок на досрочное гашение, сохраняется в доп.свойствах договора
 * 17.06.13 Iljushevich	BS00482029	Добавлена установка значения REG_DATE при инициализации V_CHANGE_RULE
 * 28.06.13	Madyarov	BS00484158 	Вырезан блок кода, автоматически добавляющий транши выкупленного договора в договор покупки/продажи
 * 05.07.13 Guseynov	BS00483214	Константа в которой хранится дата операционного дня заменена на переменную. Добавлено заполнение переменной даты операционного дня в секции: Тело, Проверка, Локальные описания (не посредственно в процедуры).
 * 28.08.13 Latfullin	BS00506652  Сделал параметр P_EARLY_PAY не обязательным
 * 03.10.13 Lakomov		BS00553274  Добавлено скрытие контрола вид заявки на досрочное погашение при выключенном приложении 1B290204.
 * 04.10.13	zakirov		BS00506511	Добавлены переменные операции: "Настройки ежемесячных платежей" (V_FACTOR_MP), "Ежемесячные платежи" (V_FACTOR_MP_ARR), "Размер платежа в первый год" (V_SUM_PAYMENT), "Ежемесячные платежи (для просмотра)" (V_FACTOR_MP_VIEW_ARR).
 *									На вкладку "Планирование" экранной формы добавлена группа элементов управления настроек ежемесячных платежей. В серверную и клиентскую валидацию добавлена обработка настроек ежемесячных платежей и связанных с ними элементов экранной формы.
 *									На экранной форме группа элементов "Реструктуризация в начале договора" перенесена с вкладки "Планирование" на новую вкладку "Реструктуризация".
 * 04.10.13 Jbokhan		BS00559613	На вид кредита наложен фильтр, исключающий из доступа виды кредитов для составных продуктов.
 *									Описание процедуры get_calc_vertion вынесено в глобальное описание.
 *									В процедуру Fill_COMISS_ARR добавлен необязательный параметр bUpdateOnlyPrior - обновление только приоритетов.
 * 29.10.13	drozhzhin	BS00566269	Приведение к одной размерности V_PRC_RATE и V_PRC_ADD
 * 31.10.13	Saraskin	BS00482213	Валидация платежных реквизитов клиента приведена к единообразному виду, с использованием библиотечных функций
 * 01.11.13	drozhzhin	BS00571943	На ЭФО реквизитов для расчетов в раздел "Не клиент банка" добавлен контрол КПП.
 * 05.11.13	gruntovskiy	BS00577295	В тело операции вставлен вызов операции RecalcAnnuityPayments из библиотеки [FACTOR_MP].[LIB]. Вызов операции выполняется если добавляется
 *									договор с ежемесячными платежами. В конец процедуры RecalcFactorTune вставлен вызов операции RecalcAnnuityPayments.
 * 08.11.13	Gorbash		BS00572810	На ЭФО для контрола %PARAM%.P_PERIOD_UNIT.NAME исправлено представление.
 * 28.11.13 Saraskin	BS00595219 	Проверка ключевания счета в режиме "не клиент" вынесена в библиотечную функцию. Логика работы с контролами Счет и Клиент в режиме "клиент" приведена к общей для продукта.
 * 13.01.14 drozhzhin	BS00692405	Добавлен параметр P_MOP_TYPE, контрол для вызова операции индивидуальной установки Тарифа МОП + добавления по коду по работу с Алгоритмом МОП(планирование).
 * 10.02.14 Gorbash		BS00743791	При изменении даты начала договора добавлено обновление суммы ЕП первого периода. На форме на закладке Реструктуризация исправлена синтаксическая ошибка.
 * 17.02.14 Anaumov		BS00764334	При поднятии экранной формы для класса овердрафт подтягивается тип проекта
 * 20.02.14 sfedorischenko	BS00737265 В секцию "переменные" добавлены три переменные: "Прочие условия", "Индекс таблицы прочих условий", "Ссылка на свойство". На ЭФО добавлена вкладка "Прочие условия" и  соответствующие контролы
 *										Кнопка "Дополнительные свойства" перенесена с вкладки "Открыть договор" на "Прочие условия". Добавлен валидатор для добавления/редактирования записей в гриде "Прочие условия"
 * 20.02.14 AKozlov		BS00559922	Добавлена проверка на права пользователя при изменении ставки в общей процентной схеме. При наличии прав на операцию [PRC_SCHEME].[PRC_SCH_ACCESS]
 *									пользователю предлагается выбор, либо изменить общую процентную схему, либо скопировать схему в договор.
 * 26.02.14 Saraskin	BS00652043	Обращение к check_client_req переведено на библиотеку L_2, добавлена валидация реквизита V_CLIENT_REQ.1.2
 * 27.02.14 aromanenko	BS00714196	Добавлено получение условий досрочного погашения из массива на виде кредита при валидации параметров "Вид Кредита", "Валюта" и "Номер договора"
 * 03.03.14	drozhzhin	BS00796443	Исправлена перерасчет ЕП при изменении даты начала договора
 * 12.03.13 Anaumov		BS00807352	При поднятии экранной формы поле портфель заполняется согласно настройки в логике продукта
 * 19.03.14 gerasev		BS00808271	Добавлен перерасчет ЕП при изменении даты окончания кредитного.
 * 08.04.14 sfedorischenko	BS00814458	В секции проверка при удалении прочего условия меняем номер текущего элемента в гриде.
 * 15.04.14 Saraskin	BS00826266	Скорректирован вызов макроса MultiCheck - передается вид кредита и валюта договора
 * 21.04.14	Jbokhan		BS00825865	В процедуре RecalcFactorTune расчет аннуитета перенесен в блок if (V_FACTOR_MP is not null) then.
 * 30.04.14 Saraskin	BS00827153	В клиент-скрипте текущее значение ячейки грида сохраняется в переменную для сравнения с новым значением (т.к. метод Value(Row,Col) грида возвращает для дробей меньше единицы не старое значение, а новое), для этого создана функция Grid13_BeforeEdit.
 									Изменено условие валидации для грида %VAR%.V_PRC_SCH_TBL чтобы исключить ложные срабатывания.
 * 05.05.14 Spinu		BS00744040  Добавлена возможность указать Алгоритм МОП, в случае если на виде кредита не настроен параметр планирования "Гашение МОП" а в параметрах планирования есть операция "Гашение МОП" 									
 * 08.05.14	Reznik		BS00827858	Добавлена логическая переменная "Согласие на продажу"(V_DO_FACTORING)  и ее обработка (353ФЗ)
 * 12.05.14	Chebotarev	BS00827688	В списке видов сальдирование исправлено отображение на наименование.
 * 26.05.14	drozhzhin	BS00829069	Реализация Тарифа МОП.
 * 29.05.14	Gorbash		BS00829730	На ЭФО для контрола %PARAM%.P_PERIOD_UNIT.NAME исправлено представление на VW_CRIT_UNITS_OF_TIME_CRED.
 * 30.05.14	Jbokhan		BS00665910	При автоматическом формировании настроек ЕП, если задана, анализируется "дата выдачи".
 * 09.06.14 Saraskin	BS00828625	Добавлена вставка записи в историю кредитной заявки. Скорректировано сохранение Тарифа МОП.
 * 23.06.14 Bakovkin	BS00821568	Исправлена функция, возвращающая профиль гашения (get_profile): берем профиль гашения из вида кредита только в том случае, если в истории профилей гашения по данному продукту нет записей.
 * 24.06.14 Bakovkin	BS00831708	На ЭФО на вкладке "Проценты и комиссии" изменена ширина колонок "Ставка", "Итоговая ставка".
 * 26.06.14 Bakovkin	BS00821458	Функция fCheckMop перенесена в ::[PR_CRED].[LIB_EXT]. Вызов fCheckMop заменен на ::[PR_CRED].[LIB_EXT].fCheckMop.
 * 02.07.14	Jbokhan		RP0025547	В блоке проверке по 'DEFAULT' добавлено определение пользовательского контекста 'CRED_BUS_PROC'.
 * 09.07.14	Timofeev	RP0066232	В процедуру PrcScheme_Clear в новый параметр передается obj_cred.[COMISS_ARR].
 * 11.07.14	Akhmadeeva	BS00469475	Добавлено заполнение реквизита [CATEGORY_INFO].
 * 06.08.14	ABorisov	RP0064454	Установка признака V_TO_BKI согласно настройке  TO_BKI_DEFAULT при запуске операции.
 * 27.08.14 sfedorischenko	RP0014527	На ЭФО добавлена кнопка "Обеспеченность договора". В валидаторе реализована обработка нового контрола
 * 01.09.14 Saraskin	RP0083923	Вызов CALC_DEBT_PRIOR перенесен в операцию SIGN_UP
 * 06.09.14 sfedorischenko	RP0091107	При редактированиия договора в статусе отличном от "Ожидает подтверждения" кнопка формирования номера по шаблону не доступна
 * 06.09.14 Timofeev	RP0072850	Добавлена установка вида льготного периода в истории.
 * 09.09.14 Guseynov	RP0025638	В секции "проверка" добавлено заполнение переменной sAdds параметром CHECK_LIMIT со значением 0. При вызове процедуры check_gen_agreem_frame добавлена передача переменной sAdds.
 * 30.09.14 Timofeev	RP0107160	Заполнение истории льготных периодов перенесено перед планированием.
 									Добавлено удаление истории льготных периодов в случае если выбран вид кредита без льготного периода.
 * 06.11.14 Timofeev	RP0133934	Строка определения класса продукта должна содержать символы ';'.
 * 19.11.14 Chebotarev	RP0139114	Исключено заполнение реквизита DATE_ENDING_MAX у договоров овердрафта.
 * 20.11.14	Reznik		RP0140916	Добавлен вызов get_def_prc_schemes при валидации P_OVD_ACCOUNT.
 * 16.01.15 Reznik		RP0066301	На ЭФО добавлена надпись, в случае когда филиал расчетного счета не совпадает с филиалом кредитного договора.
 * 19.01.15	Timofeev	RP0145964	Запрещено изменение процентной ставки схемы, созданной из тарифной подсистемы.
 									Добавлена установка на договор схемы, выбранной в списке процентных схем.
 * 11.03.15 Azarov		RP0211988	В фильтре выбора вида кредита, убрана проверка на присутствие в списке классов класса FACTORING. Переменная V_ADD_CLASS заполняется классом овердрафт, если ранее не была заполнена классом факторинг.
 									Выполнена оптимизация кода - избавление от exception, locate, select переделан на for (select..). Удален закомментированный код и неиспользуемые переменные.
 * 13.03.15 Azarov		RP0216279	При чтении значение настройки TO_BKI_DEFAULT, добавлена передача METACLASS.
 * 13.03.15 vasukov		RP0209036	Из выборки в процедуре locate_over_by_product исключено условие на CARD_DEP
 * 20.02.15 Jbokhan		RP0132331	Добавлены переменные V_TRANSH_PERIOD_NUM и V_TRANSH_PERIOD_UNIT. При определении срока транша добавлен анализ доп.свойства "TRANSH_PERIOD_NUM".
 *									Исправлена обработка переменной V_COPY_HL_PP: устанавливаем значение по умолчанию = true и исключаем анализ настройки "COPY_HIGH_LEVEL_PP" из цикла по ПП договора.
 *									Исправлено определение опердня с учетом филиала договора, через ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial.
 *									В вызовах calc_period_units и DayPeriodAdd первым параметром везде исправлено на coalesce(V_DATE_GIVE, DATE_BEGIN).
 * 29.04.15 Ionov		RP0256141	В секцию проверка при инициализации ЭФО для случаев когда есть заявка на получение кредита добавлена проверка strong_check_hollydays_err_msg.
 * 08.05.15	Dyadichkin	RP0207816	Удален параметр P_EARLY_PAY и вся связанная с ним логика.
 * 12.05.15 Dyadichkin	RP0232397	Добавлен параметр P_CO_PROD. Добавлена переменная V_ADDS. Добавлен функционал, который в случае значения в параметре P_CO_PROD не null выполняет: подключение к комплексному договору
 									через вызов ::[CRED_INTERFACE].[PRX_TARIF_PLAN].AddConnection; сброс значения в P_MOP_TYPE, если из тарифной подсистемы передан алгоритм МОП; удаление зависимостей по процентным
 									ставкам для автоматического расчета реквизитов.
 * 09.06.15	rogalenko	RP0271422	В секции валидации в случае не совпадения филиала КД и филиала расчетного счета меняем значение текстового полю Label35.
 * 15.06.15	Dyadichkin	RP0276546	В серверной валидации в режиме 'DEFAULT' при вызове через PLPCALL вызов валидации по 'TYPE_PROJECT_DEFAULT' перенесен в режим 'VALIDATE'.
 * 11.08.15	Timofeev	RP0351661	В процедуре Fill_COMISS_ARR не копируем процентную схему с КВУ.
 * 12.10.15	pkartashev	RP0395737	В секции Проверка убрана очистка переменной v_old_info при каждом вызове валидации
 * 25.12.15	a.ivanov	RP0413801	Макрос MultiCheck заменен на вызов [PR_CRED].[LIB_TUNE].get_tune.
 *									Проведен рефакторинг:
 *														Удалены не используемые переменные.
 *														Обращение за датой опердня осуществляется через филиал.
 *														Присвоение умолчательных значений даты вынесено в проверку в секцию DEFAULT.
 * 16.03.16 kljushin	RP0487722	В тело добавлена pragma error для случая, когда филиал не установлен и не вычислен по-умолчанию.
 * 25.05.16 Kljushin	RP0521231	В секции проверки исправлена инициализация параметра P_OBJECTS_CRED
 * 30.05.16 karabanov	RP0514939	В секции "Проверка" добавлено копирование из вида кредита/удаление элементов массива "Варианты расчета индивидуальных приоритетов" в регистрируемом договоре при удалении/заполнении номера КВУ на ЭФО.
 *									Удаление элементов данного массива вынесено в отдельную процедуру delete_calc_version.
 * 07.06.16	JBokhan		RP0477870	В секции "Проверка" на валидацию контролов ('PERIOD', 'P_PERIOD_UNIT', 'P_PERIOD_WD') и 'DATE_ENDING' добавлена проверка, если у КВУ указан срок для транша и срок транша превышает срок КВУ, выдается сообщение об ошибке.
 * 02.09.16  			RP0371334 	Конструктор планирования.
 * 21.11.16	Gorbash		RP0542246	Добавлена дополнительная проверка на изменение ставки для общих процентных схем при нажатии на ОК.
 * 30.12.16 Gruntovskiy	RP0545982	Реализован контроль банкротства заемщика/созаемщиков.
 * 03.03.17 Polezhaev	RP0551049	При помещении записи в историю об устанавливаемом на договоре профиле погашения, удалена передача даты окончания договора в качестве параметра даты окончания действия профиля
 * 21.03.17 Podkovko	RP0552303	В процедуру on_change_kind_credit добавлена проверка попадания даты окончания на выходной день при автоматическом расчете срока.	
 * 04.05.17 Kljushin	RP0557092	Исключена проверка на изменение ставки для общих процентных схем при нажатии на ОК при подтягивании схемы в транш из КВУ.
 * 27.07.17 Kljushin	RP0565493	В валидации добавлена логика соответствия филиала подразделению:
 * 									 - при изменении филиала очищается подразделение;
 * 									 - выбор подразделения осуществляется из списка подразделений выбранного филиала или полного списка в случае отсутствия филиала;
 * 									 - при выборе подразделения устанавливается филиал из выбранного подразделения.
 * 01.08.17 Gruntovskiy	RP0565578	Реализован запрет изменения сложной процентной ставки.
 * 09.10.17 Podkovko	RP0571025	Доработана логика фильтрации видов кредитов.
 * 30.11.17 Karabanov	RP0572592	Добавлена возможность выбора реквизитов клиента для расчетов по кредиту из справочника контрагентов.
 * 15.12.17 Podkovko	RP0576496	Добавлено ограничение на наименование при создании процентной схемы.
 * 29.12.17	Podkovko	RP0567195	Доработка реструктуризации.
 * 29.05.18 Kljushin	RP0588716	Валидация создания массива процентных ставок реализована через таймер.
 * 13.04.18	shlikov		RP0583365	Добавлена переменная для определения характеристик МСФО.
 * 26.04.18 kljushin	RP0586689	В грид комиссий и затрат добавлен признак существенности и его расчет.
 * 07.09.18 kanakhina 	RP0595506	Увеличен размер переменной "Id счетов" до 32000 символов.
 * 09.09.18 kljushin	RP0586689	В процедуре загрузки комиссий FillComissTable добавлена загрузка комиссий по гарантиям.
 * 07.11.18 pkartashev	RP0597965	В процедуре FillComissTable добавлена обработка "Операционных комиссий", в SaveComissTable добавлено сохранение существенности для процентных задолженностей.   			
 * 12.11.18 pkartashev	RP0598618	Добавлена обработка признака существенности для процентных задолженностей
 * 14/12/18 Kanakhina   RP0600452	Изменено название инициализируемой переменной (dOperDay) в процедуре FillPrcTable.
 * 09.12.19 polezhaev	RP0599587	При вызове функции  Get_Ftool_Grp добавлена передача параметра p_dDatebeg
 * 11.01.19 shlikov		RP0601426	Добавлена обработка настройки логики продукта IFRS_DEFAULT
 * 06.03.19	shlikov		RP0603667	В блоке валидация добавлен вызов get_calc_vertion.
 * 21.03.19 pkartashev	RP0605950	В функции setImportanceDebt исправлен расчет суммы задолженности по плановым операциям.
 * 28.03.19 kljushin	RP0605036	Добавлено сохранение комиссии за открытие лимита/счета в массиве комиссий.
 * 25.01.20 janus		RP0615121	Добавлено получение календаря из функции GetCurCalendarName.
 * 25.01.21 Karabanov	RP0632300	В функции get_def_prc_schemes исправлена передача класса продукта для получения значения настройки COPY_PRC_SCH_TO_TRANCHES.
 * 19.04.21 Matytsina	RP0635506	В Fill_COMISS_ARR исправлена обработка переменной rComis.
*/

pragma include (::[PR_CRED].[LIB_MACRO]);
pragma include (::[SYSTEM].[PRODUCTS]);
pragma include (::[DEBUG_TRIGGER].[MACRO_LIB]);
pragma include (::[RUNTIME].[MACRO_LIB]);

public type ProcArr is record
(
	Scheme 		varchar2(32),
    Proc_Arr 	[ARR_ARC_SCH_PRC]
);
public type Proc_Arr is table of ProcArr;
public Prc_Arr Proc_Arr;
public type t_tbl_DEBT_COMISS_PRC is table of [DEBT_COMISS_PRC];
public type t_tbl_VIEW_PRC_SCH is table of [VIEW_PRC_SCH];


--КОНСТАНТЫ
KindCredits_04			const ref [KIND_CREDITS] 	:= ::[KIND_CREDITS]([CODE] = '04');
KindCredits_06			const ref [KIND_CREDITS] 	:= ::[KIND_CREDITS]([CODE] = '06');
ClientPsFrom 			const ref [PS] 				:= ::[PS]([PS_CODE] = 'F_П');
UT_DAY					const ref [UNITS_OF_TIME] 	:= ::[UNITS_OF_TIME]([CODE] = 'D');
propTRANSH_PERIOD_NUM 	const ref [KIND_PROP_PROD] 	:= ::[KIND_PROP_PROD]([CODE] = 'TRANSH_PERIOD_NUM');

--ПЕРЕМЕННЫЕ
sign 					varchar2(5);
parent_class 	varchar2(20);
err_mess		varchar2(32000);
Oper_Day		[DATE];
old_val			ref [FT_MONEY];

kind_cred		[KIND_CREDITS];

nShift_First	integer;	-- Сдвиг гашений
nAdd_First		integer;	-- Отсрочка гашений по кредиту

rPsOrg			ref [PS];
bMulticur 		boolean;

bRebuildParam4Plan	 	boolean := false;	--необходимость пересчета параметров планирования
bRebuildPlanRule		boolean := false;	--перестроение конструктора планирования

bCanSaveRate	boolean; -- подтверждение на сохранение общей ставки
v_old_kind		ref [KIND_CREDITS];
v_old_info		varchar2(100);
v_copy_priors	boolean;
v_ShareMainPrc	boolean; -- схема по %% участвует с других договорах/видах
rSchemeHLC	ref [PRC_SCHEME];

vUseFLRule 		boolean;	-- BS00133979 В договоре используются правила расчете процентных ставок
vCopyFLRule		boolean;	-- BS00133979 Копировать правила расчета процентных ставок с КВУ в транш

Gl_rDepart_Res	ref [DEPART];	-- BS00140713 Подразделение, в котором используются счета доходов/расходов при урегулировании резерва

oChangeRuleHR	[CHANGE_RULE]; -- реструктуризация на кредите верхнего уровня

isNUK			boolean;		-- значение настройки конструктора реструктуризации
rValueHist 		ref [RT_VALUE_HIST];
user_access_for_event boolean;

dDate_reg		date;

rFactorMPKind		ref	[FACTOR_MP];	-- Настройки ежемесячных платежей из вида кредита
rFirstFactorMPRec	ref	[FACTOR_MP_REC];-- Ежемесячный платеж первого периода (для платежей с причислением процентов)
bCopyMPTune			boolean := null;	-- Необходимость копирования настроек ежемесячных платежей из вида кредита
dateHist		date;	-- дата начала истории льготных периодов

glHL_PERIOD_NUM 		[DIG_6];			-- Для транша: срок и единица измерения срока от КВУ --
glHL_PERIOD_UNIT		ref [UNITS_OF_TIME];

bRecalcOnChangeLimit	boolean;			-- признак того, что был выполнен виртуальный пересчет планового графика траншей по плановым операциям изменения лимита
g_needDropPoint			boolean := false;	--признак того, что необходимо сбросить точки, т.к. изменены общие правила
g_clickBtnRule			boolean := false;
g_clickBtnSeason		boolean := false;	--признак настройки сезонности

tPeriodPlanOnCred		::[PR_DEBT].[LIB_CREATE_PP].TPeriodOnVidDebtTable;

bChangeRate				boolean;

--
pragma macro(CSMD_Visible, 'if ([4]) then [CSMD].Show([1], [2], [3]); else [CSMD].Hide([1], [2], [3]); end if', substitute);
pragma macro(CSMD_VisibleS, 'if ([3]) then [CSMD].ShowS([1], [2]); else [CSMD].HideS([1], [2]); end if', substitute);
pragma macro(CSMD_Enabled, 'if ([4]) then [CSMD].Enable([1], [2], [3]); else [CSMD].Disable([1], [2], [3]); end if', substitute);
pragma macro(CSMD_EnabledS, 'if ([3]) then [CSMD].EnableS([1], [2]); else [CSMD].DisableS([1], [2]); end if', substitute);

--Задолженности по комиссиям без тарифа
pragma macro(VD_KOMM_GARANT, '::[VID_DEBT]([CODE]=''КОММ_ГАРАНТ'')',substitute);
pragma macro(VD_KOMM_FOR_PAY, '::[VID_DEBT]([CODE]=''ПЛАТА_ЛИМИТ_СЧЕТ'')',substitute);
pragma macro(propLimitDayToPay, '::[KIND_PROP_PROD]([CODE] = ''LIMIT_DAY_TO_PAY'')', substitute);

--сброс значений локальных переменных
procedure clearVars
is
begin
	sign := null;
	parent_class := null;
	err_mess := null;
	Oper_Day := null;
	old_val := null;
	kind_cred := null;
	nShift_First := null;
	nAdd_First := null;	
	rPsOrg := null;
	bMulticur := null;
	bRebuildParam4Plan := null;
	bRebuildPlanRule := null;
	bCanSaveRate := null;
	v_old_kind := null;
	v_old_info := null;
	v_copy_priors := null;
	v_ShareMainPrc := null;
	rSchemeHLC := null;
	vUseFLRule := null;
	vCopyFLRule := null;
	Gl_rDepart_Res := null;
	oChangeRuleHR := null;
	isNUK := null;
	rValueHist := null;
	user_access_for_event := null;
	dDate_reg := null;
	rFactorMPKind := null;
	rFirstFactorMPRec := null;
	bCopyMPTune := null;
	dateHist := null;
	glHL_PERIOD_NUM := null;
	glHL_PERIOD_UNIT := null;
end;

-----------------------------------------------------------------------------------------------------------------
-- Получение индекса в массиве по p_info для %VAR%.V_PRC_SCH_TBL.
-----------------------------------------------------------------------------------------------------------------
function GetIndexPrc ( p_info varchar2(1000), sField in out varchar2(1000) ) return integer is
	str		varchar2(100);
begin
	str := substr(p_info, 21);	-- отрезать "%VAR%.V_PRC_SCH_TBL."

	if str is null then
		return null;
	end if;

	sField := substr(str, 1, instr(str, '[')-1);
	str := replace(substr(str, instr(str, '[') + 1), ']');

	return to_number(str);

exception when others then
	return null;
end;

-----------------------------------------------------------------------------------------------------------------
-- Заполнение таблицы процентных схем
-----------------------------------------------------------------------------------------------------------------
/*	BS00133979 Добавлено заполнение новых реквизитов в гриде */
public procedure FillPrcTable
		( p_aComissArr 					[PR_CRED].[COMISS_ARR]%type
		, p_tPrcTable	in	out	nocopy	&LCONST.TBL_VIEW_PRC_SCH
		, p_sPrcAdd 		in	out		varchar2(100)
		, p_bFromEdit 					boolean
		, p_rCred 					ref [PR_CRED] default null		-- BS00133979
		, p_rKindCred 				ref [KIND_CREDITS] default null	-- BS00133979
		, p_bUseFlRule 					boolean default null
		)
is 			
	i integer;
	bFindPrcRule	boolean;		-- BS00133979
	bNeedCheckCash	boolean;
	dOperDay		date;
	rFilial		ref [BRANCH];
	rHlvCred	ref [PR_CRED];
begin
 	
 	for (	select	pr_cred	( pr_cred.[FILIAL] :filial
 							, pr_cred.[HIGH_LEVEL_CR] :hlv
 							)
 			in	[PR_CRED]
 			where pr_cred = p_rCred)
 	loop
 		rFilial := pr_cred.filial;
 		rHlvCred := pr_cred.hlv;
 		exit;
 	end loop;
 	
 	dOperDay := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(rFilial);
	
	&debug('.FillPrcTable #'||p_aComissArr%size(0), 0)
	p_tPrcTable.delete;
	i := 1;
	
	if nvl(p_bUseFlRule, false) then
		::[FL_RATE_RULE].[LIB].ProdInit(p_rCred);
	end if;
	
	-- Проверим, включено ли приложение "Определение ставки в зависимости от способа выдачи денежных средств"
	bNeedCheckCash := nvl(::[FP_TUNE].[LIB].get_bool_value('1B310060'), false);
	
	for (	select Debts( Debts: ID
						, Debts.[NAME]		: NAME
						, Debts.[CODE]		: CODE
						, Debts.[TYPE_DEBT]	: TypeDebt
						)
			in ::[VID_DEBT] all
			where	Debts.[SCHEME_PRC] is not null
					and Debts.[TO_PRODUCT] = &LCONST.AP_PR_CRED
			order by upper(Debts.[NAME]), Debts%id	-- BS00135391. Записи в гриде будут упорядочены по наименованию задолженности и ID записи
		)
	loop
		if not bNeedCheckCash and Debts.[CODE] in ('НЕУЧТЕН_ПРОЦЕНТЫ_НАЛ', 'ПРЦ_КРЕД_НАЛВ_112') then
			continue;
		end if;

		p_tPrcTable(i).[REQ_NAME]:= Debts.[CODE];
		p_tPrcTable(i).[NAME]	:= Debts.[NAME];
		p_tPrcTable(i).[DEBT] 	:= Debts.ID;		-- BS00133979
		p_tPrcTable(i).[PRIORITY] := case
											-- TODO: для процентных задолженностей тип учета может быть только "Процентная комиссия" и тип учета "Затрата" сейчас установить невозможно.
											-- Обработку заложили на будущее, если будет снято такое ограничение
											when Debts.TypeDebt = &LCONST.TD_EXPENSE then 1
											when Debts.TypeDebt = &LCONST.TD_COMMISS_PRC then 2
											else null
										end;
		for (	select x( x.[PRC_SCHEME] : PRC_SCHEME
						, x.[FROM_HL_CRED] : FROM_HL
						, x.[IMPORTANCE] : IMPORTANCE
						)
				in p_aComissArr all
				where x.[DEBT] = Debts.ID
			)
		loop	
			&debug('.FillPrcTable : DEBT = '||Debts.[CODE],0)
			p_tPrcTable(i).[PRC_REF] := x.PRC_SCHEME;
			p_tPrcTable(i).[PRC_ARR] := p_tPrcTable(i).[PRC_REF].[LIST_SCH_PRC];
			p_tPrcTable(i).[PRC] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( p_tPrcTable(i).[PRC_REF], dOperDay, 0, 0, false, false);
			p_tPrcTable(i).[FROM_HL_CRED] := x.FROM_HL;
			p_tPrcTable(i).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( p_tPrcTable(i).[PRC_REF], dOperDay);
			p_tPrcTable(i).[STOP_CALC] := x.IMPORTANCE;

			if p_bFromEdit and Debts.[CODE] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				p_sPrcAdd := 'Ставка: '||to_char(p_tPrcTable(i).[RES_RATE], '99990D00000000')||' %';
			end if;
		
			--v-- BS00133979. Если осуществляется работа с плавающими ставками, то заполним соответствующие реквизиты
			if nvl(p_bUseFlRule, false) then
				-- Проверим есть ли хоть одно правило для данной задолженности
				bFindPrcRule := [FL_RATE_RULE].[LIB].FindPrcRule(p_rCred, Debts.ID);
				
				if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(p_rKindCred, rHlvCred, Debts.ID) or bFindPrcRule then
					-- Если есть правила, или вид кредита (транша, или КВУ если действует признак копировать в транш) допускает использование правил
					
					-- Заполним тип ставки
					p_tPrcTable(i).[FL_RULE_TYPE] := get_RateType(p_rCred, Debts.ID, p_tPrcTable(i).[PRC_REF], dOperDay);
	
					if bFindPrcRule then
						-- Если правила есть, инициализируем коллекцию для работы с массивом
						p_tPrcTable(i).[FL_RULES]%collection := p_rCred%id;
					end if;
				end if;
			end if;
			--^-- BS00133979
			exit;		
		end loop;
		i := i + 1;
	end loop;	
end;

-----------------------------------------------------------------------------------------------------------------
-- Заполнение таблицы комиссий
-- Функция также вызывается в продукте Гарантии, поэтому в ней учтены особенности данного продукта
-----------------------------------------------------------------------------------------------------------------
public procedure FillComissTable
		( p_aComissArr						[PR_CRED].[COMISS_ARR]%type
		, p_tComisTable		in	out	nocopy	&LCONST.TBL_DEBT_COMISS_PRC
		)
is
	i integer;
	rProd ref [PRODUCT];
	tDebts TYPE_NUMBER_TABLE;
	
	function getComisIdx
			( p_rDebt ref [VID_DEBT]
			) return number
	is
		nItem number;
	begin
		nItem := p_tComisTable.first;
		while nItem is not null loop
			if p_tComisTable(nItem).[DEBT] = p_rDebt then
				exit;
			end if;
			nItem := p_tComisTable.next(nItem);
		end loop;
		return nItem;
	end;
	rVidDebt	ref [VID_DEBT];
	sProdClass		varchar2(16);
begin
	p_tComisTable.delete;
	i := 1;
	rProd := p_aComissArr%parent;
	sProdClass := rProd%class;
	tDebts := TYPE_NUMBER_TABLE();
	
	for (	select x( x.[DEBT] : Debt
					, x.[COMIS] : Comis
					, x.[DEBT].[TYPE_DEBT] : TypeDebt
					, x.[IMPORTANCE] : Imp
					)
			in p_aComissArr
			where x.[COMIS] is not null or x.[DEBT] in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY)
			order by upper(x.[DEBT].[NAME]), x%id	-- BS00135391. Записи в гриде будут упорядочены по наименованию задолженности и ID записи
		)
	loop
		p_tComisTable(i).[DEBT]  := x.Debt;
		p_tComisTable(i).[COMIS] := x.Comis;
		-- 1) затрата, 2) комиссия, null) - прочее
		p_tComisTable(i).[PRIORITY] := case
											when x.TypeDebt = &LCONST.TD_EXPENSE then 1
											when x.TypeDebt = &LCONST.TD_COMMISS_PRC then 2
											when sProdClass = 'GUARANTIES' and x.TypeDebt = &LCONST.TD_COMMISS_OPER then 2 -- в продукте Гарантии операционные комиссии также классифицируются
											else null
										end;
		p_tComisTable(i).[CHK] := x.[DEBT] in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY);
		-- Существенность
		p_tComisTable(i).[IMPORTANCE] := x.Imp;
		
		tDebts.extend;
		tDebts(tDebts.count) := x.Debt;
		
		i := i + 1;
	end loop;
	
	&debug('FillComissTable: проверка на признание:', 0)	
	if sProdClass = 'GUARANTIES' then
		for (	select distinct op (coalesce(d1.column_value,d2.column_value) : vid_debt)
				in	(	select g (po.[OPER] : oper)
						in	::[GUARANTIES]
							,([PLAN_OPER] collections po)
						where	g = rProd
								and g.[LIST_PLAN] = po%collection
						union
						select g2 (fo.[OPER] : oper)
						in	::[GUARANTIES]
							,([FACT_OPER] collections fo)
						where	g2 = rProd
								and g2.[LIST_FACT] = fo%collection
					)
					, (::[VID_OPER_DOG] all vod)
					, (tDebts d1)
					, (tDebts d2)
			where	op.oper = vod
					and vod.[VID_DEBT] = d1.column_value (true)
					and vod.[VID_DEBT_DT] = d2.column_value (true)
					and (d1.column_value is not null or d2.column_value is not null)
			)
		loop
			rVidDebt%id := op.vid_debt;		
			&debug('FillComissTable: найдена в операциях задолженность '||rVidDebt.[CODE], 0)
			i := getComisIdx(rVidDebt);
			if i is not null then
				&debug('FillComissTable: 	+ задолженность найдена в комиссиях, отмечаем, что признана i='||i, 0)
				p_tComisTable(i).[COPY_SCHEME] := true;-- в гриде отмечает записи, по которым прошло начисление
			end if;
		end loop;
	end if;
end;

-----------------------------------------------------------------------------------------------------------------
-- Запись в базу таблицы комиссий и процентных схем
-- Функция также вызывается в продукте Гарантии, поэтому в ней учтены особенности данного продукта
-----------------------------------------------------------------------------------------------------------------
public procedure SaveComissTable
		( aComiss 							[PR_CRED].[COMISS_ARR]%type
		, Curr_Comis_Table	in	out	nocopy	&LCONST.TBL_DEBT_COMISS_PRC
		, Curr_Prc_Table 	in	out nocopy	&LCONST.TBL_VIEW_PRC_SCH
		)
is
	rScheme 	ref [DEBT_COMISS_PRC];
	rDebt 		ref [VID_DEBT];
	Debt_id 	ref [DEBT_COMISS_PRC];
	Debt_Table 	[DEBT_COMISS_PRC]%rowtable;
	num 		integer;
	nIdx		number;
	nItem	 	number;
begin
	select x( x%rowtype([OBJECT])
			, x%rowtype('nosys')
			)
	in aComiss all
	into Debt_Table%rowtype;
	num := Debt_Table%id.count;
 	
	-- Сохраняем комиссии
	nIdx := Curr_Comis_Table.first;
 	while nIdx is not null loop
		if	Curr_Comis_Table(nIdx).COMIS is not null and Curr_Comis_Table(nIdx).DEBT is not null -- есть тариф и есть задолженность
			or Curr_Comis_Table(nIdx).DEBT in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY)  -- или задолженности без тарифа:
																															 --   комиссия за выдачу гарантии (функция вызывается из конструктора в продукте Гарантии) или
		then																												 --   комиссия за открытие лимита/счета
			-- Если была комиссия по этой задолженности, то обновляем запись. Иначе создаем новую.
			update x( x.[COMIS] = Curr_Comis_Table(nIdx).[COMIS]
					, x.[IMPORTANCE] = nvl(Curr_Comis_Table(nIdx).[IMPORTANCE], false)
					)
			in aComiss
			where x.[DEBT] = Curr_Comis_Table(nIdx).DEBT;
			
			if rownum = 0 then
				aComiss.[NEW#AUTO](
					P_DEBT == Curr_Comis_Table(nIdx).[DEBT],
					P_COMIS == Curr_Comis_Table(nIdx).[COMIS],
					P_CHK_TYPE == case when Curr_Comis_Table(nIdx).DEBT in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY) then 0 else 4 end,
					P_IMPORTANCE == nvl(Curr_Comis_Table(nIdx).[IMPORTANCE], false));
			end if;
		
		elsif Curr_Comis_Table(nIdx).COMIS is not null and Curr_Comis_Table(nIdx).DEBT is null then
			pragma error('Для комиссии необходимо указать вид задолженности!');
			
		elsif
			Curr_Comis_Table(nIdx).COMIS is null and --тариф не заполнен
			Curr_Comis_Table(nIdx).DEBT is not null and --задолженность заполнена
			Curr_Comis_Table(nIdx).DEBT not in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY) -- и это не единовременная комиссия за выдачу гарантии (функция вызывается из конструктора в продукте Гарантии)
		then
			pragma error('Необходимо указать комиссию для вида задолженности!');
		end if;
		
		nIdx := Curr_Comis_Table.next(nIdx);
	end loop;

	-- Сохраняем процентные схемы
	-- В реквизите STOP_CALC в таблице для гарантий хранится признак существенности процентной задолженности
	if Curr_Prc_Table.first is not null then
		for i in Curr_Prc_Table.first .. Curr_Prc_Table.last loop
			if Curr_Prc_Table(i).PRC_REF is not null then
				--Если была проц. схема по этой задолженности, то обновляем запись. Иначе создаем новую.
				rDebt := null;
				for (	select d(d : id)
						in ::[VID_DEBT] all
						where d.[CODE] = Curr_Prc_Table(i).[REQ_NAME]
					)
				loop
					rDebt := d.id;
					exit;
				end loop;
				
				if rDebt is not null then
					-- Если была проц. схема по этой задолженности, то обновляем запись. Иначе создаем новую.
					rScheme := null;		
					for (	select s(s : id)
							in aComiss all
							where s.[DEBT] = rDebt
						)
					loop
						rScheme := s.id;
						exit;
					end loop;		
					if rScheme is not null then
						update x( x.[PRC_SCHEME] = Curr_Prc_Table(i).PRC_REF
								, x.[FROM_HL_CRED] = Curr_Prc_Table(i).FROM_HL_CRED
								, x.[IMPORTANCE] = coalesce(Curr_Prc_Table(i).STOP_CALC, false)
								)
						in aComiss
						where x%id = rScheme;
					else
						aComiss.[NEW#AUTO](
							  rDebt/*P_DEBT*/		--Задолженность
							, null/*P_COMIS*/		--Комиссия
							, Curr_Prc_Table(i).PRC_REF/*P_SCHEME*/		--Процентная схема
							, null/*P_PRIORITY*/		--Индивидуальный приоритет
							, null/*P_COPY_SCHEME*/		--Создавать копию схемы
							, 5/*P_CHK_TYPE*/		--Для проверки при обращении извне
							, null/*P_DEPART*/		--Подразделение
							, null/*P_PAYER*/		--Плательщик по задолженности
							, Curr_Prc_Table(i).FROM_HL_CRED/*P_FROM_HL_CRED*/		--Передавать в транш
							, false
							);
					end if;
				else
					stdio.PUT_LINE_BUF('В справочнике видов задолженностей не найдена запись с кодом проц. схемы = ' || V_PRC_SCH_TBL(i).[REQ_NAME]);
				end if;
			end if;
		end loop;
	end if;

-- Удаление из массива неиспользуемых задолженностей
	if num > 0 then
		for i in 1 .. num loop

			Debt_id := Debt_Table%id(i);
			if Debt_id.[DEBT] in (&VD_KOMM_GARANT, &VD_KOMM_FOR_PAY) then
				continue;
			end if;		
			if Debt_Table.[COMIS](i) is not null then
				nItem := Curr_Comis_Table.first;
				while nItem is not null loop
					if Curr_Comis_Table(nItem).DEBT = Debt_Table.[DEBT](i) then
						Debt_id := 0;
						exit;
					end if;
					nItem := Curr_Comis_Table.next(nItem);
				end loop;
			end if;
			
			if Debt_Table.[PRC_SCHEME](i) is not null then
				if Curr_Prc_Table.first is not null then
					for k in Curr_Prc_Table.first .. Curr_Prc_Table.last loop
						if Curr_Prc_Table(k).PRC_REF is not null then
							rDebt := null;
							for (	select d(d : id)
									in ::[VID_DEBT] all
									where d.[CODE] = Curr_Prc_Table(k).[REQ_NAME]
								)
							loop
								rDebt := d.id;
								exit;
							end loop;
							
							if rDebt is not null then
								if rDebt = Debt_Table.[DEBT](i) then
									Debt_id := 0;
									exit;
								end if;
							else
								::[RUNTIME].[STDIO].put_line_buf('В справочнике видов задолженностей не найдена запись с кодом проц. схемы = ' || V_PRC_SCH_TBL(i).[REQ_NAME]);
							end if;
						end if;
					end loop;
				end if;

				if nvl(Debt_Table.[PRIORITY](i), 0) > 0 then
					if Debt_id > 0 then
						update rScheme(rScheme.[PRC_SCHEME] = null)
						in aComiss
						where rScheme%id = Debt_id;						
						Debt_id := 0;
					end if;

				elsif Debt_id > 0 and (Debt_Table.[JOURNAL_PRC](i)%size(0) > 0) then
						update rScheme(rScheme.[PRC_SCHEME] = null)
						in aComiss
						where rScheme%id = Debt_id;						
						Debt_id := 0;
				end if;
			end if;			
			if (nvl(Debt_Table.[PRIORITY](i), 0) < 1) and (Debt_id > 0) and (Debt_Table.[JOURNAL_PRC](i)%size(0) = 0) and (Debt_Table.[PRIOR_BY_TIP](i)%size(0) = 0) then
				delete x in aComiss where x%id = Debt_id;
			end if;
		end loop;
	end if;
end;

function get_date_ending_max (
		kind_cred 	[KIND_CREDITS]
	   ,class_prod 	varchar2(20)
	   ,date_give 	date
	   ,date_begin 	date
	   ,calend 		ref [OBJECT] default null)
return date is
begin
	if kind_cred.[MAX_PERIOD_NUM] is not null and kind_cred.[MAX_PERIOD_MS] is not null and class_prod <> 'OVERDRAFTS' then
		return ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( nvl(date_give, date_begin), kind_cred.[MAX_PERIOD_NUM], kind_cred.[MAX_PERIOD_MS], null, null, kind_cred.[PERIOD_WD], calend);
	end if;	
	return null;
end;

procedure disable_when_gen_frame is
begin
	[CSMD].Disable(V_DEST_STR, 'CLIENT');
	[CSMD].Disable(V_DEST_STR, 'FT_CREDIT');
	[CSMD].Disable(V_DEST_STR, 'P_FILIAL');
	[CSMD].Disable(V_DEST_STR, 'P_DEPART');
end;

public function Check_Transh_Acc( FT_CREDIT		[FT_MONEY_REF]
								, P_FILIAL		[BRANCH_REF]
								, CLIENT		[CLIENT_REF]
								, PERIOD		number
								, ACOUNT		out [AC_FIN_REF]
								, hl_cred		ref	[PR_CRED]
								, ACCs_ID		out	varchar2(32000)
								, cred_dog		ref	[PR_CRED]
								, V_DATE_GIVE	[DATE]
								, DATE_ENDING	[DATE]
								) return boolean
is
begin
	return ::[PR_CRED].[NEW_DOG_LIB].Check_Transh_Acc(
		FT_CREDIT
		,P_FILIAL
		,CLIENT
		,PERIOD
		,ACOUNT
		,hl_cred
		,ACCs_ID
		,cred_dog
		,V_DATE_GIVE
		,DATE_ENDING
	);
end;

public procedure check_plan_param	( PLAN_END_DATE			[DATE]
									, PLAN_CALC_BEGIN_DATE	[DATE]
									, PLAN_PAY_BEGIN_DATE	[DATE]
									, PLAN_DAY_CALC			[SHORT2]
									, PLAN_DAY_PAY			[SHORT2]
									)
is
begin
	if PLAN_END_DATE < PLAN_CALC_BEGIN_DATE then
		pragma error('Дата окончания планирования не может быть меньше даты начала расчета');
	end if;
	if PLAN_END_DATE < PLAN_PAY_BEGIN_DATE then
		pragma error('Дата окончания планирования не может быть меньше даты начала планирования');
	end if;
	if PLAN_DAY_CALC > 31 then
		pragma error('День месяца для расчета не может быть больше 31');
	end if;
	if PLAN_DAY_PAY > 31 then
		pragma error('День месяца для гашения не может быть больше 31');
	end if;
end;


public procedure validate_form	( high_level	ref [PR_CRED]
								, type_cred		ref [TYPES_CRED]
								, cr_class			varchar2(20)
								, bCard				boolean
								, bOpenDep			boolean
								, V_VALID	in out	varchar2(32000)
								, val_class			boolean default false
								)
is
begin
	if type_cred = &LCONST.TC_CRED_OVER then
		[CSMD].Show(V_VALID, 'V_MAX_LIMIT_SALDO', 'V');
	else
		[CSMD].Hide(V_VALID, 'V_MAX_LIMIT_SALDO', 'V');
	end if;	

	if cr_class != 'OVERDRAFTS' then
		type_cred := nvl(type_cred, &LCONST.TC_CRED_CONT);
		if type_cred = &LCONST.TC_CRED_LINE then
			[CSMD].Hide(V_VALID, 'V_LIMIT_SALDO', 'V');
			[CSMD].Show(V_VALID, 'V_COPY_TO_TRANSH', 'V');
			[CSMD].Show(V_VALID, 'V_TRANSH_PERIOD_NUM', 'V');
			[CSMD].Show(V_VALID, 'V_TRANSH_PERIOD_UNIT', 'V');
		elsif type_cred = &LCONST.TC_CRED_OVER then
			[CSMD].Show(V_VALID, 'V_LIMIT_SALDO', 'V');
			[CSMD].Show(V_VALID, 'V_COPY_TO_TRANSH', 'V');
			[CSMD].Show(V_VALID, 'V_TRANSH_PERIOD_NUM', 'V');
			[CSMD].Show(V_VALID, 'V_TRANSH_PERIOD_UNIT', 'V');
		elsif type_cred = &LCONST.TC_CRED_CONT then
			[CSMD].Hide(V_VALID, 'V_LIMIT_SALDO', 'V');
			[CSMD].Hide(V_VALID, 'V_COPY_TO_TRANSH', 'V');
			[CSMD].Hide(V_VALID, 'V_TRANSH_PERIOD_NUM', 'V');
			[CSMD].Hide(V_VALID, 'V_TRANSH_PERIOD_UNIT', 'V');
		end if;
		if high_level is not null then
			[CSMD].Show(V_VALID, 'V_LIMIT_CR', 'V');
			bMulticur := null;
			declare
				v_cannons	::[PR_CRED].[LIB_TUNE].t_Cannon_rec;
			begin
				v_cannons.[METACLASS]		:= 'PR_CRED';
				v_cannons.[KIND_CREDITS]	:= P_HIGH_LEVEL_CR.[KIND_CREDIT];
				v_cannons.[FT_MONEY]		:= P_HIGH_LEVEL_CR.[FT_CREDIT];
				bMulticur := nvl(::[PR_CRED].[LIB_TUNE].get_tune('ALLOW_MULTICUR', v_cannons, Oper_Day), false);
				&debug(&METHOD$||'.validate_form Признак мультивалютности: '||bMultiCur,0)
			end;
			if bMulticur then
				[CSMD].Enable(V_DEST_STR, 'FT_CREDIT');
			else
				[CSMD].Disable(V_DEST_STR, 'FT_CREDIT');
			end if;
		else
			[CSMD].Hide(V_VALID, 'V_LIMIT_CR', 'V');
			[CSMD].Enable(V_VALID, 'FT_CREDIT');
		end if;
		if nvl(bCard, false) then
			[CSMD].Show(V_VALID, 'P_OVD_ACCOUNT');
			[CSMD].Show(V_VALID, 'P_PRODUCT');
			if cr_class = 'KRED_PERS' then [CSMD].Show(V_VALID, 'V_OPEN_DEP', 'V'); end if;
		else
			[CSMD].Hide(V_VALID, 'P_OVD_ACCOUNT');
			[CSMD].Hide(V_VALID, 'P_PRODUCT');
			[CSMD].Hide(V_VALID, 'V_OPEN_DEP', 'V');
		end if;
	end if;

	if nvl(val_class, false) then
		if cr_class = 'OVERDRAFTS' then
			[CSMD].Show(V_VALID, 'P_ACCOUNT', 'V');
			[CSMD].Disable (V_VALID, 'V_ONE_DAY', 'V');
			[CSMD].Disable (V_VALID, 'V_DATE_ENDING_MAX', 'V');
			[CSMD].ShowS(V_VALID, 'X');
			[CSMD].Hide(V_VALID, 'V_LIMIT_SALDO', 'V');
			[CSMD].Hide(V_VALID, 'V_COPY_TO_TRANSH', 'V');
			[CSMD].Hide(V_VALID, 'V_LIMIT_CR', 'V');
			[CSMD].Show(V_VALID, 'P_G_AGRIMENT');
			[CSMD].Hide(V_VALID, 'P_HIGH_LEVEL_CR', 'V');
			[CSMD].Show(V_VALID, 'P_CALC_TYPE');
			[CSMD].Show(V_VALID, 'P_OVD_ACCOUNT');
			[CSMD].Show(V_VALID, 'P_PRODUCT');
			[CSMD].Show(V_VALID, 'V_OPEN_DEP', 'V');
		else
			[CSMD].Hide(V_VALID, 'P_ACCOUNT', 'V');
			[CSMD].HideS(V_VALID, 'X');
			[CSMD].Hide(V_VALID, 'P_G_AGRIMENT');
			[CSMD].Hide(V_VALID, 'P_CALC_TYPE');
			if bCard and cr_class != 'KRED_PERS' then
				[CSMD].Hide(V_VALID, 'V_OPEN_DEP', 'V');
			end if;
			if not nvl(bCard, false) then
				[CSMD].Hide(V_VALID, 'P_OVD_ACCOUNT');
				[CSMD].Hide(V_VALID, 'P_PRODUCT');
				[CSMD].Hide(V_VALID, 'V_OPEN_DEP', 'V');
			end if;
		end if;
	end if;
	if nvl(bOpenDep, false) then
		[CSMD].Disable(V_VALID, 'P_OVD_ACCOUNT');
		[CSMD].Disable(V_VALID, 'P_PRODUCT');
	end if;
end;

-- валидация экранной формы при наличии/отсутствии ген. соглашения на овердрафт
public procedure validate_gen_arg	( gen_arg	ref [GEN_AGREEMENT]
									, V_VALID	in out varchar2(32000)
									)
is
begin
	if not gen_arg is null then
		[CSMD].Disable(V_VALID, 'CLIENT');
		[CSMD].Disable(V_VALID, 'P_PRODUCT');
		[CSMD].Disable(V_VALID, 'FT_CREDIT');
		[CSMD].Disable(V_VALID, 'P_FILIAL');
		[CSMD].Disable(V_VALID, 'P_OVD_ACCOUNT');
		[CSMD].Disable(V_VALID, 'P_DEPART');
	else
		[CSMD].Enable(V_VALID, 'CLIENT');
		[CSMD].Enable(V_VALID, 'P_PRODUCT');
		[CSMD].Enable(V_VALID, 'FT_CREDIT');
		[CSMD].Enable(V_VALID, 'P_FILIAL');
		[CSMD].Enable(V_VALID, 'P_OVD_ACCOUNT');
		[CSMD].Enable(V_VALID, 'P_DEPART');
	end if;
end;

public procedure validate_invoice	( invoice	boolean
									, V_VALID	in out varchar2(32000)
									, cr_class	varchar2(20)
									)
is
begin
	if invoice then
		[CSMD].Command(V_VALID, 'Grid24.Visible = true');
		[CSMD].Disable(V_VALID, 'PERIOD');
		[CSMD].Disable(V_VALID, 'P_PERIOD_UNIT');
		[CSMD].Disable(V_VALID, 'P_PERIOD_WD');
		[CSMD].Disable(V_VALID, 'DATE_ENDING');
		[CSMD].Disable(V_VALID, 'P_HIGH_LEVEL_CR', 'V');
		[CSMD].Disable(V_VALID, 'V_DATE_ENDING_MAX', 'V');
		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_YEAR'); --alex_sy у линии до востребования нет признака процентов
	else
		[CSMD].Command(V_VALID, 'Grid24.Visible = false');
		[CSMD].Enable(V_VALID, 'PERIOD');
		[CSMD].Enable(V_VALID, 'P_PERIOD_UNIT');
		[CSMD].Enable(V_VALID, 'P_PERIOD_WD');
		[CSMD].Enable(V_VALID, 'DATE_ENDING');
		[CSMD].Enable(V_VALID, 'P_HIGH_LEVEL_CR', 'V');
		[CSMD].Enable(V_VALID, 'V_DATE_ENDING_MAX', 'V');
		[CSMD].Enable(V_VALID, 'P_FOR_OPEN_YEAR'); --alex_sy у линии до востребования нет признака процентов
	end if;
end;

public procedure validate_status( status	ref [COM_STATUS_PRD]
								, V_VALID	in out varchar2(32000)
								)
is
begin
	if status != &LCONST.STATUS_WAIT_CONF then
		[CSMD].Disable(V_VALID, 'DATE_BEGIN');
		[CSMD].Disable(V_VALID, 'PERIOD');
		[CSMD].Enable (V_VALID, 'V_PARAM_FOR_PLAN.PERIOD.NAME','V');
		[CSMD].Enable (V_VALID, 'V_PARAM_FOR_PLAN.PERIOD_COUNT','V');
		[CSMD].Disable(V_VALID, 'P_PERIOD_UNIT');
		[CSMD].Disable(V_VALID, 'P_PERIOD_WD');
		[CSMD].Disable(V_VALID, 'DATE_ENDING');
		[CSMD].Disable(V_VALID, 'P_HIGH_LEVEL_CR','V');
		[CSMD].Disable(V_VALID, 'P_KIND_CREDIT');
		[CSMD].Disable(V_VALID, 'CLIENT');
		[CSMD].Disable(V_VALID, 'SUMMA');
		[CSMD].Disable(V_VALID, 'FT_CREDIT');
		[CSMD].Disable(V_VALID, 'P_SIGN_UP', 'V');
		[CSMD].Disable(V_VALID, 'V_DATE_GIVE', 'V');
		[CSMD].Disable(V_VALID, 'P_OPER_WAY_OUT');
		[CSMD].Disable(V_VALID, 'V_CREDIT_ARR', 'V');
		[CSMD].Disable(V_VALID, 'V_PRC_RATE', 'V');
		[CSMD].Disable(V_VALID, 'V_PRJ_KIND_CRED', 'V');
		[CSMD].Disable(V_VALID, 'V_LIMIT_SALDO', 'V');
		[CSMD].Disable(V_VALID, 'V_MAX_LIMIT_SALDO', 'V');
		[CSMD].Disable(V_VALID, 'P_PRODUCT');
		[CSMD].Disable(V_VALID, 'P_OVD_ACCOUNT');
		[CSMD].Disable(V_VALID, 'V_OPEN_DEP', 'V');
		[CSMD].Disable(V_VALID, 'P_G_AGRIMENT');
		[CSMD].Disable(V_VALID, 'P_CALC_TYPE');
		[CSMD].Disable(V_VALID, 'V_TO_BKI', 'V');
		[CSMD].Disable(V_VALID, 'NUM_DOG');
		[CSMD].Disable(V_VALID, 'P_BALLOON_PAYMENT');
		[CSMD].DisableS(V_VALID,'Button13');
		[CSMD].Disable(V_VALID, 'V_TRANSH_PERIOD_NUM', 'V');
		[CSMD].Disable(V_VALID, 'V_TRANSH_PERIOD_UNIT', 'V');
		--конструктор. блокируем часть кнопок. остальной функционал блокируется в вызываемых операциях
		[CSMD].Disable(V_VALID, 'V_USE_PLAN_RULE', 'V');
		[CSMD].Command(V_VALID, 'BtnPRRecalc.Enabled = False');
		--по рабочему договору недоступна кнопка "создать по умолчанию"
		[CSMD].Command(V_VALID, 'ButtonDefaultCreate.Enabled = False');
	end if;
end;

--Добавляет или удаляет из массива t_tbl_DEBT_COMISS_PRC комиссию за открытие лимита/счета в зависимости от p_nSummaCom
--Возвращает индекс комиссии в массиве
function syncForPayComis
		( p_tCurrComis	in	out	nocopy	t_tbl_DEBT_COMISS_PRC	
		, p_nSummaCom					[SUMMA]
) return integer
is
	nComisIdx		integer;
	oRec			[DEBT_COMISS_PRC];
begin
	&debug('syncForPayComis: синхронизация данных по комиссии за выдачу/открытие, МассивКомиссий = '||p_tCurrComis.count||'; SUMMA_COMM = '||p_nSummaCom, 0)
	--Найдем комиссию в массиве
	if p_tCurrComis.count > 0 then
		for i in p_tCurrComis.first..p_tCurrComis.last where p_tCurrComis(i).[DEBT] = &VD_KOMM_FOR_PAY
		loop
			nComisIdx := i;
			&debug('syncForPayComis: найдена комиссия за выдачу/открытие (id = '||nComisIdx||'), существенность = '||bool_char(p_tCurrComis(i).[IMPORTANCE]), 0)
			exit;
		end loop;
	end if;
	
	if nvl(p_nSummaCom, 0) = 0 then
		--если сумма комиссии не заведена, а в массиве она есть, то удалить ее из массива
		if nComisIdx is not null then
			p_tCurrComis.delete(nComisIdx);
			nComisIdx := null;
			&debug('syncForPayComis: удаление комиссии за выдачу/открытие из массива комиссий nComisIdx = '||nComisIdx, 0)
		end if;
	else
		--если комиссия заведена на основной вкладке
		if nComisIdx is null then
			--но записи нет в массиве то добавим запись
			oRec.[DEBT] := &VD_KOMM_FOR_PAY;
			oRec.[PRIORITY] := 2; --Процентная комиссия
			oRec.[CHK] := true;
			nComisIdx := coalesce(p_tCurrComis.last, 0) + 1;
			p_tCurrComis(nComisIdx) := oRec;
			&debug('syncForPayComis: добавили комиссию в массив', 0)
		end if;
	end if;
	return nComisIdx;
end;

public procedure validate_comis	(
	  p_nForOpenPay  				[SUMMA]
	, ft_cred		 		ref 	[FT_MONEY]
	, bIsDisable	 				boolean
	, p_info						varchar2(2000)
	, p_rCred				ref		[PR_CRED]
	, ft_comis		in out	ref 	[FT_MONEY]
	, bool_comis	in out 			boolean
	, bool_year		in out 			boolean
	, V_VALID		in out 			varchar2(32000)
	, p_tCurrComis	in out nocopy	t_tbl_DEBT_COMISS_PRC
) is
	iComisIdx	integer;
begin
	&debug('validate_comis: p_info='||p_info||';bIsDisable='||bool_char(bIsDisable)||';p_nForOpenPay='||p_nForOpenPay, 0)
	
	if nvl(bIsDisable,false) then
 		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_PAY', 'P');
 		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_BOOL', 'P');
 		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_FN', 'V');
 		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_YEAR', 'P');
 		[CSMD].Disable(V_VALID, 'P_LMT_DAY_TO_PAY', 'P');
 	else
		if p_info = 'P_FOR_OPEN_BOOL' then
		 	if nvl(bool_comis,false) then
	 	 		ft_comis := ft_cred;
	 	 		[CSMD].Disable(V_VALID, 'P_FOR_OPEN_FN', 'V');
	 	 	else
	 	 		bool_year := false;
	 	 		[CSMD].Enable(V_VALID, 'P_FOR_OPEN_FN', 'V');
		 	end if;
		elsif p_info = 'P_FOR_OPEN_YEAR' then
			if nvl(bool_year,false) then
				bool_comis := true;
				ft_comis := ft_cred;	-- BFS00027399
				[CSMD].Disable(V_VALID, 'P_FOR_OPEN_FN', 'V');	-- BFS00029664
			end if;
		elsif p_info = '%VAR%.P_FOR_OPEN_FN' then
			if ft_comis != ft_cred then
	 			[CSMD].Disable(V_VALID, 'P_FOR_OPEN_BOOL');
	 		else
	 			[CSMD].Enable(V_VALID, 'P_FOR_OPEN_BOOL');
			end if;
		elsif p_info = 'FT_CREDIT' then
			if bool_comis then
	 			ft_comis := ft_cred;
	 			[CSMD].Disable(V_VALID, 'P_FOR_OPEN_FN', 'V');
	 		else
	 			[CSMD].Enable(V_VALID, 'P_FOR_OPEN_FN', 'V');
			end if;
		end if;
		
		if p_info in ('P_FOR_OPEN_PAY', 'P_FOR_OPEN_BOOL', 'P_FOR_OPEN_YEAR', '%VAR%.P_FOR_OPEN_FN', 'FT_CREDIT') then
			iComisIdx := syncForPayComis(p_tCurrComis, p_nForOpenPay);
			if iComisIdx is not null then
				p_tCurrComis(iComisIdx).[IMPORTANCE] := nvl(setImportanceDebt(p_tCurrComis(iComisIdx), p_rCred), false);
				&debug('validate_comis: синхронизировали с массивом комиссий, существенность='||bool_char(p_tCurrComis(iComisIdx).[IMPORTANCE]), 0)
			end if;
		end if;
	end if;

	&debug('validate_comis: V_VALID='||V_VALID, 0)
end;

public function get_way ( way_code varchar2(2)
						) return ref [WAY_KRED]
is
rWayKred	ref [WAY_KRED];
begin
	for (select w(w : id) in ::[WAY_KRED] where w.[CODE] = way_code and rownum < 2)
	loop
		rWayKred := w.id;
	end loop;
	
	return rWayKred;
end;

public function validate_oper_way	 (cr_class			varchar2(20)
									, ft_cred			ref [FT_MONEY]
									, P_OPER_WAY_OUT	in out ref [WAY_KRED]
									, V_VALID			in out varchar2(32000)
									, rPs 				ref [PS] default null
									) return varchar2(2)
is
begin
	if	( cr_class = 'KRED_PERS' or ( rPs is not null and rPs = ClientPsFrom ) )
	and	ft_cred = ::[SYSTEM].[SYS_MAIN_VAL] then
		if P_OPER_WAY_OUT is null then
			P_OPER_WAY_OUT := get_way('02');
		else
			[CSMD].Enable(V_VALID,'P_OPER_WAY_OUT');
		end if;
	else
		if P_OPER_WAY_OUT is null or P_OPER_WAY_OUT.[CODE] = '02' then
			P_OPER_WAY_OUT := get_way('01');
		else
			[CSMD].Disable(V_VALID,'P_OPER_WAY_OUT');
		end if;
	end if;
	return null;
end;

procedure set_kind_kred(p_info in out varchar2(2000)
						,v_prj_kind_cred in out ref [KIND_PROJECT]
						,p_kind_credit in out ref [KIND_CREDITS]
						,p_date_begin in date
						,P_SIGN_UP in out boolean
						,P_OPEN_ACC in out boolean
						,rCred	ref [PR_CRED]
						,p_bDef_Ind	in out boolean
						)
is
begin
	if p_info = '%VAR%.V_PRJ_KIND_CRED' then
		if (v_prj_kind_cred.[CRED] is not null) and (nvl(p_kind_credit,-1) != v_prj_kind_cred.[CRED]) then
			p_info := 'P_KIND_CREDIT';
			p_kind_credit := v_prj_kind_cred.[CRED];
		elsif p_kind_credit.[TYPE_PROJECT] != v_prj_kind_cred then
			p_info := 'P_KIND_CREDIT';
			p_kind_credit := null;
		end if;
	elsif p_info = 'P_KIND_CREDIT' then
		v_prj_kind_cred := nvl(p_kind_credit.[TYPE_PROJECT], v_prj_kind_cred);
		rCred.[KIND_CREDIT] := p_kind_credit;
		rCred.[PRJ_KIND_CRED] := v_prj_kind_cred;
	elsif p_info = '%VAR%.P_SIGN_UP' then			
		if P_SIGN_UP then
			p_bDef_Ind := coalesce(rCred.[GET_BOOL_TUNE](::[PRODUCT].[TUNE_CODES].CODE_IFRS_DEFAULT), false);
		else
			P_OPEN_ACC	:= false;
			p_bDef_Ind := false;
		end if;
	elsif p_info = '%VAR%.P_OPEN_ACC' then
		if nvl(P_OPEN_ACC, false) then
			P_SIGN_UP	:= true;	
			p_bDef_Ind := coalesce(rCred.[GET_BOOL_TUNE](::[PRODUCT].[TUNE_CODES].CODE_IFRS_DEFAULT), false);
		end if;
	elsif p_info = 'P_DEF_IND' then
		if nvl(p_bDef_Ind, false) then
			P_SIGN_UP	:= true;
		end if;
	end if;
end;

-- BFS00028471 Получаем значение настройки "Создавать копии процентных схем для траншей"
function need_copyPrcSch_for_tranches(cred_class varchar2(16)) return boolean is
	sAdds varchar2(2000);
	bCopyPrcSchToTranches boolean;
begin
	&debug('.need_copyPrcSch_for_tranches: cred_class = '||cred_class, 0)
	sAdds := ::[FP_TUNE].[LIB].set_canons('METACLASS', cred_class);
	bCopyPrcSchToTranches := ::[FP_TUNE].[LIB].get_bool_value('COPY_PRC_SCH_TO_TRANCHES', sAdds, '0');

	&debug('.need_copyPrcSch_for_tranches: bCopyPrcSchToTranches = '||bool_char(bCopyPrcSchToTranches), 0)
	return bCopyPrcSchToTranches;
end;

public procedure get_def_prc_schemes
		( P_KIND_CREDIT 			[KIND_CREDITS].[COMISS_ARR]%type
		, FT_CREDIT 			ref [FT_MONEY]
		, DATE_BEGIN 				date
		, V_COMISS_ARR				[PR_CRED].[COMISS_ARR]%type
		, rDepart 				ref [DEPART]
		, V_PRC_SCH_TBL		in	out	&LCONST.TBL_VIEW_PRC_SCH
		, V_CREDIT_ARR		in	out	[PRC_SCHEME].[LIST_SCH_PRC]%type
		, V_PRC_RATE		in	out	number
		, rCred					ref [PR_CRED]
		, FILL_TABLE 				boolean default null
		, P_NEW_ONLY				boolean default null 	-- копировать только новые (при дополнении схем КВУ схемами вида кредита)
		, P_FROM_HL					boolean default null	-- контролировать признак "передавать в транш" (копируем с линии)
		)
is
	tmpArr				::[PRC_SCHEME].[LIST_SCH_PRC]%type;
	tmpRate				number;
	rTmpSch			ref [PRC_SCHEME];
	sADD_PRC			varchar2(100);
	aLIST_SCH_PRC		[ARR_ARC_SCH_PRC];
	aArrDependPrc		[ARR_DEPEND_PRC];
	r_DependPrc		ref	[DEPEND_PRC];
	rARC_SCH_PRC	ref	[ARC_SCH_PRC];
	FindNothing			boolean;
	sCopied				varchar2(2000); 	-- скопированные из вида кредита схемы
	bTuneCopyToTransh 	boolean := false;
	
	Oper_Day			date;
	bImportance			boolean;
	oDebtComis			[DEBT_COMISS_PRC];
	oCred				[PR_CRED];
	v_use_round			[CASE_BETWEEN_TWO];
begin
	if P_KIND_CREDIT is null then
		return;
	end if;

 	oCred := rCred;
 	Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(oCred.[FILIAL]);
	P_NEW_ONLY 	:= nvl(P_NEW_ONLY, false);
	P_FROM_HL	:= nvl(P_FROM_HL, false);

	-- определим схемы по каким видам уже присутствуют в массиве
	&debug('.get_def_prc_schemes: rCred = '||rCred%id||' только новые = '||P_NEW_ONLY||' Копируем с линии = '||P_FROM_HL||' Oper_Day = '||to_char(Oper_Day), 0)
	sCopied := ';';
	if P_NEW_ONLY then
		for (	select Debts(Debts.[DEBT]: DEBT)
				in	V_COMISS_ARR all
				where	Debts.[PRC_SCHEME] is not null
			)
		loop
			-- ведем список схем уже присутствующих схем
			sCopied := sCopied||Debts.DEBT||';';
		end loop;
	
	-- если не добавляем новое - очистим данные старые данные
	-- если добавляем то не надо - найдется значит обновится, а если не найдется то оставит целым ранее найденное
	else
		V_CREDIT_ARR := null;
		V_PRC_RATE	 := null;
	end if;
	
	FindNothing	 := true;
	if P_FROM_HL then -- если копируем с линии, смотрим настройку
		bTuneCopyToTransh := need_copyPrcSch_for_tranches(oCred%class);
		-- транши до востребования не создают копии схем
		bTuneCopyToTransh := bTuneCopyToTransh and not nvl(oCred.[HIGH_LEVEL_CR].[INVOICE], false);
	end if;
	
	for (	select Debts( Debts.[DEBT]			: DEBT
						, Debts.[DEBT].[NAME]	: NAME
						, Debts.[DEBT].[TYPE_DEBT]	: TYPE_DEBT
						, Debts.[PRC_SCHEME]	: PRC_SCHEME
						, Debts.[COPY_SCHEME]	: COPY_SCHEME
						, Debts.[PRIORITY]		: PRIORITY
						, Debts.[FROM_HL_CRED]	: FROM_HL_CRED
						, Debts.[IMPORTANCE]	: IMPORTANCE
						)
		in P_KIND_CREDIT all
		where	Debts.[PRC_SCHEME] is not null
				-- не контролировать признак  или передавать в транш, при этом задолженность ведется по всем или по нижнему уровню
				and (not P_FROM_HL or (nvl(Debts.[FROM_HL_CRED], false) = true and Debts.[DEBT].[TYPE_CALC_DEBT] in (&HL_LL, &LL) ))
				-- не только новые или отсутствует в массиве
				and (not P_NEW_ONLY or instr(sCopied, ';'||Debts.[DEBT]||';') = 0)
				and (nvl(Debts.[PRC_SCHEME].[VALUTA], nvl(FT_CREDIT,::[SYSTEM].[SYS_MAIN_VAL])) = nvl(FT_CREDIT, ::[SYSTEM].[SYS_MAIN_VAL]))	
				and ((nvl(Debts.[DEPART], 0) = nvl(rDepart, 0)) or (Debts.[DEPART] is null))
		)
	loop
		&debug('.get_def_prc_schemes: '||Debts.NAME||' fromHL = '||Debts.[FROM_HL_CRED]||' '||Debts.PRC_SCHEME.[NAME], 0)
		FindNothing := false;
		rTmpSch  	:= Debts.[PRC_SCHEME];
		sADD_PRC 	:= null;
	
		if	(nvl(Debts.[COPY_SCHEME], false) and not P_FROM_HL)  -- если не с линии то смотрим признак массива
			or (P_FROM_HL and bTuneCopyToTransh)
		then				-- если с линии копируем то смотрим настройку
			aLIST_SCH_PRC := next_value('SEQ_ID');
			&debug('.get_def_prc_schemes: Создаем копию схемы', 0)
			for	(	select	x_sch( x_sch.[DATE_BEG]		: DATE_BEG
								 , x_sch.[DATE_END]		: DATE_END
								 , x_sch.[EI_TVALID]	: EI_TVALID
								 , x_sch.[BANK_YEAR]	: BANK_YEAR
								 , x_sch.[FOST]			: FOST
								 , x_sch.[FPERIOD]		: FPERIOD
								 , x_sch.[DAYS_IN_PERIOD]: DAYS_IN_PERIOD
								 , x_sch.[CALC_EVERY_DAY]: CALC_EVERY_DAY
								 , x_sch.[NOT2ADD0]		: NOT2ADD0
								 , x_sch.[F_PRC_RATE]	: F_PRC_RATE
								 , x_sch.[LIST_DEPEND_PRC]: LIST_DEPEND_PRC
								 , x_sch.[L_SIMPLE_PRC]	: L_SIMPLE_PRC
								 , x_sch.[VAL_SIMPLE_PRC]: VAL_SIMPLE_PRC
								 , x_sch.[PRC_MAX]		: c_prc_max
								 , x_sch.[PRC_MIN]		: c_prc_min
								 )
					in rTmpSch.[LIST_SCH_PRC]
				)
			loop
				aArrDependPrc := next_value('SEQ_ID');
				for	(	select rDependPrc( rDependPrc.[FIX_SUMMA]	: FIX_SUMMA
										 , rDependPrc.[PERIOD]		: PERIOD
										 , rDependPrc.[PRC]			: PRC
										 , rDependPrc.[SUB_SUMMA]	: SUB_SUMMA
										 , rDependPrc.[SUMMA]		: SUMMA
										 )
						in x_sch.[LIST_DEPEND_PRC]
					)
				loop
					r_DependPrc := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewRecDepnPrc
								(	 P#PRC			== rDependPrc.[PRC]
									,P#PERIOD		== rDependPrc.[PERIOD]
									,P#SUMMA		== rDependPrc.[SUMMA]
									,P#FIX_SUMMA	== rDependPrc.[FIX_SUMMA]
									,P#SUB_SUMMA	== rDependPrc.[SUB_SUMMA]
									,P_ARC_SCH_PRC	== null
								);
					aArrDependPrc%insert(r_DependPrc);
				end loop;
	
				rARC_SCH_PRC := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewRecArch(
														  P#DATE_BEG		== x_sch.[DATE_BEG]	-- Дата начала действия
														, P#DATE_END		== x_sch.[DATE_END]	-- Дата окончания действия
														, P#EI_TVALID		== x_sch.[EI_TVALID]	-- Единица измерения в процентных схемах
														, P#BANK_YEAR		== x_sch.[BANK_YEAR]	-- Признак банковского года в 360 дней
														, P#FOST			== x_sch.[FOST]	-- Разбиение остатка по суммам в процентной схеме
														, P#L_SIMPLE_PRC	== x_sch.[L_SIMPLE_PRC]	-- Признак упрощенной схемы
														, P#VAL_SIMPLE_PRC	== x_sch.[VAL_SIMPLE_PRC]	-- Процент при упрощенной схеме
														, P#LIST_DEPEND_PRC	== aArrDependPrc	-- Список процентов в зависимости от сроков и сумм
														, P#FPERIOD			== x_sch.[FPERIOD]	-- Разбиение по срокам в процентной схеме
														, P#DAYS_IN_PERIOD	== x_sch.[DAYS_IN_PERIOD]	-- Количество дней в периоде процентной ставки
														, P_CALC_EVERY_DAY	== x_sch.[CALC_EVERY_DAY]	-- Ежедневный расчет процентов
														, P_NOT2ADD0		== x_sch.[NOT2ADD0]
														, P_F_PRC_RATE		== x_sch.[F_PRC_RATE]
														, P_PRC_MAX			== x_sch.C_PRC_MAX
														, P_PRC_MIN			== x_sch.C_PRC_MIN
														, P_DEPART			== oCred.[DEPART]
														, P_MetaClass		== oCred%class
														, P_PRC_SCHEME_ARC	== aLIST_SCH_PRC
														);
			end loop;
			
			v_use_round.[0] := 2;
			
			rTmpSch := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewSchemPrc
			(
				P#NAME				== substr(Debts.[NAME] || ' по договору No ' || oCred.[NUM_DOG], 1, 100)	 -- Наименование
				,P#P_PRIVATE		== rTmpSch.[P_PRIVATE]				 	-- Признак индивидуального использования
				,P#P_CREDIT	        == rTmpSch.[P_CREDIT]				 	-- Признак схемы по активному счету
				,P#LIST_SCH_PRC	    == aLIST_SCH_PRC						-- История схемы начисления процентов
				,P#USER_CREATE		== stdlib.userid						-- Создано пользователем
				,P#DATE_CREATE		== Oper_Day		-- Дата создания
				,P#DATE_USE_BEG		== rTmpSch.[DATE_USE_BEG]				-- Дата начала использования
				,P#DATE_USE_END		== rTmpSch.[DATE_USE_END]	 			-- Дата окончания использования
				,P#PRODUCT		    == rCred								-- Ссылка на использующий схему продукт
				,P_COD				== null			 						-- Код
				,P_GROUP_CODE		== 'Кредиты'							-- Группа
				,P_VALUTA			== FT_CREDIT				 			-- Валюта схемы
				,P_PROC_RECORDS		== rTmpSch.[PROC_RECORDS]	 			-- Способ обработки выписки
				,P_PROC_PRC_DATE	== rTmpSch.[PROC_PRC_DATE]	 			-- Способ выбора процентной ставки за дату
				,P_IGNORE_NEGATIVE	== rTmpSch.[IGNORE_NEGATIVE]			-- Игнорировать отрицательные остатки в выписке
				,P_ROUND_DEGREE		== rTmpSch.[ROUND_DEGREE]				-- Степень округления
				,P_BASE_SCHEMA     	== rTmpSch.[BASE_SCHEMA]				-- Базовая схема
				,P_OPERATION       	== rTmpSch.[OPERATION]					-- Операция над базовой схемой
				,P_CLASSIFIC		== rTmpSch.[CLASSIFIC]					-- Классификация схемы
				);
		end if;
	
		-- Если задана операция, то схему не подтягиваем, но заполняем p_sINFO
		sADD_PRC := 'Ставка: '||to_char(( ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rTmpSch, Oper_Day)), '99990D000000')||' %';
	
		tmpArr	:= rTmpSch.[LIST_SCH_PRC];
		tmpRate := nvl(::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rTmpSch, DATE_BEGIN, 0, 0, false, false), 0);
		&debug('.get_def_prc_schemes: Устанавливаем схему в массив', 0)
		-- указываем признак "копировать в транш" если не копирование из линии для транша
		::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(V_COMISS_ARR, rTmpSch, Debts.[DEBT], (not P_FROM_HL and Debts.FROM_HL_CRED));
		
		if rTmpSch is not null then
			for (	select d(d : id)
					in V_COMISS_ARR all
					where d.[DEBT] = Debts.[DEBT]
				)
			loop
				if nvl(Debts.[PRIORITY], 0) > 0 then
					&debug('.get_def_prc_schemes: устанавливаем приоритет', 0)
					update x(x.[PRIORITY] = Debts.[PRIORITY])
					in V_COMISS_ARR
					where x = d.id;
				end if;

				if Debts.TYPE_DEBT in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC) then
					&debug('.get_def_prc_schemes: устанавливаем существенность', 0)
					bImportance := Debts.IMPORTANCE;
					-- если существенность не задана - рассчитаем
					if bImportance is null then
						oDebtComis.[PRC_SCHEME] := rTmpSch;
						oDebtComis.[DEBT] := Debts.DEBT;
						bImportance := setImportanceDebt(oDebtComis, oCred);
					end if;
					
					update x(x.[IMPORTANCE] = bImportance)
					in	V_COMISS_ARR
					where x = d.id;
				end if;

				exit;
			end loop;
		end if;

		if Debts.[DEBT] = &LCONST.VD_CALC_PRC then
			V_PRC_ADD := sADD_PRC;

			if rTmpSch is not null then
				V_CREDIT_ARR	:= tmpArr;
				V_PRC_RATE		:= tmpRate;
			else
				V_CREDIT_ARR := next_value('SEQ_ID');
			end if;
		end if;
	end loop;

	if FindNothing and not P_NEW_ONLY then -- если ничего не нашли и при этом не добавляли
		for	(	select rDebt(rDebt.[DEBT]: DEBT)
				in V_COMISS_ARR all
				where not rDebt.[PRC_SCHEME] is null
			)
		loop
			&debug('.get_def_prc_schemes: чистим схему в массиве '||rDebt.DEBT.[CODE],0)
			::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(V_COMISS_ARR, null, rDebt.DEBT);
		end loop;
	end if;
	
	if nvl(FILL_TABLE, true) then
		FillPrcTable (V_COMISS_ARR, V_PRC_SCH_TBL, V_PRC_ADD, false);
	end if;
end;

public procedure change_scheme_name
		( cred ref [PR_CRED]
		)
is
	scheme	ref [PRC_SCHEME];
	str			varchar2(2000);
begin
	for	(	select rSchemes	( rSchemes.[PRC_SCHEME]: prc_scheme
							, x.[NAME]: name
							)
			in	cred.[COMISS_ARR]
				, (::[VID_DEBT] all: x)
				all
			where	rSchemes.[PRC_SCHEME] is not null
					and rSchemes.[DEBT] = x
		)
	loop
		scheme := rSchemes.prc_scheme;
		if scheme.[P_PRIVATE] then
			str := rSchemes.name || ' по договору No ' || cred.[NUM_DOG];
			scheme.[NAME] := str;
		end if;
	end loop;
end;

procedure check_cred_insp(V_CRED_INSP in out [STRING_100], cred ref [PR_CRED]) is
begin
	V_CRED_INSP := ::[LOAN_INSPECTOR].[LIB_01].actual_insp_name(cred);
	if V_CRED_INSP in ('Отсутствует!','Ошибка!') then
		pragma error('Для выбранного клиента не определён кредитный инспектор!');
	end if;
end;

-- поиск договора овердрафта по заданному продукту
public procedure locate_over_by_product	( rProd ref [PRODUCT]
										)
is
begin
	for	
	(  select x(x)
		in ::[PR_CRED] all
		where x.[OVER_ON_PROD] = rProd
		  and x.[COM_STATUS] != &LCONST.STATUS_CLOSE
		  and nvl(x.[KIND_CREDIT].[TECH_OVER],false)=false
	)
	loop
		pragma error('Для продукта №'||rProd.[NUM_DOG]||' существует не закрытый договор договор овердрафта или кредитной карты!');
	end loop;
	-- если продукт физ.депозит, проверим участие в мультивалютном депозите, подавляющая часть одиночек проверится выше
	if rProd%class = 'DEPOSIT_PRIV' then
		for( select dmc_part(dmc_part%collection : c_coll) in ::[DEPN_MULTYCURR] collections
				where dmc_part.[DEPOSIT] = rProd
		)loop
			-- депозит входит в мультивалютный, посмотрим есть ли овердрафты для входящих в мультивалютный
			for( select depn(	  depn.[NUM_DOG] 				: c_mutli_dog
								, cred.[NUM_DOG]				: c_cred_dog
							) in ::[DEPOSIT_MULT], (::[PR_CRED] all : cred) all
					where depn.[MULTYCURR] = dmc_part.c_coll	-- массив исходного депозита
					  and depn.[MULTYCURR].[DEPOSIT] != rProd  	-- не смотреть самого себя
					  and cred.[OVER_ON_PROD] = depn.[MULTYCURR].[DEPOSIT]
					  and cred.[COM_STATUS] != &LCONST.STATUS_CLOSE
					  and nvl(cred.[KIND_CREDIT].[TECH_OVER],false)=false
			)loop
				-- нашли незакрытый кредит по депозиту входящему в мультвалютный
				pragma error('Для мультивалютного депозита № '||depn.c_mutli_dog||' существует незакрытый овердрафт или кредитная карта № '||depn.c_cred_dog||' !');
			end loop;
		end loop;
	end if;
end;

-- поиск продукта РКО, РЦ, Депозиты физических лиц, Сберкарт по счету
public function locate_product	( p_acc ref [AC_FIN]
								) return ref [PRODUCT]
is
prd	ref [PRODUCT];
begin
	-- вызов хука
	if nvl(::[HOOK].[CRED_PROD_OV](p_acc, prd), false) then
		return prd;
	end if;
	
	for (select rko(rko : id ) in ::[RKO] all where	rko.[ACCOUNT] = p_acc and coalesce(rko.[COM_STATUS], &LCONST.STATUS_WORK) != &LCONST.STATUS_CLOSE)
	loop
		return rko.id;
	end loop;
	
	for (select mbr(mbr : id) in ::[TRC]	all where mbr.[ACCOUNT] = p_acc	and coalesce(mbr.[COM_STATUS], &LCONST.STATUS_WORK) != &LCONST.STATUS_CLOSE)
	loop
		return mbr.id;
	end loop;
	
	for (select dep_dog(dep_dog : id) in ::[DEPN] all where dep_dog.[ACCOUNT] = p_acc and coalesce(dep_dog.[COM_STATUS], &LCONST.STATUS_WORK) != &LCONST.STATUS_CLOSE)
	loop
		return dep_dog.id;
	end loop;
	
	pragma error('Не найден договор по счету '||p_acc.[MAIN_V_ID]);
end;

public function get_port( p_cred	ref [PR_CRED]
						) return ref [SIM_LOAN_PORT]
is
port	ref [SIM_LOAN_PORT];
begin
	begin
		if V_ADD_CLASS = 'FACTORING' then
			for (select f ( f.[LOAN_PORT_DEF] : loan_port ) in ::[FACTORING] all
				where f.[REDEEM_UNITS] = ::[CRED_INTERFACE].[PRX_FACTORING].Get_v_redeem_unit_arr)
			loop
				port := f.loan_port;
				exit;
			end loop;
		else
			port := p_cred.[GET_NUM_TUNING] ( ::[PRODUCT].[TUNE_CODES].CODE_SIM_LOAN_PORT );
		end if;
	exception when others then stdio.put_line_buf ( 'Ошибка в считывании настройки "Портфель однородных ссуд"');
	end;
	return port;
end;


/*------------------------------------------------------------------------------
---------	Akil:	Наличие разрешения о предоставлении в БКИ на дату	--------
------------------------------------------------------------------------------*/
-- разрешение на предоставление в БКИ на дату
public function into_bki( rCred ref [PR_CRED]
						, on_date [date]
						) return boolean
is
	result	boolean;
begin
	result := null;
	for (
		select ask(ask.[TO_KB] : to_kb) in rCred.[TO_BKI]
		where ask.[DATE_BEG] <= on_date and
		 nvl(ask.[DATE_END], on_date) >= on_date
		order by ask.[DATE_BEG] asc
	) loop
		result := ask.to_kb;
		exit;
	end loop;
	
	return result;
end;
/*------------------------------------------------------------------------------
---------	Akil:	Наличие разрешения о предоставлении в БКИ на дату	--------
------------------------------------------------------------------------------*/
-- Обновить/Добавить в историю разрешений по БКИ
public procedure update_bki(rCred 		ref [PR_CRED]
					, value 	boolean
					, on_date 	date) is
		rHist 	ref [KB_FORM_EVENT];
begin
	if user_access_for_event is null then
		user_access_for_event := check_User_Access;
	end if;
	if user_access_for_event then
		rHist := null;
		for (select hist(hist : id) in rCred.[TO_BKI] where hist.[DATE_BEG] = on_date)
		loop
			rHist := hist.id;
			if nvl(rHist.[TO_KB], false) != value then
				rHist.[TO_KB] := value; -- если на данное число  в массиве есть информация отличная от введенной, обновим
			end if;
			exit;
		end loop;
		
		-- иначе добавим введенную информацию в массив
		if rHist is null then
			if into_bki(rCred, on_date) != value or into_bki(rCred, on_date) is null then -- в том случае если она отлична от действующей на эту дату
				::[CRED_INTERFACE].[PRX_BKI].KB_FORM_EVENT_NEW#AUTO(rCred, value, on_date);
			end if;
		end if;
	end if;
end;


-- Заполняет таблицу истории проц. ставок
public procedure FillPrc_Arr(Arr in out Proc_Arr)
is
	i integer;
begin
	Arr.delete;
	i := 1;
	for (select x(x.[CODE]: name)
		in ::[VID_DEBT] all
		where (not x.[SCHEME_PRC] is null) and (x.[TO_PRODUCT] = &LCONST.AP_PR_CRED))
	loop
		Arr(i).[Scheme]	  := x.name;
		Arr(i).[Proc_Arr] := null;
		i := i + 1;
	end loop;	
end;

-- Находит ссылку на массив проц. ставок в таблице по названию реквизита проц. схемы
public function Find_Prc_Arr( Scheme 	varchar2(20)
							, Arr 		Proc_Arr
							) return integer
is
	res integer := 0;
begin
	for i in Arr.first .. Arr.last loop
		if Arr(i).[Scheme] = Scheme then
			res := i;
			exit;
		end if;
	end loop;
	return res;
end;

-- Копирует комиссии и ссудные задолженности из массива COMISS_ARR в другой такой же массив
public procedure Fill_COMISS_ARR
		( Dest_Arr 	 in out [PR_CRED].[COMISS_ARR]%type
		, Source_Arr 		[PR_CRED].[COMISS_ARR]%type
		, rDepart 	 	ref [DEPART]
		, p_with_prioritet	boolean default null
		, bUpdateOnlyPrior	boolean default false
		, p_NewOnly			boolean default null
		)
is 				
	oComis 		[DEBT_COMISS_PRC];
	rComis 	ref [DEBT_COMISS_PRC];
	oPrior		[PRIORITY_BY_TIP];
	sCopied		varchar2(2000); 		-- скопированные из текущего комиссара тарифы
	bImportance boolean;
	rCred	ref [PR_CRED];
	oCred		[PR_CRED];
begin
	p_with_prioritet := coalesce(p_with_prioritet, true);
	p_NewOnly := coalesce(p_NewOnly, false);
	sCopied := ';';
	rCred :=  Dest_Arr%parent;
	oCred := rCred;
	
	-- ведем список задолженностей с уже установленными комиссиями
	-- по таким задолженностям ничего изменять не будем (в том числе и приоритеты)
	if p_NewOnly then
		for (	select debts(debts.[DEBT] : DEBT)
				in	Dest_Arr all
				where debts.[COMIS] is not null
			)
		loop
			sCopied := sCopied || Debts.DEBT||';';
		end loop;
	end if;
	&debug('Fill_COMISS_ARR: копирование массива комиссий p_NewOnly = '||bool_char(p_NewOnly)||' p_with_prioritet = '||bool_char(p_with_prioritet)||' sCopied = '||sCopied, 0)
	
	for	(	select x( x.[DEBT] : DEBT
					, x.[COMIS] : COMIS
					, x.[COPY_SCHEME] : COPY_SCHEME
					, x.[PRC_SCHEME] : PRC_SCHEME
					, x.[JOURNAL_PRC] : JOURNAL_PRC
					, x.[PRIORITY] : PRIORITY
					, x.[PRIOR_BY_TIP] : PRIOR_BY_TIP
					, x.[IMPORTANCE] : IMPORTANCE
					, case when x.[DEBT].[TYPE_DEBT] in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC) then 1 else 0 end : is_expence)
			in	Source_Arr
				,	(	select ttD(count(1): p_count, ttD.[DEBT] : p_debt)
						in	Source_Arr all
						where ttD.[DEPART] = rDepart
						group by ttD.[DEBT]
					)
				all
			where	x.[DEBT].[TO_PRODUCT] = &LCONST.AP_PR_CRED
					and x.[PRC_SCHEME] is null
					and (not p_NewOnly or instr(sCopied, ';'||x.[DEBT]%id||';') = 0)
					and x.[DEBT] = ttD.p_debt (true)
					and (	(nvl(ttD.p_count, 0) = 1 and x.[DEPART] = rDepart)
						or	(nvl(ttD.p_count, 0) = 0 and x.[DEPART] is null)
						)
		)
	loop
		rComis := null;
		&debug('Fill_COMISS_ARR:	- '||x.DEBT.[CODE] ||
				case when x.PRC_SCHEME is null then ' COMIS = '||x.COMIS.[CODE] else ' PRC_SCHEME = '||x.PRC_SCHEME.[NAME] end ||
				' IMPORTANCE = '||x.IMPORTANCE, 0)
		bImportance := x.IMPORTANCE;
		for (	select c( c : id
						, c.[COMIS] : comis
						, c.[PRC_SCHEME] : pcr_scheme
						)
				in Dest_Arr all
				where c.[DEBT] = x.[DEBT]
			)
		loop
			&debug('Fill_COMISS_ARR: комиссия уже существует - обновляем', 0)
			rComis := c.id;

			if bImportance is null and x.is_expence = 1 then
				oComis := rComis;
				bImportance := setImportanceDebt(oComis, oCred);
				&debug('Fill_COMISS_ARR: рассчитана существенность = '||bool_char(bImportance),0)
			end if;
			
			if bUpdateOnlyPrior then
				update y(y.[PRIORITY] = x.PRIORITY)
				in	Dest_Arr
				where	y = rComis;
			else
				update y( y.[PRIORITY] = x.PRIORITY
						, y.[COPY_SCHEME] = x.COPY_SCHEME
						, y.[COMIS] = x.COMIS
						, y.[IMPORTANCE] = bImportance
						)
				in	Dest_Arr
				where	y = rComis;
			end if;
		end loop;

		if rComis is null then
			&debug('Fill_COMISS_ARR: комиссии в массиве нет - добавляем',0)
			oComis%init(true, true);
			oComis.[DEBT]		:= x.DEBT;
			oComis.[COPY_SCHEME] := x.COPY_SCHEME;
			oComis.[COMIS]		:= x.COMIS;

			if bImportance is null and x.is_expence = 1 then
				bImportance := setImportanceDebt(oComis, oCred);
				&debug('Fill_COMISS_ARR: рассчитана существенность = '||bool_char(bImportance),0)
			end if;
			oComis.[IMPORTANCE]	:= bImportance;
			
			if p_with_prioritet then
				oComis.[PRIORITY]	:= x.PRIORITY;
			end if;
			   		
			Dest_Arr%insert(oComis);
			
			if p_with_prioritet then
				for	(	select	pr	( pr.[TYPE_ACC] : type_Acc
									, pr.[PRIORITY]	: priority
									)
						in x.[PRIOR_BY_TIP]
					)
				loop
					oPrior := null;
					oPrior%init;
					oPrior.[TYPE_ACC] := pr.[TYPE_ACC];
					oPrior.[PRIORITY] := pr.[PRIORITY];
					oComis.[PRIOR_BY_TIP]%insert(oPrior);
				end loop;
			end if;
		end if;
	end loop;
	
end;

-- BFS00028471 Копируем схему из линии в транш (по настройке "Создавать копии процентных схем для траншей")
public procedure copy_prc_sch_for_tranche
		( rSchemeHLC_to_Copy 	ref [PRC_SCHEME]
		, rDebt_HLC 				[DEBT_COMISS_PRC].[DEBT]%type
		, debt_Priority_HLC 		[DEBT_COMISS_PRC].[PRIORITY]%type
		, DATE_BEGIN 				date
		, V_COMISS_ARR				[PR_CRED].[COMISS_ARR]%type
		, V_CREDIT_ARR		in	out	[PRC_SCHEME].[LIST_SCH_PRC]%type
		, V_PRC_RATE		in	out	number
		, rCred					ref [PR_CRED]
		, p_bImportance				boolean default null
		)
is
	tmpArr				::[PRC_SCHEME].[LIST_SCH_PRC]%type;
	tmpRate				number;

	rTmpSch			ref [PRC_SCHEME];

	aLIST_SCH_PRC		[ARR_ARC_SCH_PRC];
	aArrDependPrc		[ARR_DEPEND_PRC];
	r_DependPrc		ref	[DEPEND_PRC];
	rARC_SCH_PRC	ref	[ARC_SCH_PRC];
	v_use_round			[CASE_BETWEEN_TWO];
	bImportance			boolean;
	oDebtComis			[DEBT_COMISS_PRC];
begin
	if rDebt_HLC = &LCONST.VD_CALC_PRC then
		V_CREDIT_ARR	:= null;
		V_PRC_RATE		:= null;
	end if;
	
	rTmpSch := rSchemeHLC_to_Copy;
	aLIST_SCH_PRC := next_value('SEQ_ID');
	
	for	(	select x_sch( x_sch.[DATE_BEG]		: DATE_BEG
						, x_sch.[DATE_END]		: DATE_END
						, x_sch.[EI_TVALID]		: EI_TVALID
						, x_sch.[BANK_YEAR]		: BANK_YEAR
						, x_sch.[FOST]			: FOST
						, x_sch.[FPERIOD]		: FPERIOD
						, x_sch.[DAYS_IN_PERIOD]: DAYS_IN_PERIOD
						, x_sch.[CALC_EVERY_DAY]: CALC_EVERY_DAY
						, x_sch.[NOT2ADD0]		: NOT2ADD0
						, x_sch.[F_PRC_RATE]	: F_PRC_RATE
						, x_sch.[LIST_DEPEND_PRC]: LIST_DEPEND_PRC
						, x_sch.[L_SIMPLE_PRC]	: L_SIMPLE_PRC
						, x_sch.[VAL_SIMPLE_PRC]: VAL_SIMPLE_PRC
						, x_sch.[PRC_MAX]		: C_PRC_MAX
						, x_sch.[PRC_MIN]		: C_PRC_MIN
						)
	 		in rTmpSch.[LIST_SCH_PRC]
		)
	loop
		aArrDependPrc := next_value('SEQ_ID');
		for	(	select rDependPrc( rDependPrc.[FIX_SUMMA]	: FIX_SUMMA
								 , rDependPrc.[PERIOD]		: PERIOD
								 , rDependPrc.[PRC]			: PRC
								 , rDependPrc.[SUB_SUMMA]	: SUB_SUMMA
								 , rDependPrc.[SUMMA]		: SUMMA
								 )
		 		in x_sch.[LIST_DEPEND_PRC]
			)
		loop
			r_DependPrc := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewRecDepnPrc
								(	 P#PRC			== rDependPrc.[PRC]
									,P#PERIOD		== rDependPrc.[PERIOD]
									,P#SUMMA		== rDependPrc.[SUMMA]
									,P#FIX_SUMMA	== rDependPrc.[FIX_SUMMA]
									,P#SUB_SUMMA	== rDependPrc.[SUB_SUMMA]
									,P_ARC_SCH_PRC	== null
								);
			
			aArrDependPrc%insert(r_DependPrc);
		end loop;

		rARC_SCH_PRC := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewRecArch( P#DATE_BEG		== x_sch.[DATE_BEG]	-- Дата начала действия
												, P#DATE_END		== x_sch.[DATE_END]	-- Дата окончания действия
												, P#EI_TVALID		== x_sch.[EI_TVALID]	-- Единица измерения в процентных схемах
												, P#BANK_YEAR		== x_sch.[BANK_YEAR]	-- Признак банковского года в 360 дней
												, P#FOST			== x_sch.[FOST]	-- Разбиение остатка по суммам в процентной схеме
												, P#L_SIMPLE_PRC	== x_sch.[L_SIMPLE_PRC]	-- Признак упрощенной схемы
												, P#VAL_SIMPLE_PRC	== x_sch.[VAL_SIMPLE_PRC]	-- Процент при упрощенной схеме
												, P#LIST_DEPEND_PRC	== aArrDependPrc	-- Список процентов в зависимости от сроков и сумм
												, P#FPERIOD			== x_sch.[FPERIOD]	-- Разбиение по срокам в процентной схеме
												, P#DAYS_IN_PERIOD	== x_sch.[DAYS_IN_PERIOD]	-- Количество дней в периоде процентной ставки
												, P_CALC_EVERY_DAY	== x_sch.[CALC_EVERY_DAY]	-- Ежедневный расчет процентов
												, P_NOT2ADD0		== x_sch.[NOT2ADD0]
												, P_F_PRC_RATE		== x_sch.[F_PRC_RATE]
												, P_PRC_MAX			== x_sch.C_PRC_MAX
												, P_PRC_MIN			== x_sch.C_PRC_MIN
												, P_DEPART			== rCred.[DEPART]
												, P_MetaClass		== rCred%class
												, P_PRC_SCHEME_ARC	== aLIST_SCH_PRC
												);

	end loop;
	
	v_use_round.[0] := 2;
	
	rTmpSch := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].NewSchemPrc
			(
				P#NAME				== substr(rDebt_HLC.[NAME] || ' по договору No ' || rCred.[NUM_DOG],1,100)	 -- Наименование
				,P#P_PRIVATE		== true								 	-- Признак индивидуального использования
				,P#P_CREDIT	        == rTmpSch.[P_CREDIT]				 	-- Признак схемы по активному счету
				,P#LIST_SCH_PRC	    == aLIST_SCH_PRC						-- История схемы начисления процентов
				,P#USER_CREATE		== stdlib.userid						-- Создано пользователем
				,P#DATE_CREATE		== Oper_Day		-- Дата создания
				,P#DATE_USE_BEG		== rTmpSch.[DATE_USE_BEG]				-- Дата начала использования
				,P#DATE_USE_END		== rTmpSch.[DATE_USE_END]	 			-- Дата окончания использования
				,P#PRODUCT		    == rCred								-- Ссылка на использующий схему продукт
				,P_COD				== null			 						-- Код
				,P_GROUP_CODE		== 'Кредиты'							-- Группа
				,P_VALUTA			== rTmpSch.[VALUTA]			 			-- Валюта схемы
				,P_PROC_RECORDS		== rTmpSch.[PROC_RECORDS]	 			-- Способ обработки выписки
				,P_PROC_PRC_DATE	== rTmpSch.[PROC_PRC_DATE]	 			-- Способ выбора процентной ставки за дату
				,P_IGNORE_NEGATIVE	== rTmpSch.[IGNORE_NEGATIVE]			-- Игнорировать отрицательные остатки в выписке
				,P_ROUND_DEGREE		== rTmpSch.[ROUND_DEGREE]				-- Степень округления
				,P_BASE_SCHEMA     	== rTmpSch.[BASE_SCHEMA]				-- Базовая схема
				,P_OPERATION       	== rTmpSch.[OPERATION]					-- Операция над базовой схемой
				);

	::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(V_COMISS_ARR, rTmpSch, rDebt_HLC);
	if not rTmpSch is not null then
		for (	select d(d : id)
				in V_COMISS_ARR all
				where d.[DEBT] = rDebt_HLC
			)
		loop
			if nvl(debt_Priority_HLC, 0) > 0 then
				update x(x.[PRIORITY] = debt_Priority_HLC)
				in V_COMISS_ARR
				where	x = d.id;
			end if;
		
			if rDebt_HLC.[TYPE_DEBT] in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC) then
				&debug('.copy_prc_sch_for_tranche: устанавливаем существенность', 0)
				bImportance := p_bImportance;
				-- если существенность не задана - рассчитаем
				if bImportance is null then
					oDebtComis.[PRC_SCHEME] := rTmpSch;
					oDebtComis.[DEBT] := rDebt_HLC;
					bImportance := setImportanceDebt(oDebtComis, rCred);
				end if;
				
				update x(x.[IMPORTANCE] = bImportance)
				in	V_COMISS_ARR
				where x = d.id;
			end if;

			exit;
		end loop;
	end if;

	if rDebt_HLC = &LCONST.VD_CALC_PRC then
		if rTmpSch is not null then
			tmpArr		:= rTmpSch.[LIST_SCH_PRC];
			tmpRate 	:= nvl(::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rTmpSch, DATE_BEGIN, 0, 0, false, false), 0);
			V_CREDIT_ARR:= tmpArr;
			V_PRC_RATE	:= tmpRate;
		else
			V_CREDIT_ARR := next_value('SEQ_ID');
		end if;
	end if;	
	
end;

--------------------------------------------------------------------
function IsSharedScheme
		( p_scheme		ref [PRC_SCHEME]
		, p_current_array	collection
		) return boolean
is
begin
	for	(	select comisar('1')
			in	::[DEBT_COMISS_PRC] collections
			where	comisar%collection != p_current_array
					and comisar.[PRC_SCHEME] = p_scheme
		)
	loop
		return true;
	end loop;
	return false;
end;

--v-- BS00133979. Первоначальный расчет дат начала периода и ставок по добавленным правилам
/*	Определение даты расчета:
	- если дата начала периода больше или равна даты открытия, то считаем на дату открытия;
	- если дата начала периода меньше даты открытия считаем на максимальную из дат меньших даты открытия договора, попадающих в периодичность */
public procedure FLR_FirstCalcRules	( p_Cred 		ref [PR_CRED]
									, p_DateOpen 	date)
is
	type RecBegRunDates is record
		( relation ref [FL_RATE_RELATION]
		, CalcDate date
		);	
	type TblBegRunDates is table of RecBegRunDates;	
	
	tDates TblBegRunDates;
	vRelationII integer;
	vDateCalc date;
	vDateChange date;
	vIdx integer;
begin
	-- Посчитаем даты начала периода
	For (
		select r(r :id)
		in ::[FL_RATE_RELATION] all
		where r.[PRODUCT] = p_Cred
		and r.[IS_CALC_BEGRUN] = true )
	loop
		r.id.[CALC_BEGIN_RUN];
	end loop;

	-- Выберем привязанные правила, которые могут быть посчитаны на дату открытия договора (только с признаком авторасчета)
	for (
		select r( distinct r.[DEBT] :debt)
		in ::[FL_RATE_RELATION], (::[FL_RATE_RULE] :rule) all
		where r.[PRODUCT] = p_Cred
		and r%collection = rule.[PROD_RELATION]
		and nvl(rule.[TYPE_RATE].[AUTO_CALC], false) = true)
	loop
		-- Для каждого правила по задолженности проверяем попадает ли дата на которую должен быть произведен расчет в период действия правила
		tDates.delete;
		vRelationII := 0;
		
		for (
			select rr	( rr				:id
						, rr.[BEGIN_RUN]	:BegRun
						, rr.[DATE_BEGIN]	:dBeg
						, rr.[DATE_END]		:dEnd
						, rule.[PERIODS]	:Periods
						)
			in ::[FL_RATE_RELATION], (::[FL_RATE_RULE] :rule) all
			where rr.[PRODUCT] = p_Cred
			and rr.[DEBT] = r.debt
			and rr%collection = rule.[PROD_RELATION]
			and nvl(rule.[TYPE_RATE].[AUTO_CALC], false) = true )
		loop
			if rr.dBeg <= p_DateOpen and (rr.dEnd is null or rr.dEnd >= least(rr.BegRun, p_DateOpen)) then
				vRelationII := vRelationII + 1;
				if rr.BegRun < p_DateOpen then
					-- будем искать ближайшую дату в прошлом попадающую в периодичность
					vDateCalc	:= rr.BegRun;
					vDateChange	:= rr.BegRun;
					for i in 1..1000 loop
						vDateChange := ::[PERIODS_OPER].[PER_LIB].get_next_date
									( rr.Periods		-- периодичность
									, rr.BegRun			-- дата с которой сравнивается результат
									, false				-- выдавать сообщение об ошибке
									, vDateChange		-- дата последнего выполнения
						);
						exit when vDateChange > p_DateOpen;
						vDateCalc := vDateChange;			
					end loop;		
				else
					-- будем считать на дату начала договора
					vDateCalc := p_DateOpen;
				end if;
				
				if vDateCalc >= rr.dBeg and (vDateCalc <= rr.dEnd or rr.dEnd is null) then
					vIdx := tDates.count + 1;
					tDates(vIdx).CalcDate := vDateCalc;
					tDates(vIdx).relation := rr.id;
				end if;
			end if;
		end loop;
	
		if tDates.count = 0 then
			if vRelationII = 0 then
				stdio.put_line_buf ('Для задолженности '||r.[DEBT].[NAME]||' не найдено правило для первого расчета процентной ставки');
			else		
				stdio.put_line_buf ('Для задолженности '||r.[DEBT].[NAME]||' дата начала действия правила не соответствует периодичности пересчета (ставка не будет посчитана)');			
			end if;
		elsif tDates.count = 1 then
			tDates(1).relation.[CALC_RULE](tDates(1).CalcDate, false, true);
		else
			stdio.put_line_buf ('Для задолженности '||r.[DEBT].[NAME]||' найдено несколько правил подходящих для первого расчета процентной ставки');
		end if;
	end loop;
end;

-- Определение типа ставки
public function get_RateType( p_cred 	ref [PR_CRED]
							, p_debt 	ref [VID_DEBT]
							, p_prc_shm ref [PRC_SCHEME]
							, p_date 	date
							) return varchar2
is
	vTypeRef varchar2(12);
begin
	-- проверим не является ли схема ссылкой (уже используется в КВУ или на Виде кредита)
	if [FL_RATE_RULE].[LIB].Check_UseRefPrcSch(p_cred, p_debt, p_prc_shm, vTypeRef) then
		return 'Ссылка на '||vTypeRef;
	else
		-- Если найдем правило на дату, то возьмем тип ставки оттуда					
		for (select Rule(Rule.[TYPE_RATE].[NAME] : name)
				in ::[FL_RATE_RULE], (::[FL_RATE_RELATION] all :Rel) all
			where Rel%collection = Rule.[PROD_RELATION]
			and Rel.[DEBT] = p_debt
			and Rel.[PRODUCT] = p_cred
			and p_date >= Rel.[DATE_BEGIN]
			and (p_date <= Rel.[DATE_END] or Rel.[DATE_END] is null)
			and rownum = 1)
		loop		
			return Rule.name;
		end loop;
	end if;

	-- Если не ссылка и правило не найдено, значит ставка фиксированная
	return 'Фиксированная';
end;
--^-- BS00133979

public procedure delete_calc_version( p_this 		ref [PR_CRED]
									)
is
begin
	for hist in p_this.[DEBT_PRIORITY] loop
		hist.[DELETE#AUTO];
	end loop;
end;

public procedure get_calc_vertion	( p_this 		ref [PR_CRED]
									, P_KIND_CREDIT ref [KIND_CREDITS]
									, P_DATE_BEGIN 	date
									, P_DATE_END 	date
									)
is
	ohist [SQ_VERSION_HIST];
begin
	delete_calc_version(p_this);
	for hist in P_KIND_CREDIT.[DEBT_PRIORITY] where
		(P_DATE_BEGIN is null or hist.[DATE_BEGIN] is null or hist.[DATE_BEGIN] <= P_DATE_BEGIN) and
		(P_DATE_BEGIN is null or hist.[DATE_END] is null or hist.[DATE_END] >= P_DATE_BEGIN) and
		(P_DATE_END is null or hist.[DATE_END] is null or hist.[DATE_END] >= P_DATE_END)
	loop
		ohist := hist;
		p_this.[DEBT_PRIORITY]%insert(ohist);
	end loop;
end;

public procedure SetRestr	( p_cred 	ref [PR_CRED]
							, p_kind 	ref [CHANGE_KIND]
							, p_min_pay [SUMMA]
							, p_curent 	in out [CHANGE_RULE]
							)
is
	rChangeRule  ref [CHANGE_RULE];
begin
	if p_cred is null then
		return;
	end if;
	
	p_min_pay := nvl(p_min_pay, 0);	
	if p_kind is null then -- если не указан вариант реструктуризации проверим что записи нет	
		delete rec in ::[CHANGE_RULE] all where rec%id = p_curent%id;
	else -- есть данные для сохранения
		p_curent%init(true,true);
		rChangeRule := p_curent%id;
 		update rec(	  rec.[DATE_REG] = p_curent.[DATE_REG]
 					, rec.[DATE_FROM] = p_curent.[DATE_FROM]
 					, rec.[DATE_TO] = p_curent.[DATE_TO]
			 		, rec.[DATE_DELAY] = p_curent.[DATE_DELAY]
 					, rec.[KIND] = p_kind
 					, rec.[MIN_PAY] = p_min_pay
 					, rec.[CRED] = p_cred
 					, rec.[STATUS] = ::[COM_STATUS_PRD]([CODE]='WAIT_CONF')
 		) in ::[CHANGE_RULE] all
 		where rec%id = p_curent%id; 		
 		p_curent := rChangeRule; 	
	end if;
end;

public function check_User_Access return boolean
is
begin
	return nvl(security.Cls_Accessible('KB_FORM_EVENT', stdlib.userid.[USERNAME]), '0') = '1';
end;

--v-- BS00133979 Процедуры включения/отключения работы с правилами на ЭФО ---
procedure fl_rule_on is
begin
	[CSMD].Show(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULE_TYPE','V');
	[CSMD].Show(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULES','V');
	vUseFLRule := true;
end;

procedure fl_rule_off is
begin
	[CSMD].Hide(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULE_TYPE','V');
	[CSMD].Hide(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULES','V');
	vUseFLRule := false;
end;
--^-- BS00133979  -------------------------------------------------------------

b_Kind_Cred_Changed boolean;
procedure on_change_kind_credit (
			p_cred						ref	[PR_CRED],
			P_KIND_CREDIT					ref [KIND_CREDITS],
			P_CALENDAR_NAME						[NAME],
			DATE_BEGIN				in out		[DATE],
			DATE_ENDING				in out		[DATE],
			DECL_ON_CRED_REF		in out	ref	[DECL_ON_GET_CRED],
			DIC_TYPE_CRED			in out	ref	[TYPES_CRED],
			FT_CREDIT				in out	ref	[FT_MONEY],
			NUM_DOG					in out		[PRODUCT_NUM],
			PERIOD					in out		[DIG_6],
			P_CALC_TYPE				in out	ref	[OVER_BALANCE],
			P_DEPART				in out	ref	[DEPART],
			P_FOR_OPEN_YEAR			in out		[BOOLEAN],
			P_HIGH_LEVEL_CR			in out	ref	[PR_CRED],
			P_OPER_WAY_OUT			in out	ref	[WAY_KRED],
			P_OVD_ACCOUNT			in out	ref	[AC_FIN],
			P_PERIOD_UNIT			in out	ref	[UNITS_OF_TIME],
			P_PRODUCT				in out	ref	[PRODUCT],
			V_COMISS_TBL			in out		t_tbl_DEBT_COMISS_PRC,
			V_CREDIT_ARR			in out		[ARR_ARC_SCH_PRC],
			V_CR_CLASS				in out		[STRING_100],
			V_DATE_ENDING_MAX		in out		[DATE],
			V_DATE_GIVE				in out		[DATE],
			V_DEST_STR				in out		[STRING_32000],
			V_EARLY_PAY				in out	ref	[EARLY_PAY],
			V_GEN_AGR				in out	ref	[GEN_AGREEM_FRAME],
			V_INVOICE				in out		[BOOLEAN],
			V_IS_FOR_CRED_CARD		in out		[BOOLEAN],
			V_OPEN_DEP				in out		[BOOLEAN],
			V_PRC_ADD				in out		[STRING_100],
			V_PRC_RATE				in out		[NUM_16_8],
			V_PRC_SCH_TBL			in out		t_tbl_VIEW_PRC_SCH,
			V_PRJ_KIND_CRED			in out	ref	[KIND_PROJECT],
			V_SCHM_CHANGE			in out		[SHORT1],
			V_WAY_OUT_CODE			in out		[STRING_2],
			P_PERIOD_WD				in out		[BOOLEAN],
			P_SUMMA					in out		[NUMBER],
			p_ChangeTarif			boolean default true		--признак необходимости смены тарифов на договоре
		
			) is
	obj_cred [PR_CRED];
	dep [PRC_DEP_TURN];
	v_kind_early ref [EARLY_PAY];
	sErr [MEMO];
	sCalendar		varchar2(100);
begin
	if P_KIND_CREDIT is not null then
		kind_cred := P_KIND_CREDIT;
		obj_cred := p_cred;
		if kind_cred.[REG_RULES] is null then
			pragma error('У вида кредита не заполнено правило учета.');
		end if;

		if kind_cred.[DEF_PERIOD_MS] is not null
		and kind_cred.[DEF_PERIOD_NUM] is not null
		-- переопределяем только если в КВУ не определен срок для транша --
		and glHL_PERIOD_NUM is null
		then
			PERIOD := kind_cred.[DEF_PERIOD_NUM];
			P_PERIOD_UNIT := kind_cred.[DEF_PERIOD_MS];
			P_PERIOD_WD := false;
		end if;

		--v-- BS00133979 Удалим заданные правила, если их нельзя использовать для нового вида кредита			
		if [FL_RATE_RULE].[LIB].FindPrcRule(p_cred) then
			for (
				select r(distinct r.[DEBT] :debt)
				in ::[FL_RATE_RELATION] all
				where r.[PRODUCT] = p_cred)
			loop
				if not [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR, r.[DEBT]) then
					delete rlt in ::[FL_RATE_RELATION] where rlt.[PRODUCT] = p_cred and rlt.[DEBT] = r.[DEBT];
					[CSMD].MessageBox(V_DEST_STR, 'Удаление правил расчета ставки при смене вида кредита', 'Правила для задолженности '||substr(r.[DEBT].[CODE],1,60)||' будут удалены');
				end if;
			end loop;				
		end if;
		--^-- BS00133979
		
		-- 1. предварительная очистка COMISS_ARR
		if p_kind_credit is not null and p_ChangeTarif then
			
			::[PR_CRED].[NEW_DOG_LIB].PrcScheme_Clear(obj_cred%id, obj_cred.[COMISS_ARR]);

			V_CREDIT_ARR:= null;		-- BFS00029749
			V_PRC_RATE 	:= null;		-- BFS00029749
			V_PRC_ADD 	:= null;		-- BFS00029749
		end if;

 		obj_cred.[KIND_CREDIT] := P_KIND_CREDIT;

 		if V_GEN_AGR is null then
		-- BFS00035280
			FT_CREDIT := kind_cred.[CURRENCY];
			if FT_CREDIT is null and not(P_HIGH_LEVEL_CR is null) then
				FT_CREDIT := P_HIGH_LEVEL_CR.[FT_CREDIT];
			end if;
			if FT_CREDIT is null then
				FT_CREDIT := ::[SYSTEM].[VARIABLES].NatCur;
			end if;
		end if;
		
		if not(P_KIND_CREDIT) is null then P_OPER_WAY_OUT := kind_cred.[WAY_CRED]; end if;

		V_WAY_OUT_CODE := validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		
		--транш всегда CRED_CONT
		if P_HIGH_LEVEL_CR is null then
			DIC_TYPE_CRED := kind_cred.[REG_RULES];
		else
			DIC_TYPE_CRED := &LCONST.TC_CRED_CONT;
		end if;
		
		P_CALC_TYPE	:= kind_cred.[CALC_TYPE];
		V_IS_FOR_CRED_CARD := kind_cred.[IS_FOR_CRED_CARD];
		V_INVOICE = obj_cred.[INVOICE]:= kind_cred.[INVOICE];
		obj_cred.[FT_CREDIT] := FT_CREDIT;
		V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(P_SUMMA, FT_CREDIT.[CUR_SHORT]);

		-- Дополнительные свойства --
		V_PROPERTIES%delete;
		if not nvl(::[HOOK].[CRED_COPY_PROPS](p_cred, DECL_ON_CRED_REF), false) then
			::[PROD_PROPERTY].[L].make_default_properties( V_PROPERTIES, V_CR_CLASS, DATE_BEGIN, kind_cred.[CODE]);
		end if;

		if V_INVOICE then	-- BFS00027595
			V_DATE_ENDING_MAX := null;
			obj_cred.[DATE_ENDING_MAX] := null;
		end if;
		
		sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(p_cred%id, p_cred.[CALENDAR_NAME]);
		validate_invoice(V_INVOICE, V_DEST_STR, V_CR_CLASS);
		if V_INVOICE then
			DATE_ENDING	:= null;
			PERIOD		:= null;
			P_PERIOD_UNIT	:= null;
			P_PERIOD_WD := false;
			P_HIGH_LEVEL_CR	:= null;
			P_FOR_OPEN_YEAR := false;
			V_INVOICE_COND.delete;
		else
			if PERIOD is null then
				P_PERIOD_UNIT := nvl(kind_cred.[PERIOD_UNIT], UT_DAY);
				P_PERIOD_WD	:= nvl(P_PERIOD_WD, false);
			else
				DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( nvl(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar);
				if DATE_ENDING is not null and ::[PR_CRED].[L_2].strong_check_hollydays_bool(DATE_ENDING, sErr,obj_cred%class, sCalendar) then
					stdio.put_line_buf(sErr||NL$);
					DATE_ENDING := null;
					PERIOD		:= null;
				end if;
			end if;
			V_DATE_ENDING_MAX := get_date_ending_max(kind_cred,V_CR_CLASS,V_DATE_GIVE,DATE_BEGIN, sCalendar);

			V_INVOICE_COND.delete;
		end if;
		
		if V_CR_CLASS != 'OVERDRAFTS' and not nvl(V_IS_FOR_CRED_CARD, false) then
			P_OVD_ACCOUNT = P_PRODUCT := null;
			V_OPEN_DEP := false;
		end if;
		validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR);
		
		if nvl(V_EARLY_PAY.[USE_PRIVATE], false) and nvl(::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY'), false) then
			begin
				V_EARLY_PAY.[DELETE#AUTO];
			exception when others then null;
			end;
		end if;
		
		v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);	
		V_EARLY_PAY := ::[PR_CRED].[NEW_DOG_LIB].MakeEarlyPeny( nvl(DECL_ON_CRED_REF.[EARLY_PAY], v_kind_early), 'по договору № '||NUM_DOG );
		bRebuildParam4Plan := true;
		
		if kind_cred.[PRC_DEP_SCHEME]%size(0) > 0 then
			[CSMD].Show(V_DEST_STR, 'V_PRC_DEP_TURN_ACC_LIST', 'V');
			[CSMD].Show(V_DEST_STR, 'V_PRC_DEP_TURN_PRC_DEP_SCHEME', 'V');
			V_PRC_DEP_TURN_PRC_DEP_SCHEME%delete;

			for x in kind_cred.[PRC_DEP_SCHEME] loop
				--v-- BS00133979 Не копируем схему зависимостей для процентной схемы, если для этой задолженности задано правило
				declare
					bFind boolean;
				begin
					bFind := false;
					for (select r(null)
						in ::[FL_RATE_RELATION] all
						where r.[PRODUCT] = p_cred
						and r.[DEBT] = x.[DEBT])
					loop
						bFind := true;
						[CSMD].MessageBox(V_DEST_STR, 'Невозможно скопировать схему зависимости с Вида кредита', 'Для задолженности '||substr(x.[DEBT].[CODE],1,50)||' уже задано правило расчета ставки');
						exit;	
					end loop;

					if not bFind then	
						dep := x;
						dep.[LAST_VALUE] := null;
						insert dep into V_PRC_DEP_TURN_PRC_DEP_SCHEME;
					end if;
				end;
				--^-- BS00133979
			end loop;

		else
			V_PRC_DEP_TURN_PRC_DEP_SCHEME%delete;
			[CSMD].Hide(V_DEST_STR, 'V_PRC_DEP_TURN_ACC_LIST', 'V');
			[CSMD].Hide(V_DEST_STR, 'V_PRC_DEP_TURN_PRC_DEP_SCHEME', 'V');
		end if;

		-- 2. заполнить комиссии с инд. приоритетами из вида кредита
		-- Приоритеты погашения переносить всегда, кроме: (заполнена ссылка на КВУ) AND (договор КВУ не является ?До востребования?).
		--v_copy_priors := not ((not P_HIGH_LEVEL_CR is null) and (not nvl(P_HIGH_LEVEL_CR.[INVOICE], false)));
		if p_kind_credit is not null and p_ChangeTarif then
			v_copy_priors := P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false);
			
			Fill_COMISS_ARR(obj_cred.[COMISS_ARR], kind_cred.[COMISS_ARR], P_DEPART, v_copy_priors);	
			FillComissTable (obj_cred.[COMISS_ARR], V_COMISS_TBL);		

			-- 3. обработать вариант обновления схемы пользователем
			-- решение пользователя о варианте обновления %% схем
			-- 0 - нажал отмену (валидация должна заблокироваться выше и сюда не зайдет)
			-- 1 - Всё отчистить заполнить из вида кредита (стандартный вариант)
			-- 2 - Всё зачистить взять с КВУ, добавить из вида кредита
			-- 3 - Всё зачистить взять с КВУ, потом из вида кредита затирая КВУ
			-- null - не запрашивали пользователя (это не транш)
			if nvl(V_SCHM_CHANGE, 1) = 1 then -- отрабатываем как обычно по виду кредита
				-- BFS00030875 подтягиваем % схемы (даже если это транш, а у соответствующей линии имеется признак копирования условий в транши)
				::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred);
			elsif V_SCHM_CHANGE > 1 then -- взять с КВУ
				if V_SCHM_CHANGE = 2 then --добавить из вида кредита
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, null, true); --контролируем признак "передавать в транш"
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, true); -- только новые схемы
				else -- из вида кредита затирая КВУ
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred);
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, true, true); -- только новые, контролируем признак "передавать в транш"
				end if;
			end if;


			--v-- BS00133979 Работа с плавающими ставками на ЭФО
			if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR) then
				fl_rule_on;
			else
				fl_rule_off;
			end if;	
			
			if vUseFLRule and obj_cred.[KIND_CREDIT] != P_KIND_CREDIT then
				-- Переинициализируем КЭШ с учетом изменения вида кредита
				[FL_RATE_RULE].[LIB].ProdInit(p_cred, P_KIND_CREDIT);
			end if;		
				
			FillPrcTable (obj_cred.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, false, p_cred, P_KIND_CREDIT, vUseFLRule);
		end if;
	end if;
	b_Kind_Cred_Changed := false;
end;

procedure set_balloon_payment (
	rCred			ref [PR_CRED],
	date_begin		date,
	nSummaBalloon	number
) is
begin
	-- проверяем значение суммы последнего платежа
	if nSummaBalloon >= rCred.[SUMMA_DOG] then
		pragma error ('Сумма последнего платежа не может быть большей или равной сумме кредита');
	end if;

	if nSummaBalloon is null then
		-- удаляем старое значение
		::[PROPERTY_PROD].[LIB].DelProperty(rCred, ::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'));
	elsif nvl(::[PROPERTY_PROD].[LIB].GetPropVal(rCred, greatest(Oper_Day, nvl(date_begin, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT')),0) <> nSummaBalloon then
		-- удаляем старое значение
		::[PROPERTY_PROD].[LIB].DelProperty(rCred, ::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'));
		-- сохраняем новое
		::[PROPERTY_PROD].[LIB].AddProperty(rCred,
											date_begin,
											null,
											::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'),
											nSummaBalloon);	
	end if;
end;

public function get_profile	( p_cred ref [PR_CRED]
							, p_date date
							, p_kind_cred ref [KIND_CREDITS]
							) return ref [CR_DISTR_PROFILE]
is
	ret_val ref [CR_DISTR_PROFILE];

	profile_found boolean;
begin
	profile_found := false;
	for (select prof_found(prof_found : id) in ::[CR_DISTR_PR_HIST] all where prof_found.[PRODUCT] = p_cred and prof_found.[DISTR_PROFILE] is not null)
	loop
		profile_found := true;
		for (select profile(profile.[DISTR_PROFILE] : id) in ::[CR_DISTR_PR_HIST] all where
			profile.[PRODUCT] = p_cred and profile.[DISTR_PROFILE] is not null and
			(profile.[DATE_BEGIN] is null or profile.[DATE_BEGIN] <= p_date) and
			(profile.[DATE_END] is null or profile.[DATE_END] >= p_date)
		)loop
			ret_val := profile.id;
			exit;
		end loop;
		exit;
	end loop;

	if not profile_found and p_kind_cred is not null then
		ret_val := p_kind_cred.[DISTR_PROFILE];
	end if;
	
	return ret_val;
end;

public procedure ValidateTranshPeriodNum( pInfo 				varchar2(100)
										, vDEST_STR				in out varchar2(32000)
										, vTRANSH_PERIOD_NUM 	in out [DIG_6]
										, pHL_PERIOD_NUM		[DIG_6]
										, vTRANSH_PERIOD_UNIT 	in out ref [UNITS_OF_TIME]
										, pHL_PERIOD_UNIT 		ref [UNITS_OF_TIME]
										, vCOPY_TO_TRANSH 		boolean
										, vDATE_GIVE 			date
										, pDATE_BEGIN 			date
										, pDATE_ENDING 			date
										, pDIC_TYPE_CRED		ref [TYPES_CRED]
										, vCR_CLASS				varchar2
										, pPERIOD_WD			boolean
										, vCALENDAR				varchar2
										)
is
	dMaxEndDateTransh date; -- максимальная дата окончания транша в зависимости от срока транша, установленного на линии V_TRANSH_PERIOD_NUM
	pragma macro(IsCredLine,
				'vCR_CLASS != ''OVERDRAFTS'' -- не овердрафт
				 and coalesce(pDIC_TYPE_CRED, &LCONST.TC_CRED_CONT) in (&LCONST.TC_CRED_LINE, &LCONST.TC_CRED_OVER)'
				);
begin
	
	if pInfo = '%VAR%.V_TRANSH_PERIOD_NUM' then
		if vTRANSH_PERIOD_NUM is not null then
			[CSMD].Disable(vDEST_STR, 'V_COPY_TO_TRANSH', 'V');
			if vTRANSH_PERIOD_NUM > pHL_PERIOD_NUM then
				pragma error('Ошибка! Срок транша не может превышать срок КВУ.');
			end if;
			if vTRANSH_PERIOD_NUM = 0 then
				pragma error('Ошибка! Укажите значение для срока транша больше 0.');
			end if;
		else
			[CSMD].Enable(vDEST_STR, 'V_COPY_TO_TRANSH', 'V');
		end if;
	end if;
	
	if pInfo = '%VAR%.V_COPY_TO_TRANSH' then
		if vCOPY_TO_TRANSH then
				[CSMD].Disable(vDEST_STR, 'V_TRANSH_PERIOD_NUM', 'V');
		else	[CSMD].Enable (vDEST_STR, 'V_TRANSH_PERIOD_NUM', 'V');
		end if;
	end if;

	if pInfo in ('P_PERIOD_UNIT', 'P_KIND_CREDIT') then
		if &IsCredLine then
			vTRANSH_PERIOD_UNIT := pHL_PERIOD_UNIT;
		else
			vTRANSH_PERIOD_NUM := null;
		end if;
	end if;
	
	if pInfo in ('DATE_BEGIN', '%VAR%.V_DATE_GIVE', 'P_PERIOD_UNIT', 'DATE_ENDING', 'PERIOD') then
		if &IsCredLine then
			if vTRANSH_PERIOD_NUM is not null then
				dMaxEndDateTransh := pDATE_ENDING;
				if vTRANSH_PERIOD_NUM is not null then
					dMaxEndDateTransh := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd
											(coalesce(vDATE_GIVE, pDATE_BEGIN)
											,vTRANSH_PERIOD_NUM
											,vTRANSH_PERIOD_UNIT
											,null, null
											,pPERIOD_WD
											,vCALENDAR);
				end if;
				if vTRANSH_PERIOD_UNIT != pHL_PERIOD_UNIT then
					vTRANSH_PERIOD_UNIT := pHL_PERIOD_UNIT;
					::[PR_CRED].[NEW_DOG_LIB].calc_period_units
					( coalesce(vDATE_GIVE, pDATE_BEGIN)
					, dMaxEndDateTransh
					, vTRANSH_PERIOD_NUM
					, vTRANSH_PERIOD_UNIT
					, pPERIOD_WD
					, vCALENDAR);
				end if;
				if dMaxEndDateTransh > pDATE_ENDING then vTRANSH_PERIOD_NUM := pHL_PERIOD_NUM; end if;
			else
				vTRANSH_PERIOD_UNIT := pHL_PERIOD_UNIT;
			end if;
		end if;
	end if;
end;

/*
 * Расчет существенности комиссии или затраты по критериям
 * Сумма комиссии для комиссионной или простой задолженности определяется расчетом тарифа,
 * для процентной задолженности определяется по плановым операциям погашения данной задолженности
 * (БП = "Гашение", Уменьшаемая задолженность = рассчитываемой задолженности).
 */
public function setImportanceDebt
		( p_oDebtComisPrc [DEBT_COMISS_PRC]
		, p_oCred [PR_CRED]
		) return boolean
is
	nSumTarif		number := 0;
	rTarifValuta	ref [FT_MONEY];
	rVidDebt		ref [VID_DEBT];		
	oVidDebt			[VID_DEBT];

	rFtoolGrp	ref	[IFRS_FTOOL_GRP];
	bEssent			boolean;
	oIfrsCrit		[IFRS_CRIT_VALUES];
	nSumFI			number;
	sAdds			varchar2(32000);
	
begin
	&debug('setImportanceDebt: p_oCred = '||p_oCred%id||' SUMMA_DOG = '||p_oCred.[SUMMA_DOG], 0)

	rVidDebt := p_oDebtComisPrc.[DEBT];
	oVidDebt := rVidDebt;
	if oVidDebt.[TYPE_DEBT] not in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC, &LCONST.TD_COMMISS_OPER) then
		&debug('setImportanceDebt: существенность рассчитывается только для задолженностей с типом учета "Процентная комиссия", "Операционная комиссия" или "Затрата"', 0)
		return null;
	end if;

	&debug('setImportanceDebt: расчет существенности для задолженности '||oVidDebt.[CODE], 0)

	-- Сумму комиссии считаем по плановым операциям гашения, если это не комиссия за открытие лимита/счета
	if rVidDebt <> &VD_KOMM_FOR_PAY then
		select x( coalesce(sum(x.[SUMMA]), 0))
		in	p_oCred.[LIST_PLAN_PAY]
		where	x.[OPER].[VID_DEBT] = rVidDebt
		into nSumTarif;
		&debug('setImportanceDebt: сумма задолженности по плановым операциям гашения '||nSumTarif, 0)
	end if;

	-- Если по плану не посчитали, но есть тариф, то сумму считаем по тарифу
	if  rVidDebt = &VD_KOMM_FOR_PAY or (nSumTarif = 0 and p_oDebtComisPrc.[COMIS] is not null) then
		&debug('setImportanceDebt: Расчет существенности по тарифу '||p_oDebtComisPrc.[COMIS].[CODE],0)
		-- Вычислим сумму комиссии
		::[PR_CRED].[CALC_COMIS].CalcSumComis(
				  rProd == p_oCred%id
				, rTarif == p_oDebtComisPrc.[COMIS]
				, OnDate == p_oCred.[DATE_ENDING]
				, p_nSum == nSumTarif
				, p_rFintool == rTarifValuta
				, val_op == p_oCred.[FT_CREDIT]
				, kindOfDebt == rVidDebt
			);
		&debug('setImportanceDebt:	сумма тарифа = '||nSumTarif||' валюта тарифа = '||rTarifValuta.[NAME], 0)

		if rVidDebt = &VD_KOMM_FOR_PAY and rTarifValuta <> p_oCred.[FT_CREDIT] then
			nSumTarif := ::[DOCUMENT].[LIB_CUR].cur2cur(nSumTarif, rTarifValuta, p_oCred.[FT_CREDIT], nvl(p_oCred.[DATE_BEGINING],p_oCred.[DATE_BEGIN]));
			&debug('setImportanceDebt:	пересчет суммы тарифа в валюту договора на дату начала. Сумма в валюте договора = '||nSumTarif||' ('||p_oCred.[FT_CREDIT].[NAME]||')', 0)
		end if;	
	end if;

	if nSumTarif > 0 then
		&debug('setImportanceDebt: Расчет существенности затраты/комиссии в сумме ('||nSumTarif||'): задолженность = '||oVidDebt.[CODE], 0)
	
		if nvl(::[HOOK].[CALC_SUM_FI](rVidDebt, p_oCred%id, p_oCred%class, nSumFI, p_oCred.[FT_CREDIT], sAdds), false) then
			&debug('setImpByPrcComiss:	хук вернул сумму ФИ = '||nSumFI, 0)
		else
			nSumFI := coalesce(p_oCred.[LIMIT_SALDO], p_oCred.[SUMMA_DOG], 0);
			&debug('setImportanceDebt:	установим сумму ФИ равную сумме договора '||nSumFI, 0)
		end if;
		
		if nSumFI > 0 then
			-- рассчитаем существенность затраты/комиссии
			rFtoolGrp := ::[CRED_INTERFACE].[PRX_IFRS].Get_Ftool_Grp(
					p_Obj_Ref == p_oCred%id
					, p_Obj_Class == p_oCred%class
					, p_Date == p_oCred.[DATE_BEGIN]
					, p_bAim == 2 --для определения справочных значений существенности
					, p_Period == p_oCred.[DATE_ENDING] - p_oCred.[DATE_BEGIN]
					, p_UN_Period == ::[UNITS_OF_TIME]([CODE]='D')
					, p_Summa == p_oCred.[SUMMA_DOG]
					, p_Currency == p_oCred.[FT_CREDIT]
					, p_Add_Par	== null
					, p_dDateBeg == p_oCred.[DATE_BEGIN]
			);
			&debug('setImportanceDebt:	rFtoolGrp = '||rFtoolGrp.[NAME], 0)

			::[CRED_INTERFACE].[PRX_IFRS].Get_Crit_Value(
					p_rFtool_Grp == rFtoolGrp
					, p_date == p_oCred.[DATE_BEGIN]
					, p_rCrit_Kind ==	case
											when oVidDebt.[TYPE_DEBT] = &LCONST.TD_EXPENSE then &LCONST.g_CRIT_EXPENS
											when oVidDebt.[TYPE_DEBT] in (&LCONST.TD_COMMISS_PRC, &LCONST.TD_COMMISS_OPER) then &LCONST.g_CRIT_COMIS
											else null
										end
					, p_rVid_Debt == rVidDebt
					, p_What_Compare == nSumTarif
					, p_With_Compare == nSumFI
					, p_rCurrency == p_oCred.[FT_CREDIT]
					, p_oCrit_Values == oIfrsCrit
					, p_bEssent == bEssent
					, p_bGen_Err == true
					, p_Obj_Ref	== p_oCred%id
					, p_Obj_Class == p_oCred%class
					, p_nBound_Left	== null
					, p_nBound_Right == null
				);
		end if;
	end if;
	&debug('.setImportanceDebt: bEssent='||bool_char(bEssent),0)
	return bEssent;

exception
	when ::[RUNTIME].[MESSAGE].APP_EXCEPTION then
		::[RUNTIME].[STDIO].put_line_buf('При расчете признака существенности произошла ошибка: '||::[RUNTIME].[PRINTFUN].SQLERRM_INF);
		&debug('setImportanceDebt: ошибка при расчете признака существенности = '||utils.error_stack(true) , 0)
		return false;
end;

public procedure recalcImportance
		( p_tCurDebtComis	in	out	nocopy	t_tbl_DEBT_COMISS_PRC
		, p_tCurDebtPrc		in	out	nocopy	t_tbl_VIEW_PRC_SCH
		, p_oCred [PR_CRED]
		)
is
	iIdx			number;
	oDebtComis		[DEBT_COMISS_PRC];
	tKindCredComis	[CONSTANT].BOOLSTRING_TABLE_S;
begin
	&debug('recalcImportance: Найдены задолженности на виде кредита с незаполненным признаком существенности:', 0)
	for (	select	dcp	( dcp.[DEBT] :	debt
						, dcp.[DEBT].[CODE]	: debt_code
						, dcp.[DEBT].[NAME]	: debt_name
						)
		in	::[DEBT_COMISS_PRC]
			, ([KIND_CREDITS] kc) all
		where	kc.[COMISS_ARR] = dcp%collection
				and kc = p_oCred.[KIND_CREDIT]
				and (dcp.[DEPART] is null or dcp.[DEPART] = p_oCred.[DEPART])
				and dcp.[DEBT].[TYPE_DEBT] in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC)
				and dcp.[IMPORTANCE] is null
		)
	loop
		tKindCredComis(dcp.debt) := true;
		&debug('recalcImportance: 	'||dcp.debt_name||' ('||dcp.debt_code||')', 0)
	end loop;
	
	&debug('recalcImportance: обработка комиссионных задолженностей', 0)
	iIdx := p_tCurDebtComis.first;
	while iIdx is not null loop
		if tKindCredComis.exists(p_tCurDebtComis(iIdx).[DEBT]) then
			&debug('recalcImportance: рассчитаем существенность для задолженности '||p_tCurDebtComis(iIdx).[DEBT].[CODE],0)
			p_tCurDebtComis(iIdx).[IMPORTANCE] := setImportanceDebt(p_tCurDebtComis(iIdx), p_oCred);
		end if;
			
		iIdx := p_tCurDebtComis.next(iIdx);
	end loop;

	&debug('recalcImportance: обработка процентных задолженностей', 0)
	iIdx := p_tCurDebtPrc.first;
	while iIdx is not null loop
		if tKindCredComis.exists(p_tCurDebtPrc(iIdx).[DEBT]) then
			&debug('recalcImportance: рассчитаем существенность для задолженности '||p_tCurDebtPrc(iIdx).[DEBT].[CODE],0)
			oDebtComis.[PRC_SCHEME] := p_tCurDebtPrc(iIdx).[PRC_REF];
			oDebtComis.[DEBT] := p_tCurDebtPrc(iIdx).[DEBT];
			p_tCurDebtPrc(iIdx).[STOP_CALC] := setImportanceDebt(oDebtComis, p_oCred);
		end if;
			
		iIdx := p_tCurDebtPrc.next(iIdx);
	end loop;
end;

S226_NEW_DOG (
	@name('Номер договора')
	NUM_DOG in [PRODUCT_NUM],
	@name('Клиент')
	CLIENT in [CLIENT_REF],
	@name('Валюта')
	FT_CREDIT in [FT_MONEY_REF],
	@name('Сумма')
	SUMMA in [NUM_20_4],
	@name('Дата начала')
	DATE_BEGIN in [DATE],
	@name('Дата окончания')
	DATE_ENDING in [DATE],
	@name('Тип кредита')
	DIC_TYPE_CRED in [TYPE_CRED_REF],
	@name('Объект кредитования')
	P_OBJECTS_CRED in [OBJECT_CRED_ARR],
	@name('Примечания')
	NOTES in [MEMO],
	@name('Оборачиваемость')
	P_TURNOVER in [TIME_PERIOD],
	@name('Филиал')
	P_FILIAL in [BRANCH_REF],
	@name('Срок размещения')
	PERIOD in [DIG_6],
	@name('Вид кредита')
	P_KIND_CREDIT in [KIND_CREDITS_REF],
	@name('Сумма / процент')
	P_FOR_OPEN_PAY in [SUMMA],
	@name('Признак процента')
	P_FOR_OPEN_BOOL in [BOOLEAN],
	@name('Плата за лимит в % годовых')
	P_FOR_OPEN_YEAR in [BOOLEAN],
	@name('Номер контракта')
	P_NUM_CONTR in [STRING_250],
	@name('Реквизиты  клиента  для расчетов по кредиту')
	V_CLIENT_REQ in [REQ_CLIENT],
	@name('Подразделение')
	P_DEPART in [DEPART_REF],
	@name('Путь выдачи')
	P_OPER_WAY_OUT in [WAY_KRED_REF],
	@name('Договор продажи векселей')
	P_ISSUE_VEK in [NS_OPER_DOG_REF],
	@name('Единица измерения периода')
	P_PERIOD_UNIT in [REF_UNIT_OF_TIME],
	@name('Генеральное соглашение')
	P_G_AGRIMENT in [GEN_AGREEMEN_REF] default null,
	@name('Продукт, которому предоставлен овердрафт')
	P_PRODUCT in [A_PROD_REF] default null,
	@name('Счет, по которому предоставлен овердрафт')
	P_OVD_ACCOUNT in [AC_FIN_REF] default null,
	@name('Предельная дата выдач')
	P_DATE_PAYOUT_LTD in [DATE] default null,
	@name('Портфель')
	P_LOAN_PORT in [SIM_LOAN_POR_REF] default null,
	@name('Вид сальдирования овердрафта')
	P_CALC_TYPE in [OVER_BALANCE_REF] default null,
	@name('Выбор филиала для урегулирования резерва')
	P_FILIAL_RES in [CASE_BETWEEN_TWO] default null,
	@name('Принадлежность к календарю')
	P_CALENDAR_NAME in [NAME] default null,
	@name('Период - рабочие дни')
	P_PERIOD_WD in [BOOLEAN] default null,
	@name('Оборачиваемость - рабочие дни')
	P_TURNOVER_WD in [BOOLEAN] default null,
	@name('Последний платеж')
	P_BALLOON_PAYMENT in [SUMMA] default null,
	@name('Алгоритм МОП')
	P_MOP_TYPE in [CR_CALC_MOP_REF] default null,
	@name('Комплексный договор')
	P_CO_PROD in [CO_PROD_REF] default null,
	@name('Определить характеристики МСФО')
	P_DEF_IND in [BOOLEAN] default null,
	@name('Количество дней для уплаты комиссии за открытие лимита/счета')
	P_LMT_DAY_TO_PAY in [NUM10] default null
) return ref [PR_CRED] is

validate is
	-- Пересчет суммы ежемесячного платежа первого периода (для платежей с причислением процентов)
	procedure RecalcPaySumma
	is
		dDATE_BEGIN	date;
	begin
		dDATE_BEGIN := coalesce(V_DATE_GIVE, DATE_BEGIN);
		
		&msg(&METHOD$ || '.Обновление настроек ЕП: Массив периодов #' ||to_char(V_FACTOR_MP_ARR));
		
		if (V_FACTOR_MP_ARR is not null) then
			rFirstFactorMPRec := ::[FACTOR_MP].[LIB].GetFirstRec(V_FACTOR_MP_ARR);
		else
			rFirstFactorMPRec := null;
		end if;
		&msg(&METHOD$ || '.Обновление настроек ЕП: Первый период #' || rFirstFactorMPRec%id);
		
		if (rFirstFactorMPRec is not null) then
			V_SUM_PAYMENT := rFirstFactorMPRec.[SUM_PAYMENT];
		else
			V_SUM_PAYMENT := null;
			if (rFactorMPKind is not null) then
				declare
					rFirstFactorMPRecKind	ref [FACTOR_MP_REC];
				begin
					&msg(&METHOD$ || '.RecalcPaySumma: DATE_BEGIN = ' || to_char(dDATE_BEGIN, 'dd/mm/yy'));
					rFirstFactorMPRecKind := ::[FACTOR_MP].[LIB].GetFirstActiveFactor(rFactorMPKind.[FACTOR_MP_ARR], dDATE_BEGIN);
					if (rFirstFactorMPRecKind is not null) then
						V_SUM_PAYMENT := rFirstFactorMPRecKind.[SUM_PAYMENT];
					end if;
				end;
			end if;
		end if;
		&msg(&METHOD$ || '.Обновление настроек ЕП: Сумма платежа первого периода = ' || V_SUM_PAYMENT);
	
		&CSMD_Enabled(V_DEST_STR, 'V_SUM_PAYMENT', 'V', (rFirstFactorMPRec is not null) and (V_FACTOR_MP.[CRED] is not null));
		&msg(&METHOD$ || '. V_DEST_STR = ' || V_DEST_STR);
	end;
	
	-- Пересчет настроек ежемесячных платежей
	procedure RecalcFactorTune(p_oPrCred	[PR_CRED])
	is
	begin
		&msg(&METHOD$ || '.Обновление настроек ЕП: Вид кредита #' || P_KIND_CREDIT%id);
		
		V_FACTOR_MP := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT, p_oPrCred%id);
		&msg(&METHOD$ || '.Обновление настроек ЕП: Настройки ЕП кредита #' || V_FACTOR_MP%id);
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		&msg(&METHOD$ || '.RecalcFactorTune: rFactorMPKind #' || rFactorMPKind%id);
		
		if (V_FACTOR_MP is not null) then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			V_FACTOR_MP_VIEW_ARR := V_FACTOR_MP_ARR;
			::[FACTOR_MP].[LIB].RecalcAnnuityPayments(p_oPrCred%id, V_FACTOR_MP_ARR);
		else
			V_FACTOR_MP_ARR := null;
			if (rFactorMPKind is not null) then
				V_FACTOR_MP_VIEW_ARR := rFactorMPKind.[FACTOR_MP_ARR];
			else
				V_FACTOR_MP_VIEW_ARR := null;
			end if;
		end if;
		&msg(&METHOD$ || '.RecalcFactorTune: V_FACTOR_MP_ARR #' || to_char(V_FACTOR_MP_ARR));
		&msg(&METHOD$ || '.RecalcFactorTune: V_FACTOR_MP_VIEW_ARR #' || to_char(V_FACTOR_MP_VIEW_ARR));
		
		&CSMD_Enabled(V_DEST_STR, 'V_FACTOR_MP_VIEW_ARR', 'V', V_FACTOR_MP_VIEW_ARR is not null);
		
		RecalcPaySumma();
	end;
	
	-- Определение необходимости автоматического копирования настроек ежемесячных платежей
	function RecalcCopyFPTune(p_rPrCred ref	[PR_CRED])
	return boolean
	is
		bAutoCopyMPTune		boolean := false;
	begin
		V_FACTOR_MP := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT, p_rPrCred);
		if V_FACTOR_MP is not null then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			if ::[FACTOR_MP].[LIB].GetFirstActiveFactor(V_FACTOR_MP_ARR) is not null then
				&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита уже заданы индивидуальные настройки ЕП. Копировать не нужно.');
				return false;
			else
				&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита есть индивидуальные настройки ЕП, но не задан ни один период.');
			end if;
		else
			&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита нет индивидуальных настройки ЕП.');
		end if;
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		if rFactorMPKind is null then
			&msg(&METHOD$ || '.RecalcCopyFPTune: У вида кредита не заданы настройки ЕП. Копировать нечего.');
			return false;
		end if;
		&msg(&METHOD$ || '.RecalcCopyFPTune: Настройки ЕП вида кредита используют даты? ' || bool_char(not ::[FACTOR_MP].[LIB].IsFactorsUsePeriod(rFactorMPKind.[FACTOR_MP_ARR]), 'Да', 'Нет'));
		&msg(&METHOD$ || '.RecalcCopyFPTune: Настройки ЕП вида кредита используют суммы? ' || bool_char(::[FACTOR_MP].[LIB].IsFactorsUseSum(rFactorMPKind.[FACTOR_MP_ARR]), 'Да', 'Нет'));
		if (not ::[FACTOR_MP].[LIB].IsFactorsUsePeriod(rFactorMPKind.[FACTOR_MP_ARR]))
		and (::[FACTOR_MP].[LIB].IsFactorsUseSum(rFactorMPKind.[FACTOR_MP_ARR])) then
			bAutoCopyMPTune := coalesce	(::[FP_TUNE].[LIB].get_bool_value
											( 'CRED_FACTOR_COPY'
											, ::[FP_TUNE].[LIB].set_canons
												( ::[METACLASS]%class, p_rPrCred%class
												, ::[KIND_CREDITS]%class, P_KIND_CREDIT
												)
											, false
											)
										, false
										);
			&msg(&METHOD$ || '.RecalcCopyFPTune: Для вида кредита указано автоматическое копирование настроек в договор? ' || bool_char(bAutoCopyMPTune, 'Да', 'Нет'));
		else
			bAutoCopyMPTune := true;
		end if;
		
		if (not bAutoCopyMPTune) then
			return false;
		end if;
		
		return true;
	end;
	
	-- Проверка настроек ежемесячных платежей
	procedure CheckMPTune(p_rPrCred	ref [PR_CRED])
	is
		dDATE_BEGIN	date;
	begin
		dDATE_BEGIN := coalesce(V_DATE_GIVE, DATE_BEGIN);

		if (bCopyMPTune is null) then
			if P_KIND_CREDIT is not null then
				bCopyMPTune := RecalcCopyFPTune(p_rPrCred);
			end if;
			&msg(&METHOD$ || '.CheckMPTune: Рассчитанно bCopyMPTune = ' || bool_char(bCopyMPTune, 'Да', 'Нет'));
		else
			&msg(&METHOD$ || '.CheckMPTune: Уже рассчитанное bCopyMPTune = ' || bool_char(bCopyMPTune, 'Да', 'Нет'));
		end if;
		
		if not coalesce(bCopyMPTune, false) then
			return;
		end if;
		
		&msg(&METHOD$ || '.CheckMPTune: DATE_BEGIN = ' || to_char(dDATE_BEGIN, 'dd/mm/yy'));
		&msg(&METHOD$ || '.CheckMPTune: Копирование настроек ЕП из вида кредита...');
		V_FACTOR_MP := p_rPrCred.[MAKE_DEF_MP](P_KIND_CREDIT, dDATE_BEGIN, false);
		bCopyMPTune := false;
		if (V_FACTOR_MP is not null) then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
		end if;
	end;
	
	-- Инициализация настроек ежемесячных платежей
	procedure InitFactorTune(p_oPrCred	[PR_CRED])
	is
		bKindUseFactor		boolean := false;
		bCredUseFactor		boolean := false;
		bCheckApp			boolean := ::[PR_CRED].[LIB_SERVICE].check_app('1B290033');
	begin
		bCopyMPTune := null;
		&msg(&METHOD$ || '.InitFactorTune: Вид кредита #' || P_KIND_CREDIT%id);
		
		if P_KIND_CREDIT is not null then
			if bCheckApp then
				bKindUseFactor := ::[FACTOR_MP].[LIB].ParamUseFactor(P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			end if;
		end if;
		&msg(&METHOD$ || '.InitFactorTune: Вид кредита содержит параметр планирования ЕП? ' || bool_char(bKindUseFactor, 'Да', 'Нет'));
	
		&CSMD_VisibleS(V_DEST_STR, 'FrameFactor', bKindUseFactor);
		
		if bCheckApp then
			bCredUseFactor := ::[FACTOR_MP].[LIB].ParamUseFactor(V_PARAM_FOR_PLAN_A);
		end if;
		&msg(&METHOD$ || '.InitFactorTune: Кредит содержит параметр планирования ЕП? ' || bool_char(bCredUseFactor, 'Да', 'Нет'));
		
		&CSMD_EnabledS(V_DEST_STR, 'FrameFactor', bCredUseFactor);
		-- Скрыть/отобразить "Планирование -> Сумма погашения" в том числе и для конструктора планирования
		&CSMD_VisibleS(V_DEST_STR, 'FrameSumPay', (not bCredUseFactor and not coalesce(V_USE_PLAN_RULE, false)));
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		&msg(&METHOD$ || '.InitFactorTune: Настройки ЕП вида кредита #' || rFactorMPKind%id);
		
		&CSMD_EnabledS(V_DEST_STR, 'BTN_FACTOR_MP_DEFAULT', (rFactorMPKind is not null));
		
		CheckMPTune(p_oPrCred%id);
		RecalcFactorTune(p_oPrCred);
	end;
	
	-- Функция проверки параметров планирования для МОПов
	function CheckP4P(p_oPrCred	[PR_CRED]) return boolean is
		bMop	boolean;
	begin
		-- Если на договоре есть параметр планирования Гашение МОП и установлен реквизит Алгоритм расчета МОП
		-- то добавляет параметр планирования входящий в состав МОП не следует
		bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(p_oPrCred.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
		if P_MOP_TYPE is not null and bMop and V_PARAM_FOR_PLAN_REF.[OPER]<>::[VID_OPER_DOG]([CODE]='ГАШЕНИЕ_МОП' ) then
			for mt in P_MOP_TYPE.[DEBTS_MOP] where mt.[PLAN_OPER] = V_PARAM_FOR_PLAN_REF.[OPER] loop
				return false;
			end loop;
		end if;
		return true;
	end;


	-- Процедура обновления таблицы параметров планирования
	procedure Update_P4P_Grid(p_oPrCred	[PR_CRED]) is
		FoundP4P	boolean;
	begin
		V_P4P_GRID.delete;
		FoundP4P := false;
		-- BS00135391. Записи в гриде будут упорядочены по дате начала гашения, наименованию операции и ID записи
		for p4p in V_PARAM_FOR_PLAN_A order by p4p.[PAY_BEGIN_DATE], upper(p4p.[OPER].[SYS_NAME]), p4p%id loop
			V_P4P_GRID(nvl(V_P4P_GRID.last, 0) + 1) := p4p;
			if not(V_PARAM_FOR_PLAN_REF is null) and V_PARAM_FOR_PLAN_REF = p4p then
				V_P4P_IDX := V_P4P_GRID.last;
				FoundP4P := true;
			end if;
		end loop;
		if not FoundP4P then
			V_P4P_IDX := V_P4P_GRID.count;
		end if;
		InitFactorTune(p_oPrCred);
	end;

	-----------------------------------------------------------------------------------------------------------------
	-- Процедура Call_Check_Transh_Acc
	-----------------------------------------------------------------------------------------------------------------
	procedure Call_Check_Transh_Acc(rPrCred	ref [PR_CRED]) is
	begin
		if V_CR_CLASS != 'OVERDRAFTS' then
			if Check_Transh_Acc( FT_CREDIT, P_FILIAL, CLIENT, PERIOD, P_ACCOUNT, P_HIGH_LEVEL_CR, ACCs_ID, rPrCred, nvl(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING) then
				[CSMD].Show(V_DEST_STR, 'P_ACCOUNT', 'V');
			else
				[CSMD].Hide(V_DEST_STR, 'P_ACCOUNT', 'V');

			end if;
		end if;
	end;

	-----------------------------------------------------------------------------------------------------------------
	-- Процедура CALC_NUM_DOG
	-----------------------------------------------------------------------------------------------------------------
	procedure CALC_NUM_DOG is
		counter	number := 0;
	begin
		if	NUM_DOG is null then
			if	P_KIND_CREDIT is null then pragma error('NEW_DOG_N Укажите вид кредита от него может зависеть номер договора !');
			else		[KIND_CREDIT]	:= 	P_KIND_CREDIT;
			end if;
			if	CLIENT is null then pragma error('NEW_DOG_N Укажите клиента от него может зависеть номер договора !');
			else		
				[CLIENT]	:= 	CLIENT;
				if P_OVD_ACCOUNT is not null then
					[OVER_ON_PROD] := P_PRODUCT;	-- продукт, по которому предоставлен кредит
				end if;
			end if;
			if P_KIND_CREDIT = KindCredits_06 then -- для траншей
 				if P_HIGH_LEVEL_CR is null then pragma error('Укажите траншем какой линии является данный договор !');
				else	[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;
				end if;
			else
				--- BFS00030291 Проверим, может, это транш, но вид кредита у него отличен от KindCredits_06 и указан в виде кредита линии
				declare
					kind_line ref [KIND_CREDITS];
				begin
					if not(P_HIGH_LEVEL_CR is null) then
						kind_line := null;
						for(select	 k	(
											k	:	kk
										)
										in ::[KIND_CREDITS] all
										where k.[LINE_TRANSH] = P_KIND_CREDIT
						)
						loop
							kind_line := k.kk;
							exit;
						end loop;
						if not(kind_line is null) then
							if not nvl(P_HIGH_LEVEL_CR.[INVOICE], false) then
								[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;
							end if;
						end if;
					end if;
				end;
			end if;
			if not(P_KIND_CREDIT.[NUM_SHABL] is null) then
				::[PR_CRED].[GET_CONTROL_VAL].Flush;
				NUM_DOG := [GET_NEW_NUM_DOG](P_KIND_CREDIT.[NUM_SHABL]);
			end if;
			if NUM_DOG is null and P_G_AGRIMENT is not null then
				for over in P_G_AGRIMENT.[OVERDRAFTS]
				loop
					counter := counter + 1;
				end loop;
				NUM_DOG := P_G_AGRIMENT.[NUM_DOG]||'-'||to_char(counter);
			end if;
			[NUM_DOG]	:= NUM_DOG;
		else
			[STDIO].put_line_buf('NEW_DOG_N: Уже заполнен номер договора, удалите его для генерации нового ! ');
		end if;
	end;
	
	--процедура снятия savepoint
	procedure deleteSavePoint
	is
	begin
		&debug('.deleteSavePoint: g_needDropPoint '||bool_char(g_needDropPoint)||' g_clickBtnRule '||bool_char(g_clickBtnRule)||' g_clickBtnSeason '||bool_char(g_clickBtnSeason), 0)
		if g_needDropPoint then
			&rb(recalcP4P)
			V_CRED_VBS := this;
			V_NEED_DROP := true;
			
		elsif g_clickBtnSeason then
			&rb(prSeason)
			g_clickBtnSeason := false;
			
		else
			&rb(ChangeRule)
			g_clickBtnRule := false;
		end if;
	end;

	procedure presaveThis is
		oCred		[PR_CRED];
	begin
		oCred := this;

		oCred.[SUMMA_DOG]		:= SUMMA;			--	Сумма договора
		oCred.[LIMIT_SALDO]		:= V_LIMIT_SALDO;	--	Лимит задолженности
		oCred.[KIND_CREDIT]		:= P_KIND_CREDIT;	--	Вид кредита
		oCred.[FT_CREDIT]		:= FT_CREDIT;		--	Валюта кредита
		oCred.[DATE_ENDING_MAX]	:= V_DATE_ENDING_MAX;	--	Максимальная дата окончания
		oCred.[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;	--  Кредит верхнего уровня
		oCred.[DATE_GIVE]		:= V_DATE_GIVE;		--	дата выдачи (не обязательно)
		oCred.[DATE_BEGIN]		:= DATE_BEGIN;		--	дата начала договора
		oCred.[DATE_ENDING]		:= DATE_ENDING;		--	дата окончания договора
		oCred.[INVOICE]			:= V_INVOICE;		--	признак "до востребования"
		oCred.[DIC_TYPE_CRED]	:= DIC_TYPE_CRED;	--	правило учета кредитного договора
		oCred.[TURNOVER]		:= P_TURNOVER;		--	максимальный срок выдачи
		oCred.[CALENDAR_NAME]	:= P_CALENDAR_NAME;	--  календарь договора
		-- 	комиссия за открытие лимита/счета
		oCred.[FOR_OPEN_PAY]	:= P_FOR_OPEN_PAY;
		oCred.[FOR_OPEN_BOOL]	:= P_FOR_OPEN_BOOL;
		oCred.[FOR_OPEN_YEAR]	:= P_FOR_OPEN_YEAR;
		oCred.[FOR_OPEN_FN]		:= P_FOR_OPEN_FN;

		set_balloon_payment(this, DATE_BEGIN, P_BALLOON_PAYMENT);	-- размер балуна

		this := oCred;
	end;
	
	-----------------------------------------------------------------------------------------------------------------
	-- Процедура call_make_plan_pr
	-----------------------------------------------------------------------------------------------------------------
	procedure call_make_plan_pr(bCheck boolean default true)
	is
		bCanCall	boolean	:= true;
		dOperDay	date;
	begin
		if g_needDropPoint then
			&sp(RecalcP4P)
		end if;
		
		presaveThis();
		
		--<Akil> Обновление продуктовых	настроек
		[GET_CONTROL_VAL].flush; -- сброс кеша значений контролов
		
		--максимальный срок выдачи в рабочих днях
		P_TURNOVER_WD := nvl(P_TURNOVER_WD, false);
		dOperDay := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(this.[FILIAL]);
		if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(dOperDay, nvl(this.[DATE_BEGIN], dOperDay)),::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD')) = '1', false) <> P_TURNOVER_WD then
			-- сначала удаляем исходное значение в настройке, а затем создаем
			::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'));
			::[PROPERTY_PROD].[LIB].AddProperty(this, this.[DATE_BEGIN], null, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'), P_TURNOVER_WD);	
		end if;
		
		--изменим дату начала сезонности
		::[PR_CRED].[NEW_DOG_LIB].setDateBeginSeason(this, DATE_BEGIN);
		
		-- обновление значений настроек
		nShift_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_FIRST_PLAN', this%class, this.[DEPART],
			null, this.[PRJ_KIND_CRED], this.[KIND_CREDIT]).[NUMBER_VALUE];
		
		nAdd_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_PLAN_CRED', this%class, this.[DEPART],
			null, this.[PRJ_KIND_CRED], this.[KIND_CREDIT]).[NUMBER_VALUE];
		
		-- Проверка на присутствие значения во всех требуемых реквизитах
		-- (Если данную проверку не сделать, то MAKE_DEFAULT_PP может сломаться
		-- с соответствующим сообщением об ошибке)
		if bCheck then
			pragma macro
				( CheckAttr
				, 'bCanCall := bCanCall and (this.[1] is not null)'
				, substitute
				);

			&CheckAttr( [SUMMA_DOG] );
			&CheckAttr( [PARAM_FOR_PLAN] );
			&CheckAttr( [KIND_CREDIT] );
			&CheckAttr( [FT_CREDIT] );	
			bCanCall := bCanCall and (::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) is not null);

			if not nvl(this.[INVOICE], false) then
				&CheckAttr( [DATE_ENDING] );
			end if;
			bCanCall := bCanCall and (not(this.[DATE_GIVE] is null and this.[DATE_BEGIN] is null));
		else
			bCanCall := true;
		end if;
		
		&debug('.call_make_plan_pr: bCanCall '||bool_char(bCanCall)||' bRebuildPlanRule '||bool_char(bRebuildPlanRule), 0)
		if bCanCall then
			--null только до первого пересчета
			if V_USE_PLAN_RULE is null then
				--если признак не был установлен, то установим его если конструктор указан на виде кредита
				V_USE_PLAN_RULE := coalesce(P_KIND_CREDIT.[PR_DEBT]%size(0) > 0, false) or (not P_HIGH_LEVEL_CR is null and P_HIGH_LEVEL_CR.[PR_DEBT]%size(0) > 0); -- updated CHANGE_QUALIFIER PR_RULE->PR_DEBT 19/10/15
				if V_USE_PLAN_RULE then
					--валидация фрейма с возможными действиями по конструктору планирования
					::[PR_CRED].[NEW_DOG_LIB].validateUsePlanRule(V_USE_PLAN_RULE, V_DEST_STR);
				end if;
			end if;
			
			--нужно ли перестроить конструктор?
			if bRebuildPlanRule then
				if V_USE_PLAN_RULE then
					--если по правилам планирования, то нужно перенести конструктор на договор
					::[PR_CRED].[NEW_DOG_LIB].clearPlanRule(this);
					::[PR_CRED].[NEW_DOG_LIB].makePlanRule(this, P_KIND_CREDIT, P_HIGH_LEVEL_CR, coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING);
				else
					::[PR_CRED].[NEW_DOG_LIB].clearPlanRule(this);
				end if;
				bRebuildPlanRule := false;
			end if;
			
			V_PARAM_FOR_PLAN_REF := null;
			::[CRED_INTERFACE].[PRX_PLAN].Cred_MAKE_DEFAULT_PP( this, true, null, V_COPY_HL_PP, V_USE_PLAN_RULE);
			V_PARAM_FOR_PLAN_A := this.[PARAM_FOR_PLAN];
			V_P4P_PLAN_RULE := V_PARAM_FOR_PLAN_A;
			Update_P4P_Grid(This);
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
			' || NL$;
		end if;

		if bRebuildParam4Plan then
			bRebuildParam4Plan := false;
		end if;
		
		g_clickBtnRule := false;
		g_clickBtnSeason := false;
		
	exception when others then
		if g_needDropPoint or g_clickBtnRule or g_clickBtnSeason then
			deleteSavePoint();
			if g_needDropPoint then
				stdio.put_line_buf(sqlerrm);
			else
				raise;
			end if;
			
		elsif not coalesce(g_needDropPoint, false) then
			raise;
		end if;
	end;

	-----------------------------------------------------------------------------------------------------------------
	-- Процедура set_from_gen_agr
	-----------------------------------------------------------------------------------------------------------------
	procedure set_from_gen_agr(p_oPrCred	[PR_CRED]) is
	begin
		if not P_G_AGRIMENT is null then
			if nvl(P_G_AGRIMENT.[COM_STATUS], &LCONST.STATUS_CLOSE) != &LCONST.STATUS_WORK then
				pragma error('Ген. соглашение на овердрафт не находится в состоянии "Работает"');
			end if;
			P_PRODUCT		:= P_G_AGRIMENT.[AGREEM_TO_RPOD];
			P_OVD_ACCOUNT	:= P_G_AGRIMENT.[AGREEM_TO_RPOD].[ACCOUNT];
			FT_CREDIT		:= nvl(P_G_AGRIMENT.[AGREEM_TO_RPOD].[ACCOUNT].[FINTOOL],FT_CREDIT);
			P_FILIAL		:= nvl(P_G_AGRIMENT.[FILIAL], P_FILIAL);
			P_DEPART		:= nvl(P_G_AGRIMENT.[DEPART], P_DEPART);
			CLIENT			:= P_G_AGRIMENT.[AGREEM_TO_RPOD].[CLIENT];
			DATE_BEGIN		:= coalesce(P_G_AGRIMENT.[DATE_BEGINING], P_G_AGRIMENT.[DATE_BEGIN]);
			V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
			V_CLIENT_REQ.[1].[1] := CLIENT;
			V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;

			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
			
			
			for over	in P_G_AGRIMENT.[OVERDRAFTS]
						where over%id != p_oPrCred%id
						order by over.[DATE_ENDING] desc
			loop
				DATE_BEGIN := over.[DATE_ENDING] + 1;
				exit;
			end loop;
			P_PERIOD_UNIT := UT_DAY;
			DATE_ENDING := DATE_BEGIN + 29;
			P_PERIOD_WD := nvl(P_PERIOD_WD, false);
			for over	in P_G_AGRIMENT.[OVERDRAFTS]
						where over%id != p_oPrCred%id
						order by over.[DATE_BEGIN] desc
			loop
				if (over.[COM_STATUS]!=&LCONST.STATUS_CLOSE and over.[DATE_CLOSE] is null) then
					P_ACCOUNT			:= nvl(P_ACCOUNT, over.[ACCOUNT]);
				end if;			
				declare
					rScheme		 ref [PRC_SCHEME];
					Scheme_Name  ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				begin
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							p_oPrCred.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.[COMISS_ARR], Scheme_Name),
							Scheme_Name);
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(p_oPrCred.[COMISS_ARR], Scheme_Name);
					V_CREDIT_ARR := rScheme.[LIST_SCH_PRC];
					V_PRC_RATE	 := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
					rScheme.[P_PRIVATE]	:= false; -- снимаем признак индивидуального использования

					Scheme_Name := &LCONST.VD_PRC_PENY;
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							p_oPrCred.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.[COMISS_ARR], Scheme_Name),
							Scheme_Name);

					Scheme_Name := &LCONST.VD_CREDIT_PENY;
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							p_oPrCred.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.[COMISS_ARR], Scheme_Name),
							Scheme_Name);
				end;
				exit;
			end loop;
			CALC_NUM_DOG;
			validate_gen_arg ( P_G_AGRIMENT, V_DEST_STR);
		end if;
	end;


	-- BS00140713 --------------------------------------------------------------------
	-- Процедура Check_Res_Filial: проверяет необходимость отображения контрола P_FILIAL_RES на ЭФО
	----------------------------------------------------------------------------------
	procedure Check_Res_Filial(p_oPrCred	[PR_CRED]) is
		bTune_RezByPort boolean;
	begin
		-- определим значение признака REZ_ON_PORT, с которым договор будет включаться в портфель
		bTune_RezByPort := nvl(::[FP_TUNE].[LIB].get_bool_value('REZ_BY_PORT'), false);
		
		if bTune_RezByPort and P_LOAN_PORT is not null then
			-- резерв по договору будет урегулироваться по портфелю, берем настройку и признак с портфеля
			Gl_rDepart_Res := ::[PRODUCT].[L_RES].get_tune_res_fil(P_LOAN_PORT.[FILIAL], 'SIM_LOAN_PORT', Oper_Day);
			if ::[PRODUCT].[L_RES].get_res_fil_sign(P_LOAN_PORT.[RES_OTHER_FIL]) then
				P_FILIAL_RES.[0] := 2;
			else
				P_FILIAL_RES.[0] := 1;
			end if;
			-- признак не доступен для редактирования
			[CSMD].Disable(V_DEST_STR, 'P_FILIAL_RES');
		else
			-- резерв по договору будет формироваться индивидуально, берем настройку с договора
			Gl_rDepart_Res := ::[PRODUCT].[L_RES].get_tune_res_fil(P_FILIAL, p_oPrCred%class, Oper_Day);
			
			-- Разблокируем признак для редактирования
			[CSMD].Enable(V_DEST_STR, 'P_FILIAL_RES');
			
			if P_HIGH_LEVEL_CR is not null then
				if nvl(::[PRODUCT].[L_RES].get_res_fil_sign(P_HIGH_LEVEL_CR.[RES_OTHER_FIL]),false) then
					P_FILIAL_RES.[0] := 2;
				else
					P_FILIAL_RES.[0] := 1;
				end if;			
				
				if nvl(::[FP_TUNE].[LIB].get_num_value('CR_REZ_LN',::[FP_TUNE].[LIB].set_canons('DEPART',[DEPART]%id)),0) = 1 then
					[CSMD].Disable(V_DEST_STR, 'P_FILIAL_RES');
				end if;
			else
				P_FILIAL_RES.[0] := 2;
			end if;
		end if;
		
		-- Скроем/отобразим контролы на ЭФО
		if Gl_rDepart_Res is not null then
			[CSMD].Show(V_DEST_STR, 'P_FILIAL_RES');
			[CSMD].Command(V_DEST_STR, NL$||'ResFilial1.Caption = "Филиал договора ('||replace(P_FILIAL.[CODE],'"','""')||')"'||NL$);
			[CSMD].Command(V_DEST_STR, NL$||'ResFilial2.Caption = "Филиал из настройки RES_IN_OTHER_FILIAL ('||replace(Gl_rDepart_Res.[FILIAL].[CODE],'"','""')||')"'||NL$);
		else
			[CSMD].Hide(V_DEST_STR, 'P_FILIAL_RES');
		end if;
	end;

	function ISBalloon return boolean is
	begin
		if (P_KIND_CREDIT is not null and P_KIND_CREDIT.[BALLOON_PAYMENT]) or (P_KIND_CREDIT is null and DECL_ON_CRED_REF.[KIND_CREDIT].[BALLOON_PAYMENT]) then
			&debug('FUNCTION ISBalloon returned TRUE',0)
			return true;
		else
			&debug('FUNCTION ISBalloon returned FALSE',0)
			return false;
		end if;
	end;

	procedure balloon_validate is
	begin
		if ISBalloon then
			[CSMD].Command(V_DEST_STR, 'balloon_payment.Visible = True');
			[CSMD].Command(V_DEST_STR, 'balloon_label.Visible = True');
		else
			[CSMD].Command(V_DEST_STR, 'balloon_payment.Visible = False');
			[CSMD].Command(V_DEST_STR, 'balloon_label.Visible = False');
			P_BALLOON_PAYMENT := NULL;
		end if;
	end;
	
	procedure Check_Scheme(rScheme ref	[PRC_SCHEME]) is
	begin
		if IsSharedScheme(rScheme, this.[COMISS_ARR]) then
			bCanSaveRate := false; -- запрещаем текущее обновление ставки
			V_CAN_PRC_SCH := 0;
			--Проверим права пользователя на операцию PRC_SCH_ACCESS
			if [RUNTIME].[SECURITY].Is_Method_Accessible('PRC_SCHEME', 'PRC_SCH_ACCESS', [stdlib].userid.[USERNAME]) then
				--есть права, предоставим выбор что сделать со ставкой
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
				if Form1.ScriptPlayEx("<% PLPCALL [PRC_SCHEME].[PRC_SCH_ACCESS](%PARAM%.P_COPY_SCH => ''FALSE'', %PARAM%.P_VALUE => %VAR%.V_CAN_PRC_SCH) %>") then
					Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_YES")
				else
					Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_NO")
				end if
				' || NL$;						
			else
				--нет прав, откатываем изменение ставки
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
				if MsgBox("У вас нет прав на изменение общей процентной схемы.", vbOKOnly, "Внимание!") = vbOK then
					Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_NO")
				end if
				' || NL$;
			end if;
		end if;
	end;
	
	----- переменные ------------------------
	i				integer;
	sField			varchar2(100);
	rScheme			ref	[PRC_SCHEME];
	fPenMainRate	number;
	fPenPrcRate		number;
	
	reqs_cl_tmp		[PR_CRED].[CLIENT_REQ]%type;
	v_kind_early 	ref [EARLY_PAY];
	
	sADDS 			varchar(300);
	sErrMess 		varchar(2000);
	
	bMop			boolean;
	iPeriod			integer;
	nIdxCmsRow 		number; --Индекс для массива V_COMISS_TBL
	rTypeDebt		ref [TYPE_DEBT];
	sCalendar		varchar2(100);
-----------------------------------------------------------------------------------------------------------------
-- ТЕЛО ВАЛИДАТОРА
-----------------------------------------------------------------------------------------------------------------
begin
	FillPrc_Arr(Prc_Arr);
-- DEFAULT
	&debug('p_message '||p_message||' p_info '||p_info, 0)
	sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(this, V_CALENDAR%id);
	if p_message = 'DEFAULT' then
	
		-- Исправлено изменение по RP0413801 в части переноса умолчательного значения параметра P_OBJECTS_CRED для обеспечения совместимости с режимом потокового ввода.
		P_OBJECTS_CRED := this.[OBJECTS_CRED];
		V_PARAM_FOR_PLAN_A := nvl(V_PARAM_FOR_PLAN_A, this.[PARAM_FOR_PLAN]);
		V_LIST_PLAN_PAY_ARR := nvl(V_LIST_PLAN_PAY_ARR, this.[LIST_PLAN_PAY]);
		V_DEBTORS := nvl(V_DEBTORS, this.[DEBTORS]);
		V_PROPERTIES := nvl(V_PROPERTIES, this.[PROPERTIES]);
		V_PRC_DEP_TURN_ACC_LIST := nvl(V_PRC_DEP_TURN_ACC_LIST, this.[PRC_DEP_TURN].[ACC_LIST]);
		V_PRC_DEP_TURN_PRC_DEP_SCHEME := nvl(V_PRC_DEP_TURN_PRC_DEP_SCHEME, this.[PRC_DEP_TURN].[PRC_DEP_SCHEME]);
		V_SUMMA_PAY := nvl(V_SUMMA_PAY, this.[SUMMA_PAY]);
		V_LIST_EXP_PAY_ARR := nvl(V_LIST_EXP_PAY_ARR, this.[LIST_PLAN_PAY]);
		dateHist := DATE_BEGIN;
		V_PRJ_KIND_CRED := null;
		V_CAN_PRC_SCH := 9;
		V_DO_FACTORING := true;
		V_CLIENT_REQ.[1].[1] := coalesce(V_CLIENT_REQ.[1].[1], CLIENT);
		[CSMD].Init_Form(V_DEST_STR, &METHOD$CLASS, &METHOD$SNAME);
		
		executor.set_context('CRED_BUS_PROC', &cBP_REGISRATION%id);

		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290076', 'P_CALENDAR_NAME,v_calendar');
		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290055', 'SET_TUNE_LIMIT');
		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290033', 'FrameFactor');
		
		[CSMD].Command(V_DEST_STR, 'CorpTextBox.MaxLength = ' || [PAYER_NAME].[LIB].gcn_LENGTH);
		
		if isNUK is null then
			isNUK := nvl(::[FP_TUNE].[LIB].get_bool_value('RT_NUK_ON'), false);
		end if;
		
		if not isNUK then
			[CSMD].Command(V_DEST_STR, 'Frame_Restr.VISIBLE = true');		
			[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.VISIBLE = false');	
		else			
			[CSMD].Command(V_DEST_STR, 'Frame_Restr.VISIBLE = false');
			[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.VISIBLE = true');	
		end if;
		
		user_access_for_event := check_User_Access;
		if user_access_for_event then
			[CSMD].Enable(V_DEST_STR, 'V_TO_BKI', 'V');
		else
			[CSMD].Disable(V_DEST_STR, 'V_TO_BKI', 'V');
		end if;
						
		V_TO_BKI := coalesce([FP_TUNE].[LIB].get_bool_value('TO_BKI_DEFAULT', ::[FP_TUNE].[LIB].set_canons('METACLASS', This%class), '0'),false);
		
		-- Читаем параметры для Oper_Day --
		if P_DEPART is null then
			P_DEPART := [STDLIB].UserId.[DEPART];
			P_FILIAL := P_DEPART.[FILIAL];
		end if;
		P_FILIAL := nvl(P_FILIAL, P_DEPART.[FILIAL]);
		
		Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
		
		bRebuildParam4Plan := false;
		v_ShareMainPrc := null;

        -- Параметры планирования
		V_PLAN_ALL := true;				-- Крыжик "планировать все"
		V_PARAM_FOR_PLAN_REF := null;   -- Ссылка на текущий параметр планирования
		V_P4P_IDX := 0;					-- Индекс текущего параметра планирования в таблице параметров
		v_old_kind := P_KIND_CREDIT;
		V_CHANGE_RULE := null;

		::[CRED_INTERFACE].[PRX_ZALOG].Set_ref_prod(this); -- для привязки обеспечения к договору
		executor.set_context('ZALOG_PROD', this%id);
		FT_CREDIT := ::[SYSTEM].[SYS_MAIN_VAL];

		parent_class := this%parentclass;
		if parent_class = 'GEN_AGREEMENT' then
			P_G_AGRIMENT := this%parent;
		elsif parent_class = 'GEN_AGREEM_FRAME' then
			V_GEN_AGR := this%parent;
		end if;
		
		if V_GEN_AGR is not null then
			[STR].set_par(sAdds,'CHECK_LIMIT', '0');
			iPeriod := PERIOD;
			if ::[PR_CRED].[NEW_DOG_LIB].check_gen_agreem_frame(this, DATE_BEGIN, DATE_ENDING, iPeriod, FT_CREDIT, CLIENT, SUMMA, P_FILIAL, P_DEPART, P_OBJECTS_CRED, V_LIMIT_SALDO, P_HIGH_LEVEL_CR, P_KIND_CREDIT, err_mess) = false then
				pragma error(err_mess);
			end if;
			PERIOD := iPeriod;
			disable_when_gen_frame;
			[OBJECTS_CRED] := P_OBJECTS_CRED;
			V_OBJ_CRED := [L_ALEX].get_main_obj(this);
		end if;

		[DEPART]		:= P_DEPART;

		[FILIAL]		:= P_FILIAL;
		DATE_BEGIN		:= nvl(DATE_BEGIN, Oper_Day);
		[DATE_BEGIN]	:= DATE_BEGIN;
		V_DATE_GIVE		:= DATE_BEGIN;
		P_FOR_OPEN_FN	:= FT_CREDIT;
		P_PERIOD_UNIT 	:= UT_DAY;
		P_PERIOD_WD		:= false;
		V_CR_CLASS		:= this%class;
		
		case V_CR_CLASS of
		: 'KRED_PERS' :
			CL_CLASS := 'CL_PRIV';
		: 'KRED_CORP' :
			CL_CLASS := 'CL_ORG';
		: 'KRED_BANK' :
			CL_CLASS := 'CL_BANK_N CL_PART';
		: 'OVERDRAFTS' :
			CL_CLASS := 'CL_ORG CL_PRIV';
			
			if nvl(p_info, 'null') != '%PLPCALL%' then
				[KIND_CREDIT] = P_KIND_CREDIT := KindCredits_04;
				DIC_TYPE_CRED := P_KIND_CREDIT.[REG_RULES];
			end if;
		end;
		
		V_COPY_HL_PP := true;
		
		DECL_ON_CRED_REF := ::[CRED_INTERFACE].[PRX_DECL_ON_GET].GET_GLOBAL_DECL;
				
		-- Вызвана из заявки
		if DECL_ON_CRED_REF is null then
			if V_CR_CLASS = 'OVERDRAFTS' then
				PERIOD := 29;
				P_PERIOD_UNIT := UT_DAY;
				P_PERIOD_WD := false;
				DATE_ENDING	:= [L].Shift_Holiday(DATE_BEGIN + 29, -1, this%class, sCalendar);
			end if;
			get_def_prc_schemes(P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);
			bChangeRate := true;
		else
			bChangeRate := false;
			get_def_prc_schemes(DECL_ON_CRED_REF.[KIND_CREDIT].[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);
			::[CRED_INTERFACE].[PRX_DECL_ON_GET].SET_GLOBAL_DECL(null);
			::[CRED_INTERFACE].[PRX_DECL_ON_GET].set_from_decl(DECL_ON_CRED_REF
															, this
															, FT_CREDIT
															, CLIENT
															, P_KIND_CREDIT
															, P_HIGH_LEVEL_CR
															, SUMMA
															, V_SUM_STR
															, PERIOD
															, V_PRC_RATE
															, P_OBJECTS_CRED
															, V_ANNUITET
															, V_DATE_GIVE
															, DIC_TYPE_CRED
															, DATE_ENDING
															, DATE_BEGIN
															, P_FILIAL
															, P_DEPART
															, P_PERIOD_UNIT
															, fPenMainRate
															, fPenPrcRate
															, P_NUM_CONTR
															, V_EARLY_PAY
															, NUM_DOG
															, P_PERIOD_WD
															, P_BALLOON_PAYMENT);
			-- Перечитаем дату опердня --
			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);

			V_PRJ_KIND_CRED := P_KIND_CREDIT.[TYPE_PROJECT];
				
			if DIC_TYPE_CRED is null then
				pragma error('Не указано правило учета договора!');
			end if;

			if not CLIENT is null and not FT_CREDIT is null then
				-- Устанавливаем клиента и валюту по заявке
				[CLIENT] := CLIENT;
				[FT_CREDIT] := FT_CREDIT;
				V_CLIENT_REQ := [GET_CUST_PROPS];	-- Получаем реквизиты клиента для расчетов по кредиту
				[KIND_CREDIT] := P_KIND_CREDIT;
			end if;
			
			if not fPenMainRate is null then
				declare
					Scheme_Name  ref [VID_DEBT] := &LCONST.VD_CREDIT_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme('R',
												'ПЕНЯ_КРЕДИТ',
												fPenMainRate,
												rScheme,
												Prc_Arr(Find_Prc_Arr('ПЕНЯ_КРЕДИТ', Prc_Arr)).[Proc_Arr],
												this,
												Oper_Day,
												Oper_Day,
												V_ANNUITET,
												V_ONE_DAY,
												FT_CREDIT);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;
			
			if not fPenPrcRate is null then
				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_PRC_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme('R',
												'ПЕНЯ_ПРОЦЕНТЫ',
												fPenPrcRate,
												rScheme,
												Prc_Arr(Find_Prc_Arr('ПЕНЯ_ПРОЦЕНТЫ', Prc_Arr)).[Proc_Arr],
												this,
												Oper_Day,
												Oper_Day,
												V_ANNUITET,
												V_ONE_DAY,
												FT_CREDIT);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;

			V_DATE_GIVE := DATE_BEGIN;
			V_INVOICE := nvl(P_KIND_CREDIT.[INVOICE], false);

			declare
				Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
			begin
				rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
				if not P_HIGH_LEVEL_CR is null then
					rSchemeHLC := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[HIGH_LEVEL_CR].[COMISS_ARR], Scheme_Name);
				end if;
				if not IsSharedScheme(rScheme, this.[COMISS_ARR]) then
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme_R('НЕУЧТЕН_ПРОЦЕНТЫ',
												V_PRC_RATE,
												rScheme,
												V_CREDIT_ARR,
												this,
												DATE_BEGIN,
												greatest(Oper_Day, DATE_BEGIN),
												V_ANNUITET,
												V_ONE_DAY,
												FT_CREDIT);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end if;
				-- Если у транша и у линии одна процентная схема, то
				-- запретить редактировать ставку на первой закладке
				if not rSchemeHLC is null and not rScheme is null and rScheme = rSchemeHLC then
					[CSMD].Disable(V_DEST_STR, 'V_PRC_RATE','V');
				else
					[CSMD].Enable(V_DEST_STR, 'V_PRC_RATE','V');
				end if;

			end;
				
			bRebuildParam4Plan := true;
			
			[OBJECTS_CRED] := P_OBJECTS_CRED;
			V_OBJ_CRED := [L_ALEX].get_main_obj(this);
			
			P_LOAN_PORT := get_port(this);
			
			PR_CRED.[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
		end if;
		
		if P_HIGH_LEVEL_CR is null then
			glHL_PERIOD_NUM = glHL_PERIOD_UNIT := null;
		else
			glHL_PERIOD_UNIT:= null;
			glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																, DATE_BEGIN
																, propTRANSH_PERIOD_NUM);
			if not glHL_PERIOD_NUM is null then
				PERIOD := glHL_PERIOD_NUM;
				P_PERIOD_UNIT = glHL_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
				P_PERIOD_WD := false;
			end if;
		end if;
		
		if not P_KIND_CREDIT is null
			and not P_KIND_CREDIT.[DEF_PERIOD_MS] is null
			and not P_KIND_CREDIT.[DEF_PERIOD_NUM] is null
			and glHL_PERIOD_NUM is null
		then
			PERIOD := P_KIND_CREDIT.[DEF_PERIOD_NUM];
			P_PERIOD_UNIT := P_KIND_CREDIT.[DEF_PERIOD_MS];
			P_PERIOD_WD := false;
		end if;
		
		if not nvl(::[HOOK].[CRED_COPY_PROPS](this, DECL_ON_CRED_REF), false) then
			::[PROD_PROPERTY].L.make_default_properties(V_PROPERTIES, V_CR_CLASS, DATE_BEGIN, P_KIND_CREDIT.[CODE]);
		end if;
		
		::[CRED_INTERFACE].[PRX_PRC_SCHEME].SetVariablesNewSimple(p_names == ',CR_DOG,', CR_DOG == this);
		::[CRED_INTERFACE].[PRX_PRC_SCHEME].SetVariables(p_names == ',V_PRODUCT,', V_PRODUCT == this);

		-- Ген. соглашение на овердрафт
		set_from_gen_agr(This);

		if not P_HIGH_LEVEL_CR is null then
			FT_CREDIT	:= P_HIGH_LEVEL_CR.[FT_CREDIT];
			V_GEN_AGR	:= null;
			CLIENT		:= P_HIGH_LEVEL_CR.[CLIENT];
		 	V_LIMIT_CR	:= ::[PR_CRED].[L].GetSumDebt(P_HIGH_LEVEL_CR, &LCONST.VD_LIMIT, Oper_Day);
		 	P_INFO		:= 'CLIENT';
		 	P_KIND_CREDIT := nvl(P_HIGH_LEVEL_CR.[KIND_CREDIT].[LINE_TRANSH], KindCredits_06);
		 	DIC_TYPE_CRED := &LCONST.TC_CRED_CONT;
			
			if P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] then
				DATE_ENDING	:= P_HIGH_LEVEL_CR.[DATE_ENDING];
				::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
				::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			end if;
			
			if P_HIGH_LEVEL_CR.[INVOICE] or P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] then
				if P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] and need_copyPrcSch_for_tranches(V_CR_CLASS) then
					-- BFS00028471 Установлена настройка "Создавать копии процентных схем для траншей"
					for	(	select	comiss_arr_rec	(comiss_arr_rec.[PRC_SCHEME] : PRC_SCHEME
													, comiss_arr_rec.[PRIORITY]	: PRIORITY
													, comiss_arr_rec.[DEBT] : DEBT
													, comiss_arr_rec.[IMPORTANCE] : IMPORTANCE
													)
							in P_HIGH_LEVEL_CR.[COMISS_ARR]
							where	comiss_arr_rec.[PRC_SCHEME] is not null
									and	comiss_arr_rec.[DEBT] is not null
									and	(	comiss_arr_rec.[DEBT].[TYPE_CALC_DEBT] is null
										or	comiss_arr_rec.[DEBT].[TYPE_CALC_DEBT] != &HL
										)
						)
					loop
						-- Будем создавать копию схемы (с установкой признака индивидуального использования)
						copy_prc_sch_for_tranche(comiss_arr_rec.PRC_SCHEME
												, comiss_arr_rec.DEBT
												, comiss_arr_rec.PRIORITY
												, greatest(Oper_Day, DATE_BEGIN)
												, this.[COMISS_ARR]
												, V_CREDIT_ARR
												, V_PRC_RATE
												, this
												, comiss_arr_rec.IMPORTANCE);
					end loop;
				else	-- Настройка "Создавать копии процентных схем для траншей" не установлена
					declare
						Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
					begin
						rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR],
														::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(P_HIGH_LEVEL_CR.[COMISS_ARR], Scheme_Name),
														Scheme_Name);
								
						::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme_R('НЕУЧТЕН_ПРОЦЕНТЫ',
														V_PRC_RATE,
														rScheme,
														V_CREDIT_ARR,
														this,
														DATE_BEGIN,
														greatest(Oper_Day, DATE_BEGIN),
														V_ANNUITET,
														V_ONE_DAY,
														FT_CREDIT);
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
					end;					
				end if;

				[CSMD].Disable(V_DEST_STR, 'V_CREDIT_ARR', 'V');
			end if;
			DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar);--DATE_BEGIN + PERIOD;
			::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
		end if;
		
		::[PR_CRED].[GET_CONTROL_VAL].Flush;
		P_FOR_OPEN_YEAR = P_FOR_OPEN_BOOL := nvl(::[PR_CRED].[GET_BOOL_TUNING]('ПЛ_ЗА_ЛИМИТ_В_ПРЦ_ГОДОВЫХ'), false);

		V_ADD_CLASS := null;
		pragma IF_DEF (FACTORING);
			if ::[CRED_INTERFACE].[PRX_FACTORING].Get_v_redeem_unit_arr is not null or
				::[CRED_INTERFACE].[PRX_FACTORING].IsCredBuySale (P_HIGH_LEVEL_CR)
			then
				V_ADD_CLASS := 'FACTORING';
			end if;
		pragma END_IF;
		
		if V_CR_CLASS = 'OVERDRAFTS' and V_ADD_CLASS is null then
			V_ADD_CLASS := 'OVERDRAFTS';
		end if;

		if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then
			rPsOrg := CLIENT->([CL_CORP])[FORMA].[PS];
		else
			rPsOrg := null;
		end if;
		
		validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, false, V_DEST_STR, true);
		
		if V_INVOICE then	-- BFS00027595
			V_DATE_ENDING_MAX := null;
			[DATE_ENDING_MAX] := null;
		end if;
		validate_invoice(V_INVOICE, V_DEST_STR, V_CR_CLASS);
		
		kind_cred := P_KIND_CREDIT;
		if not kind_cred.[WAY_CRED] is null then
			P_OPER_WAY_OUT := kind_cred.[WAY_CRED];
		end if;
					
		V_WAY_OUT_CODE := validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		V_DATE_ENDING_MAX := get_date_ending_max(kind_cred, V_CR_CLASS, V_DATE_GIVE, DATE_BEGIN, sCalendar);

		[INVOICE] 		:= V_INVOICE;
		[FT_CREDIT] 	:= FT_CREDIT;
		[SUMMA_DOG] 	:= SUMMA;
		[LIMIT_SALDO] 	:= V_LIMIT_SALDO;
		[DATE_BEGIN] 	:= DATE_BEGIN;
		[DATE_GIVE] 	:= V_DATE_GIVE;
		[DATE_ENDING]	:= DATE_ENDING;
		[CLIENT]		:= CLIENT;
		
		P_CALC_TYPE			:= kind_cred.[CALC_TYPE];
		V_IS_FOR_CRED_CARD 	:= kind_cred.[IS_FOR_CRED_CARD];
		V_OPEN_DEP			:= false;
		
		if kind_cred.[PRC_DEP_SCHEME]%size(0) > 0 then
			[CSMD].Show(V_DEST_STR, 'V_PRC_DEP_TURN_ACC_LIST', 'V');
			[CSMD].Show(V_DEST_STR, 'V_PRC_DEP_TURN_PRC_DEP_SCHEME', 'V');
			V_PRC_DEP_TURN_PRC_DEP_SCHEME%delete;

			var dep [PRC_DEP_TURN];
			for x in kind_cred.[PRC_DEP_SCHEME] loop
				--v-- BS00133979 Не копируем схему зависимостей для процентной схемы, если для этой задолженности задано правило
				declare
					bFind boolean;
				begin
					bFind := false;
					for
					(
						select r(null)
						in ::[FL_RATE_RELATION] all
						where r.[PRODUCT] = this
						and r.[DEBT] = x.[DEBT]
						and rownum = 1
					)
					loop
						bFind := true;
						[CSMD].MessageBox(V_DEST_STR, 'Невозможно скопировать схему зависимости с Вида кредита', 'Для задолженности '||substr(x.[DEBT].[CODE],1,50)||' уже задано правило расчета ставки');
						exit;
					end loop;	

					if not bFind then	
						dep := x;
						dep.[LAST_VALUE] := null;
						insert dep into V_PRC_DEP_TURN_PRC_DEP_SCHEME;
					end if;
				end;
				--^-- BS00133979
			end loop;

		else
			V_PRC_DEP_TURN_PRC_DEP_SCHEME%delete;
			[CSMD].Hide(V_DEST_STR, 'V_PRC_DEP_TURN_ACC_LIST', 'V');
			[CSMD].Hide(V_DEST_STR, 'V_PRC_DEP_TURN_PRC_DEP_SCHEME', 'V');
		end if;
		
		Fill_COMISS_ARR(this.[COMISS_ARR], kind_cred.[COMISS_ARR], P_DEPART);
		FillComissTable (this.[COMISS_ARR], V_COMISS_TBL);
		FillPrcTable (this.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, false, this, P_KIND_CREDIT, vUseFLRule);
		
		-- Настройка по сдвигу гашений
		nShift_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_FIRST_PLAN', this%class, this.[DEPART],
			null, null, kind_cred%id).[NUMBER_VALUE];
		nAdd_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_PLAN_CRED', this%class, this.[DEPART],
			null, null, kind_cred%id).[NUMBER_VALUE];

		V_SCHM_CHANGE := null; -- запрос пользователю на вариант обновления схем не делали
		if (this%class in ('KRED_CORP', 'KRED_PERS') and P_KIND_CREDIT.[REG_RULES].[PS] is not null) or
			(nvl(V_INVOICE, false)) or
			(this%class = 'OVERDRAFTS' and P_KIND_CREDIT.[REG_RULES] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and P_KIND_CREDIT.[LINE_TRANSH] is not null)
		then
			[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = true');
		else
			[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = false');
		end if;

		-- Возможность выбрать филиал со счетами доходов/расходов для урегулирования резерва
		Check_Res_Filial(This);	-- BS00140713
		
		if P_TURNOVER.UNIT_INTERVALS = ::[UNITS_OF_TIME]([CODE] = 'D') then
			[CSMD].Enable(V_DEST_STR, 'P_TURNOVER_WD');
		else
			[CSMD].Disable(V_DEST_STR, 'P_TURNOVER_WD');
			P_TURNOVER_WD := false;
		end if;

		if P_PERIOD_UNIT = ::[UNITS_OF_TIME]([CODE] = 'D') then
			[CSMD].Enable(V_DEST_STR, 'P_PERIOD_WD');
		else
			[CSMD].Disable(V_DEST_STR, 'P_PERIOD_WD');
			P_PERIOD_WD := false;
		end if;

		if V_CR_CLASS = 'OVERDRAFTS' then
			[CSMD].Disable(V_DEST_STR, 'V_DATE_ENDING_MAX', 'V');
			
			--при вызове через plpcall данная валидация выполнится позднее
			if nvl(p_info, 'null') != '%PLPCALL%' then
				V_DEST_STR := V_DEST_STR || NL$ || ' Call Form1.ScriptServerValidate(Nothing, "TYPE_PROJECT_DEFAULT")';
			end if;
		end if;
		
		balloon_validate;
		
		-- определим профиль гашения
		v_distr_profile := get_profile(this%id, nvl(DATE_BEGIN, Oper_Day), P_KIND_CREDIT);
		
		InitFactorTune(This);
		
		--конструктор планирования
		V_USE_PLAN_RULE := null;
		::[PR_CRED].[NEW_DOG_LIB].validateUsePlanRule(V_USE_PLAN_RULE, V_DEST_STR);
		if not ::[PR_CRED].[LIB_SERVICE].check_app('1B290078') then
			[CSMD].Disable(V_DEST_STR, 'V_USE_PLAN_RULE', 'V');	
		end if;
		
		--@@@
		--данная переменная не нужна!!!
		V_P4P_PLAN_RULE := this.[PARAM_FOR_PLAN];
		bRebuildPlanRule := false;
		
		--@@@
		--валидацию для КВУ
		V_PL_CRED := nvl(P_HIGH_LEVEL_CR%id, this%id);
		
		--пересчета не было
		bRecalcOnChangeLimit := false;
		
		g_needDropPoint := false;
		g_clickBtnRule := false;
		g_clickBtnSeason := false;
		
		--заполним подразделения для выбора вида кредита
		::[PR_CRED].[EDIT_LAST].set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);
		
		if (P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false)) and P_KIND_CREDIT is not null then
			get_calc_vertion (this, P_KIND_CREDIT, DATE_BEGIN, DATE_ENDING);
		end if;

	end if;

-- VALIDATE
	if P_MESSAGE = 'VALIDATE' then
		V_DEST_STR := null;

		if p_info = 'CHANGE_PRC_ARR' then
			--Обработка события, которое будет сгенерировано через таймер после добавления массива процентных ставок
			::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(	 'A'
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR]
														,this
														,DATE_BEGIN
														,greatest(Oper_Day,DATE_BEGIN)
														,V_ANNUITET
														,V_ONE_DAY
														,FT_CREDIT);	-- BS00133030
			V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day );
			-- обновить на форме
			if V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_CREDIT_ARR	:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR];
				V_PRC_RATE		:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC];
				V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
			end if;
		end if;

		--пересчет конструктора планирования выполняется при валидации следующих контролов. Или при валидации на вкладке "Планирование"
		if p_info in ('P_KIND_CREDIT', '%VAR%.P_HIGH_LEVEL_CR', '%VAR%.V_PRJ_KIND_CRED', 'Умолчания', '%VAR%.V_USE_PLAN_RULE') then
			bRebuildPlanRule := true;
		end if;
				
		if p_info = '%PLPCALL%' then
			declare
				rVidDebtCalcPrc 	ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				rPrcScheme 			ref [PRC_SCHEME];
				sInfoTmp			varchar2(2000) := 'P_KIND_CREDIT';
			begin
				--если позвали по PLPCALL из тарифной подсистемы, то необходимо сделать недоступными контролы, значения по которым были переданы
				&debug('P_CO_PROD '||P_CO_PROD%id, 0)
				if not P_CO_PROD is null then
					stdio.put_line_buf('Выполняется открытие кредитного договора из комплексного договора '||P_CO_PROD.[NUM_DOG]||'. Часть реквизитов будет недоступно для заполнения.');
					
					--подписывать и открывать счета будем при подписании комплексного договора
					P_SIGN_UP := false;
					P_OPEN_ACC := false;
					P_DEF_IND := false;
					[CSMD].Command(V_DEST_STR, 'Check6.Enabled = false');
					[CSMD].Command(V_DEST_STR, 'Check7.Enabled = false');
					[CSMD].Command(V_DEST_STR, 'Check18.Enabled = false');
					
					--если передали вид кредита, то выполняем полную валидацию по нему
					if not P_KIND_CREDIT is null then
						V_COPY_HL_PP := false;
						[CSMD].Command(V_DEST_STR, 'Factoring.Enabled = true');
						
						--вызываем в режиме смены вида кредита. Вызов взамен default валидации с вызовом 'TYPE_PROJECT_DEFAULT'
						set_kind_kred(sInfoTmp, V_PRJ_KIND_CRED, P_KIND_CREDIT, DATE_BEGIN, P_SIGN_UP, P_OPEN_ACC, this, P_DEF_IND);			
	
						-- С целью исключения изменений в процентной схеме, "принадлежащей" другому виду кредита
						rPrcScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], rVidDebtCalcPrc);
						if not V_CREDIT_ARR is null or not rPrcScheme is null then
							for
							(
								select kindCredit(1)
								in ::[KIND_CREDITS]
								, (::[DEBT_COMISS_PRC] all : comissPrc)
								, (::[PRC_SCHEME] all : prcScheme)
								all
								where (P_KIND_CREDIT is null or kindCredit != P_KIND_CREDIT)
									and kindCredit.[COMISS_ARR] = comissPrc%collection
									and comissPrc.[PRC_SCHEME] = prcScheme
									and (rPrcScheme = prcScheme or prcScheme.[list_sch_prc] = V_CREDIT_ARR)
							)
							loop
								::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, rVidDebtCalcPrc);
								V_CREDIT_ARR := null;
								V_PRC_RATE := null;
								exit;
							end loop;
						end if;
						
						bCopyMPTune := null;
						
						on_change_kind_credit (this,
												P_KIND_CREDIT,
												P_CALENDAR_NAME,
												DATE_BEGIN,
												DATE_ENDING,
												DECL_ON_CRED_REF,
												DIC_TYPE_CRED,
												FT_CREDIT,
												NUM_DOG,
												PERIOD,
												P_CALC_TYPE,
												P_DEPART,
												P_FOR_OPEN_YEAR,
												P_HIGH_LEVEL_CR,
												P_OPER_WAY_OUT,
												P_OVD_ACCOUNT,
												P_PERIOD_UNIT,
												P_PRODUCT,
												V_COMISS_TBL,
												V_CREDIT_ARR,
												V_CR_CLASS,
												V_DATE_ENDING_MAX,
												V_DATE_GIVE,
												V_DEST_STR,
												V_EARLY_PAY,
												V_GEN_AGR,
												V_INVOICE,
												V_IS_FOR_CRED_CARD,
												V_OPEN_DEP,
												V_PRC_ADD,
												V_PRC_RATE,
												V_PRC_SCH_TBL,
												V_PRJ_KIND_CRED,
												V_SCHM_CHANGE,
												V_WAY_OUT_CODE,
												P_PERIOD_WD,
												SUMMA,
												(P_CO_PROD is null));
						
						if (P_HIGH_LEVEL_CR is null or P_HIGH_LEVEL_CR.[INVOICE]) and not P_KIND_CREDIT is null then
							get_calc_vertion(this, P_KIND_CREDIT, DATE_BEGIN, DATE_ENDING);
						else
							delete_calc_version(this);
						end if;
						
						if P_FILIAL is null then
							Oper_Day := ::[SYSTEM].[VARIABLES].Br2OpDate(::[SYSTEM].[VARIABLES].OurBranch%id);
						else
							Oper_Day := ::[SYSTEM].[VARIABLES].Br2OpDate(P_FILIAL%id);
						end if;
						
						this.[FILIAL] := P_FILIAL;
						this.[DEPART] := P_DEPART;
						this.[FT_CREDIT] := FT_CREDIT;
						this.[KIND_CREDIT] := P_KIND_CREDIT;
						this.[CLIENT] := CLIENT;
						this.[DATE_GIVE] := DATE_GIVE;
						this.[DATE_BEGIN] := DATE_BEGIN;
						this.[DATE_ENDING] := DATE_ENDING;
						
						pragma set_this;
						
						P_LOAN_PORT := get_port(this);
						Check_Res_Filial(This);
						
						if V_INVOICE
							or (this%class in ('KRED_CORP', 'KRED_PERS') and not P_KIND_CREDIT.[REG_RULES].[PS] is null)
							or (this%class = 'OVERDRAFTS' and P_KIND_CREDIT.[REG_RULES] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and not P_KIND_CREDIT.[LINE_TRANSH] is null)
						then
							[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = true');
						else
							[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = false');
						end if;
						
						v_distr_profile := get_profile(this%id, coalesce(DATE_BEGIN, Oper_Day), P_KIND_CREDIT);
						
						bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
						if (not P_KIND_CREDIT.[MOP_TYPE] is null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
							[CSMD].COMMAND(V_DEST_STR, 'FrameMOP.Visible = true');
							P_MOP_TYPE := P_KIND_CREDIT.[MOP_TYPE];
						else
							[CSMD].COMMAND(V_DEST_STR, 'FrameMOP.Visible = false');
							P_MOP_TYPE := null;
						end if;
					end if;
				end if;
			end;
		end if;
		
		if p_info = 'P_FILIAL' then
			-- Читаем дату Oper_Day ДО того, как будем ее применять ниже --
			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
			P_DEPART := null; --если поменялся филиал, то обнулить подразделение
			::[PR_CRED].[EDIT_LAST].set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);
		end if;
	
		if p_info = 'P_FILIAL' or p_info like '%V_CLIENT_REQ%' then
			if P_FILIAL != V_CLIENT_REQ.[1].[2].[FILIAL] then
				[CSMD].Command(V_DEST_STR, 'label35.Caption = "Расчетный счет открыт в филиале ' || V_CLIENT_REQ.[1].[2].[FILIAL].[CODE] || '"');
				[CSMD].Command(V_DEST_STR, 'label35.Visible = true');
			else
				[CSMD].Command(V_DEST_STR, 'label35.Visible = false');
			end if;
		end if;
		
		if p_info = 'P_TURNOVER.UNIT_INTERVALS' then
			if P_TURNOVER.UNIT_INTERVALS = ::[UNITS_OF_TIME]([CODE]='D') then
				[CSMD].Enable(V_DEST_STR, 'P_TURNOVER_WD');
			else
				[CSMD].Disable(V_DEST_STR, 'P_TURNOVER_WD');
				P_TURNOVER_WD := false;
			end if;
		elsif p_info = 'P_TURNOVER_WD' then
			if P_TURNOVER_WD then
				P_TURNOVER.UNIT_INTERVALS := ::[UNITS_OF_TIME]([CODE]='D');
			end if;
		end if;
		
		-- необходимость выбрать вариант изменения %% схем если сменили вид кредита, вид проекта, КВУ
		if p_info in ('P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED', '%VAR%.P_HIGH_LEVEL_CR') and not P_HIGH_LEVEL_CR is null then

			V_DO_FACTORING := coalesce(::[PROPERTY_PROD].[LIB].GetPropVal(coalesce(P_HIGH_LEVEL_CR, this), greatest(Oper_Day, coalesce(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING')), true);
			
			if P_HIGH_LEVEL_CR is not null then
				[CSMD].Command(V_DEST_STR, 'Factoring.Enabled = false');
			else
				[CSMD].Command(V_DEST_STR, 'Factoring.Enabled = true');
			end if;
			
			if ((p_info = '%VAR%.P_HIGH_LEVEL_CR' and P_KIND_CREDIT != nvl(P_HIGH_LEVEL_CR.[KIND_CREDIT].[LINE_TRANSH], P_KIND_CREDIT))
				or (p_info ='P_KIND_CREDIT' and P_KIND_CREDIT is not null)
				or (p_info ='%VAR%.V_PRJ_KIND_CRED' and V_PRJ_KIND_CRED.[CRED] is not null)
				) and [COMISS_ARR]%size(1) > 0
			then
			 	-- выдадим запрос через клиент-скрипт и отправим результат окна в сервер-валидатор
				V_DEST_STR := V_DEST_STR || NL$ ||'Call Form1.ScriptServerValidate(Nothing, "SCHM_" & Form1.ScriptPlayEx("<% PLPCALL [PR_CRED].[SCHM_CHANGE_VAR](P_SELECT => %VAR%.V_SCHM_CHANGE) %>"))';
				v_old_info := p_info; -- запомнил что изменял пользователь
				p_info := null; -- отменяем все валидации до ответа пользователя
			end if;
		end if;

		if p_info like 'SCHM_%' then -- результат окна запроса (0 - закрыл/1 - нажал ОК)
			if substr(p_info, 6, 1) = '0' then -- пользователь закрыл запрос или нажал отмену
				P_KIND_CREDIT := v_old_kind;
			else
				-- возвращаем валидацию которая была до запроса пользователю
				-- результат выбора пользователя через in out V_SCHM_CHANGE
				p_info := v_old_info;
				v_old_info := null;
			end if;
			v_old_kind := P_KIND_CREDIT;
		end if;
	
		if p_info in ('DATE_BEGIN', 'P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED','%VAR%.P_SIGN_UP','%VAR%.P_OPEN_ACC','P_DEF_IND') then
			declare
				bKindCred_change boolean;
				bPrjKindCred_change boolean;
				kindCred_before_skk P_KIND_CREDIT%type;
			begin
				if P_INFO = 'P_KIND_CREDIT' then
					bKindCred_change := true;
				else
					bKindCred_change := false;
				end if;
				if P_INFO = '%VAR%.V_PRJ_KIND_CRED' then
					bPrjKindCred_change := true;
					[PRJ_KIND_CRED] := V_PRJ_KIND_CRED;
				else
					bPrjKindCred_change := false;
				end if;
				kindCred_before_skk := P_KIND_CREDIT;

				set_kind_kred(p_info,v_prj_kind_cred,p_kind_credit, DATE_BEGIN, P_SIGN_UP, P_OPEN_ACC, this, P_DEF_IND);
	
				if (P_INFO = 'P_KIND_CREDIT' or P_INFO = '%VAR%.V_PRJ_KIND_CRED') then
					if (kindCred_before_skk is null and P_KIND_CREDIT is null) or (kindCred_before_skk = P_KIND_CREDIT) then
						null;	-- BFS00027399 Если вид кредита не изменился, путь выдачи не изменяем
					elsif not(P_KIND_CREDIT is null) then
						-- BFS00027399 Если в виде кредита указан путь выдачи, то устанавливаем этот путь выдачи
						b_Kind_Cred_Changed := true;
					end if;
				end if;

				if bKindCred_change OR (bPrjKindCred_change AND kindCred_before_skk <> P_KIND_CREDIT) then
						-- С целью исключения изменений в процентной схеме, "принадлежащей" другому виду кредита

					declare
						Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
						psPRC__CREDIT ref [PRC_SCHEME];
					begin
						psPRC__CREDIT := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
						if V_CREDIT_ARR is not null OR psPRC__CREDIT is not null then
								for	( select vk(vk) in ::[KIND_CREDITS],(::[DEBT_COMISS_PRC] all : pss),(::[PRC_SCHEME] all : ps) all
										where (P_KIND_CREDIT is null OR vk <> P_KIND_CREDIT)
										and vk.[COMISS_ARR] = pss%collection
										and pss.[PRC_SCHEME] = ps
										and (psPRC__CREDIT = ps OR ps.[list_sch_prc] = V_CREDIT_ARR)
								)
								loop
									::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
									V_CREDIT_ARR := null;
									V_PRC_RATE := null;
									exit;
								end loop;
						end if;
						
					end;
				end if;
				if b_Kind_Cred_Changed then
					on_change_kind_credit (
						this,
						P_KIND_CREDIT,
						P_CALENDAR_NAME,
						DATE_BEGIN,
						DATE_ENDING,
						DECL_ON_CRED_REF,
						DIC_TYPE_CRED,
						FT_CREDIT,
						NUM_DOG,
						PERIOD,
						P_CALC_TYPE,
						P_DEPART,
						P_FOR_OPEN_YEAR,
						P_HIGH_LEVEL_CR,
						P_OPER_WAY_OUT,
						P_OVD_ACCOUNT,
						P_PERIOD_UNIT,
						P_PRODUCT,
						V_COMISS_TBL,
						V_CREDIT_ARR,
						V_CR_CLASS,
						V_DATE_ENDING_MAX,
						V_DATE_GIVE,
						V_DEST_STR,
						V_EARLY_PAY,
						V_GEN_AGR,
						V_INVOICE,
						V_IS_FOR_CRED_CARD,
						V_OPEN_DEP,
						V_PRC_ADD,
						V_PRC_RATE,
						V_PRC_SCH_TBL,
						V_PRJ_KIND_CRED,
						V_SCHM_CHANGE,
						V_WAY_OUT_CODE,
						P_PERIOD_WD,
						SUMMA,
						(P_CO_PROD is null));
				end if;
			end;
			
		end if;

		if	P_INFO = 'FT_CREDIT' then
			[FT_CREDIT] := FT_CREDIT;
		 	if P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] then
				get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], P_HIGH_LEVEL_CR.[FT_CREDIT], DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, true);
	 		end if;

			if nvl( V_EARLY_PAY.[USE_PRIVATE], false ) and nvl(::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY'), false) then
				begin
					V_EARLY_PAY.[DELETE#AUTO];
				exception when others then null;
				end;
			end if;
			v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);
			V_EARLY_PAY := ::[PR_CRED].[NEW_DOG_LIB].MakeEarlyPeny( nvl(DECL_ON_CRED_REF.[EARLY_PAY], v_kind_early), 'по договору № '||NUM_DOG );	 		
		end if;
		
		if p_info = '%THIS%.TO_BKI' then -- <Akil> -- разрешение на предоставление информации в БКИ
			V_TO_BKI := into_bki(this, Oper_Day);
		end if;

		if p_info = 'SAVE_RATE_TBL_YES' and V_PRC_SCH_TBL_IDX > 0 then -- пользователь подтвердил сохранение ставки из грида
			if ::[PROL_CONTRACT].[LIB_FIND_REF].is_exists_scheme_in_tp(V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]) then	
				stdio.put_line_buf('Схема начисления процентов сформирована автоматически. Ручное редактирование запрещено!');
				V_PRC_RATE = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC] = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE]	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF] , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
				return;
			end if;
			if V_CAN_PRC_SCH = 2 then
				--выбрали копирование схемы
				::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[DEBT]);
				V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF] := null;
				V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR] := null;
			end if;

			::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(	 'R'
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR]
														,this
														,DATE_BEGIN
														,greatest(Oper_Day,DATE_BEGIN)
														,V_ANNUITET
														,V_ONE_DAY
														,FT_CREDIT);
															
			V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day );
			
			if V_CAN_PRC_SCH = 2 then
				::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[DEBT]);
			end if;
				
			-- обновить на форме
			if V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_CREDIT_ARR	:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR];
				V_PRC_RATE		:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC];
				V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
			end if;

		end if;
		
		if p_info = 'SAVE_RATE_TBL_NO' then
			-- вернуть ставку на форму
			if V_PRC_SCH_TBL_IDX>0 and V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_PRC_RATE = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC] = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE]	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
			end if;
		end if;		
				
		-- процентные схемы/ставки/истории ставок
		if p_info like '%VAR%.V_PRC_SCH_TBL.%[%]' then
			i := GetIndexPrc(p_info, sField);
			V_PRC_SCH_TBL_IDX := i; --сохраним индекс изменяемой строки, для последующей обработки в SAVE_RATE_TBL_YES

			if i is not null then
				if sField = 'PRC_REF' then		-- процентная схема
					if V_PRC_SCH_TBL(i).[PRC_REF] is not null then	-- прописать
						rScheme := V_PRC_SCH_TBL(i).[PRC_REF];
						V_PRC_SCH_TBL(i).[PRC]		:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, Oper_Day, 0, 0, false, false );
						V_PRC_SCH_TBL(i).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, Oper_Day );
						V_PRC_SCH_TBL(i).[PRC_ARR]	:= rScheme.[LIST_SCH_PRC];
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, V_PRC_SCH_TBL(i).[DEBT]);

					elsif V_PRC_SCH_TBL(i).[PRC_REF] is null then	-- очистить
						V_PRC_SCH_TBL(i).[PRC]		:= null;
						V_PRC_SCH_TBL(i).[PRC_ARR]	:= null;
						V_PRC_SCH_TBL(i).[RES_RATE] := null;
						V_PRC_SCH_TBL(i).[STOP_CALC] := null;
						-- После удаления схемы всегда позволяем на первой закладки редактировать ставку
						-- Сделано для траншей, для которых этот контрол блокируется
						[CSMD].Enable(V_DEST_STR, 'V_PRC_RATE','V');
					end if;
					
					--v-- BS00133979. При изменении в гриде процентной схемы обновляем тип ставки, если осуществляется работа с правилами					
					if vUseFLRule then
						V_PRC_SCH_TBL(i).[FL_RULE_TYPE] :=	get_RateType(this, V_PRC_SCH_TBL(i).[DEBT], V_PRC_SCH_TBL(i).[PRC_REF], Oper_Day);
					end if;
					--^-- BS00133979
					
				elsif sField = 'PRC' then					-- процентная ставка
					--Сначала сработает серверный валидатор и установит значение V_CAN_PRC_SCH
					--Потом клиентский, в котором задаем вопрос пользователю, что делать со схемой
					--Затем снова серверный SAVE_RATE_TBL_YES, где уже сохранение ставки
					V_CAN_PRC_SCH := 9;
					if V_PRC_SCH_TBL(i).[PRC_REF] is not null then
						--проверка на общую схему
						for	(	select	comisar('1')
								in ::[DEBT_COMISS_PRC] collections
								where	comisar%collection != this.[COMISS_ARR]
										and comisar.[PRC_SCHEME] = V_PRC_SCH_TBL(i).[PRC_REF]
							)
						loop
							--Проверим права пользователя на операцию PRC_SCH_ACCESS
							if ::[RUNTIME].[SECURITY].Is_Method_Accessible('PRC_SCHEME', 'PRC_SCH_ACCESS', [stdlib].userid.[USERNAME]) then
								--есть права, предоставим выбор что сделать со ставкой
								V_CAN_PRC_SCH := 1;
							else
								V_CAN_PRC_SCH := 0;
							end if;
							exit;
						end loop;
					end if;

					-- если можно изменять, то проверим что придется изменять простую ставку или сложную ставку с простыми процентами
					if V_PRC_SCH_TBL(i).[PRC_ARR] is not null and V_CAN_PRC_SCH <> 0 then
						declare
							oArcSchPrc	[ARC_SCH_PRC];
						begin
							oArcSchPrc := ::[PR_CRED].[NEW_DOG_LIB].getCurrentArcPrc(V_PRC_SCH_TBL(i).[PRC_ARR], nvl(DATE_BEGIN, Oper_Day));
							if not nvl(oArcSchPrc.[L_SIMPLE_PRC], false) then
								V_CAN_PRC_SCH := 2;
							end if;
						end;
					end if;
					
				elsif sField = 'PRC_ARR' then				-- история ставок
					--Добавить генерацию события CHANGE_PRC_ARR через таймер, чтобы ИД массива процентных ставок успело записаться в ячейку грида
					[CSMD].Command(V_DEST_STR, 'Form1.SetTimer 1, 500');

				elsif sField = 'STOP_CALC' then		-- существенность
					-- Менять существенность можно только для затрат/комиссий по которым заданы процентные схемы
					if	V_PRC_SCH_TBL(i).[PRC_REF] is null or coalesce(V_PRC_SCH_TBL(i).[DEBT].[TYPE_DEBT], -1) not in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC) then
						V_PRC_SCH_TBL(i).[STOP_CALC] := null;
					end if;
				end if;
				-- обновить на форме
				if V_PRC_SCH_TBL(i).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
					V_CREDIT_ARR	:= V_PRC_SCH_TBL(i).[PRC_ARR];
					V_PRC_RATE		:= V_PRC_SCH_TBL(i).[PRC];
					V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(i).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
				end if;

				::[RUNTIME].[CSMD].Command(V_DEST_STR, 'Call CheckCalcImpPrc()');
			end if;
		end if;
		
		if P_INFO in ('CLIENT', 'OK') then
			-- контроль операций по клиентам-банкротам
			::[CR_B_CHECK_TUNE].[LIB].checkCredClient
					( p_client		== CLIENT
					, p_date		== ::[SYSTEM].[VARIABLES].Br2OpDate(coalesce(P_FILIAL%id, this.[FILIAL], ::[SYSTEM].[VARIABLES].OurBranch%id))
					, p_product		== this
					, p_num_dog		== coalesce(NUM_DOG, this.[NUM_DOG])
					, p_oper_class	== &METHOD$CLASS
					, p_oper_code	== &METHOD$SNAME
					, p_oper_step	== P_INFO
					, p_cred_class	== this%class
					, p_sVBScript	== V_DEST_STR
			);
		end if;

		if P_INFO = 'CLIENT' then
		
	 		if V_CR_CLASS = 'OVERDRAFTS' and CLIENT is not null and CLIENT%class != 'CL_PRIV' then
				V_OPEN_DEP := false;
	 			[CSMD].Disable(V_DEST_STR, 'V_OPEN_DEP', 'V');
				[CSMD].Enable (V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Enable (V_DEST_STR, 'P_PRODUCT');
	 		else
	 			[CSMD].Enable(V_DEST_STR, 'V_OPEN_DEP', 'V');
	 		end if;
	 		
		end if;

	 	if	P_INFO in ('CLIENT', 'FT_CREDIT') and not (CLIENT is null) then
	 		
			[CLIENT] := CLIENT;
			
			::[PR_CRED].[GET_CONTROL_VAL].Flush;
		 	if CLIENT.[REGISTR_NUM] is null and nvl(this.GET_BOOL_TUNING('КОНТРОЛЬ_РЕГ_НОМЕРА'),false) then
				pragma error ('Укажите регистрационный номер клиента ');
	 		end if;
	 		
	 		for (select x(x.[OKONH] : okonh) in CLIENT.[OKONH_IN_PERIOD] where
				(x.[DATE_BEGIN] is null or DATE_BEGIN is null or x.[DATE_BEGIN] <= DATE_BEGIN)
				and (x.[DATE_END] is null or DATE_BEGIN is null or x.[DATE_END] > DATE_BEGIN)
 				and rownum < 2)
			loop
				V_OKONH := x.okonh;
			end loop;
			
			CL_CLASS_NAME	:= [LIB].class_name(CLIENT);
			V_CLIENT_REQ	:= [GET_CUST_PROPS];
			
			-- Class
			if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then rPsOrg := CLIENT->([CL_CORP])[FORMA].[PS]; else rPsOrg := null; end if;
			if not(FT_CREDIT is null) then	-- BFS00027399
				if P_KIND_CREDIT is null or (not(P_KIND_CREDIT is null) and P_KIND_CREDIT.[WAY_CRED] is null) then	-- Путь выдачи в виде кредита не указан - установим его
					if V_CR_CLASS = 'KRED_PERS' and FT_CREDIT = ::[SYSTEM].[VARIABLES].NatCur then
						-- Установим 'Через кассу' (В справочнике может быть указано только одно значение с кодом 02)
						P_OPER_WAY_OUT := get_way('02');
					else
						-- Установим 'Перечислением' (В справочнике может быть указано только одно значение с кодом 01)
						P_OPER_WAY_OUT := get_way('01');
					end if;
				end if;
			end if;
			V_WAY_OUT_CODE := validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);

	 	 	Call_Check_Transh_Acc(This);
		end if;
	 	if p_info in ('P_FOR_OPEN_BOOL', '%VAR%.P_FOR_OPEN_FN', 'FT_CREDIT', 'P_FOR_OPEN_YEAR', 'P_FOR_OPEN_PAY')	then
			presaveThis();
			validate_comis(
				p_nForOpenPay == P_FOR_OPEN_PAY,
				ft_cred == FT_CREDIT,
				bIsDisable == false,
				p_info == p_info,
				p_rCred == this,
				ft_comis == P_FOR_OPEN_FN,
				bool_comis == P_FOR_OPEN_BOOL,
				bool_year == P_FOR_OPEN_YEAR,
				V_VALID == V_DEST_STR,
				p_tCurrComis == V_COMISS_TBL
			);

			V_WAY_OUT_CODE := validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
			if p_info = 'FT_CREDIT' then
				this.[COMISS_ARR]%delete;
				get_def_prc_schemes (P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);
			end if;
 		end if;
 		
 		-- сделаем обработку ответа пользователя до основных обработчиков чтобы не дублировать код
 		-- а подставить нужный p_info
		if p_info = 'SAVE_RATE_YES' then -- пользователь подтвердил сохранение ставки
			bCanSaveRate := true;
		elsif p_info  = 'SAVE_RATE_NO' then
			-- вернуть ставку на форму
			V_PRC_RATE := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
			-- обновить в таблице значение ставки
			if not (V_PRC_SCH_TBL.first is null) then
				for idxprc in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
					where V_PRC_SCH_TBL(idxprc).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
					V_PRC_SCH_TBL(idxprc).[PRC] = V_PRC_SCH_TBL(idxprc).[RES_RATE]		:= V_PRC_RATE;
				end loop;
			end if;
			
		end if;
 		
		if P_INFO = 'P_OPER_WAY_OUT' then
			if P_OPER_WAY_OUT is not null then
				V_WAY_OUT_CODE := validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
			end if;
			
 		elsif P_INFO = 'P_KIND_CREDIT' then
			bCopyMPTune := null;
			on_change_kind_credit (
					this,
					P_KIND_CREDIT,
					P_CALENDAR_NAME,
					DATE_BEGIN,
					DATE_ENDING,
					DECL_ON_CRED_REF,
					DIC_TYPE_CRED,
					FT_CREDIT,
					NUM_DOG,
					PERIOD,
					P_CALC_TYPE,
					P_DEPART,
					P_FOR_OPEN_YEAR,
					P_HIGH_LEVEL_CR,
					P_OPER_WAY_OUT,
					P_OVD_ACCOUNT,
					P_PERIOD_UNIT,
					P_PRODUCT,
					V_COMISS_TBL,
					V_CREDIT_ARR,
					V_CR_CLASS,
					V_DATE_ENDING_MAX,
					V_DATE_GIVE,
					V_DEST_STR,
					V_EARLY_PAY,
					V_GEN_AGR,
					V_INVOICE,
					V_IS_FOR_CRED_CARD,
					V_OPEN_DEP,
					V_PRC_ADD,
					V_PRC_RATE,
					V_PRC_SCH_TBL,
					V_PRJ_KIND_CRED,
					V_SCHM_CHANGE,
					V_WAY_OUT_CODE,
					P_PERIOD_WD,
					SUMMA,
					(P_CO_PROD is null));

			balloon_validate;

		elsif P_INFO like '%.V_PRC_SCH_TBL.FL_RULES[%]' then
			-- Обновим запись по которой редактировались правила в гриде процентных схем
			declare
				vIdx 			pls_integer := to_number(substr(P_INFO,30,length(P_INFO)-30));
				vFindPrcRule	boolean;
				vMessage varchar2(500);
			begin
				-- Если процентная схема задана то не обновляем ее
				
				if V_PRC_SCH_TBL(vIdx).[PRC_REF] is null then
					
					for (select x( x.[PRC_SCHEME] : rSchema
							, x.[FROM_HL_CRED] :sFromHL)
					in this.[COMISS_ARR]
					where x.[DEBT] = V_PRC_SCH_TBL(vIdx).[DEBT])
					loop
						V_PRC_SCH_TBL(vIdx).[PRC_REF]		:= x.rSchema;
						V_PRC_SCH_TBL(vIdx).[PRC_ARR]		:= V_PRC_SCH_TBL(vIdx).[PRC_REF].[LIST_SCH_PRC];
						V_PRC_SCH_TBL(vIdx).[PRC]	 	  	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(vIdx).[PRC_REF], Oper_Day, 0, 0, false, false);
						V_PRC_SCH_TBL(vIdx).[FROM_HL_CRED] 	:= x.sFromHL;
						exit;
					end loop;
				end if;
				
				if V_PRC_SCH_TBL(vIdx).[PRC_REF] is not null then
					if V_PRC_SCH_TBL(vIdx).[DEBT] = ::[VID_DEBT]([CODE] = 'НЕУЧТЕН_ПРОЦЕНТЫ') then
						V_CREDIT_ARR	:= V_PRC_SCH_TBL(vIdx).[PRC_ARR];
						V_PRC_RATE		:= V_PRC_SCH_TBL(vIdx).[PRC];
					end if;
		
					vFindPrcRule := [FL_RATE_RULE].[LIB].FindPrcRule(this, V_PRC_SCH_TBL(vIdx).[DEBT]);
		
					if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR, V_PRC_SCH_TBL(vIdx).[DEBT]) or vFindPrcRule then
						-- Есть правила или вид кредита допускает их использование
					
						-- определим тип ставки
						V_PRC_SCH_TBL(vIdx).[FL_RULE_TYPE] := get_RateType(this, V_PRC_SCH_TBL(vIdx).[DEBT], V_PRC_SCH_TBL(vIdx).[PRC_REF], Oper_Day);
							
						if vFindPrcRule then
							-- правила есть, отображаем массив как (***)
							V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := this%id;
						else
							-- правил нет, отметим массив для обнуления (***)
							V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := '0';
							
							-- проверим если массив был доступен только из-за наличия правил то заблокируем его							
							if not [FL_RATE_RULE].[LIB].Check_UseFLR2ProdDebt(this, V_PRC_SCH_TBL(vIdx).[DEBT], vMessage, V_PRC_SCH_TBL(vIdx).[PRC_REF]) then
								[CSMD].Command(V_DEST_STR, 'Gridcol36.Enabled = false');
							end if;
						end if;
					end if;
				end if;
			end;
			
		elsif P_INFO like 'SET_FLR_CONTEXT%' then
			declare
				vIdx integer := to_number(substr(P_INFO,16));
			begin
				executor.set_context('$FL_RATE$SET$PROD', this%id);
				executor.set_context('$FL_RATE$SET$DEBT', V_PRC_SCH_TBL(vIdx).[DEBT]%id);
				executor.set_context('$FL_RATE$SET$CLCALSS', CLIENT%class);
				executor.set_context('$FL_RATE$SET$SCHEME', V_PRC_SCH_TBL(vIdx).[PRC_REF]%id);

				if V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection = '0' then
					-- обнулим массив (будет отображаться как (...))
					V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := null;
				else
					-- заполним коллекцию для работы с массивом
					V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := this%id;
				end if;
			end;
		elsif P_INFO like 'PRCSCH_ROW_CHANGE%' then
			declare
				vMessage varchar2(1000);
				vIdx integer := to_number(substr(P_INFO,18));
			begin
				[FL_RATE_RULE].[LIB].ProdInit(this, P_KIND_CREDIT);	
				-- Определим доступен ли массив для работы
				if [FL_RATE_RULE].[LIB].Check_UseFLR2ProdDebt(this, V_PRC_SCH_TBL(vIdx).[DEBT], vMessage,  V_PRC_SCH_TBL(vIdx).[PRC_REF]) or [FL_RATE_RULE].[LIB].FindPrcRule(this, V_PRC_SCH_TBL(vIdx).[DEBT]) then
					V_SCHM_FOR_RULE := '1';
				else
					V_SCHM_FOR_RULE := '0';
				end if;
				
				if vMessage is not null then
					-- добавим сообщение для клиент-скрипта
					V_SCHM_FOR_RULE := V_SCHM_FOR_RULE || vMessage;
				end if;
			end;			
		--^-- BS00133979

		elsif  P_INFO like '%VAR%.V_INVOICE_COND.PAY_BEGIN_DATE%'
			or P_INFO like '%VAR%.V_INVOICE_COND.END_DATE%'
			or P_INFO like '%VAR%.V_INVOICE_COND.START_SUMMA%'
			or P_INFO like '%VAR%.V_INVOICE_COND.PLAN_PERCENT%'
		then
			if V_INVOICE_COND.exists(V_INVOICE_IDX) then
				if V_INVOICE_COND(V_INVOICE_IDX).PAY_BEGIN_DATE is null then
					V_INVOICE_COND(V_INVOICE_IDX).PAY_BEGIN_DATE := DATE_BEGIN;
				end if;
				if V_INVOICE_COND(V_INVOICE_IDX).END_DATE is null then
					V_INVOICE_COND(V_INVOICE_IDX).END_DATE := to_date('01/01/4012','dd/mm/yyyy');
				end if;
			end if;

		elsif P_INFO = '%VAR%.V_OPEN_DEP' then
			if nvl(V_OPEN_DEP, false) then
				P_PRODUCT = P_OVD_ACCOUNT := null;
				V_CLIENT_REQ.[0] := 1;
				V_CLIENT_REQ.[1].[1] := null;
				V_CLIENT_REQ.[1].[2] := null;
				[CSMD].Disable(V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Disable(V_DEST_STR, 'P_PRODUCT');
			else
				[CSMD].Enable (V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Enable (V_DEST_STR, 'P_PRODUCT');
			end if;
	 		
	 	elsif P_INFO in ('FT_CREDIT', 'SUMMA', '%VAR%.V_LIMIT_SALDO') then
	 		if V_CR_CLASS = 'OVERDRAFTS' then
	 			V_LIMIT_SALDO := SUMMA;
	 		end if;
			[SUMMA_DOG] := SUMMA;
			[LIMIT_SALDO] := V_LIMIT_SALDO;
			if not SUMMA is null and not FT_CREDIT is null then
				V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(SUMMA, FT_CREDIT.[CUR_SHORT]);
			end if;
			if SUMMA is null then	-- BFS00027399
				V_SUM_STR := null;
			end if;
			
			if nvl([DIC_TYPE_CRED],P_KIND_CREDIT.[REG_RULES]) = &LCONST.TC_CRED_OVER then
				if V_MAX_LIMIT_SALDO is not null and nvl(V_LIMIT_SALDO, SUMMA) > V_MAX_LIMIT_SALDO then
					pragma error('Значение максимального лимита задолженности должно быть больше лимита задолженности');
				end if;
			end if;
			
			if SUMMA < nvl(P_BALLOON_PAYMENT, SUMMA) then
				P_BALLOON_PAYMENT := SUMMA;
			end if;
			bRebuildParam4Plan := true;
			
			presaveThis();
			recalcImportance(V_COMISS_TBL, V_PRC_SCH_TBL, this);
			
		elsif P_INFO in ('P_BALLOON_PAYMENT') then	
			if SUMMA < nvl(P_BALLOON_PAYMENT, SUMMA) then
				P_BALLOON_PAYMENT := SUMMA;
			end if;
			bRebuildParam4Plan := true;
		elsif P_INFO in ('%VAR%.V_MAX_LIMIT_SALDO') then	
			if V_MAX_LIMIT_SALDO is not null and nvl(V_LIMIT_SALDO, SUMMA) > V_MAX_LIMIT_SALDO then
				pragma error('Значение максимального лимита задолженности должно быть больше лимита задолженности');
			end if;
	  	elsif p_info = '%VAR%.DECL_ON_CRED_REF' then

			[COMISS_ARR]%delete;

			::[CRED_INTERFACE].[PRX_DECL_ON_GET].set_from_decl(
				DECL_ON_CRED_REF
				,this
				,FT_CREDIT
				,CLIENT
				,P_KIND_CREDIT
				,P_HIGH_LEVEL_CR
				,SUMMA
				,V_SUM_STR
				,PERIOD
				,V_PRC_RATE
				,P_OBJECTS_CRED
				,V_ANNUITET
				,V_DATE_GIVE
				,DIC_TYPE_CRED
				,DATE_ENDING
				,DATE_BEGIN
				,P_FILIAL
				,P_DEPART
				,P_PERIOD_UNIT
				,fPenMainRate
				,fPenPrcRate
				,P_NUM_CONTR
				,V_EARLY_PAY
				,NUM_DOG
				,P_PERIOD_WD
				,P_BALLOON_PAYMENT);
			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
				
			V_PRJ_KIND_CRED := P_KIND_CREDIT.[TYPE_PROJECT];

			-- заведем схемы по реквизитам заявки
			if not (fPenMainRate is null) then
				declare
					Scheme_Name  ref [VID_DEBT] := &LCONST.VD_CREDIT_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
							'R',
							'ПЕНЯ_КРЕДИТ',
							fPenMainRate,
							rScheme,
							Prc_Arr(Find_Prc_Arr('ПЕНЯ_КРЕДИТ', Prc_Arr)).[Proc_Arr],
							this,
							Oper_Day,
							Oper_Day,
							V_ANNUITET,
							V_ONE_DAY);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;
			if not (fPenPrcRate is null) then
				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_PRC_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
							'R',
							'ПЕНЯ_ПРОЦЕНТЫ',
							fPenPrcRate,
							rScheme,
							Prc_Arr(Find_Prc_Arr('ПЕНЯ_ПРОЦЕНТЫ', Prc_Arr)).[Proc_Arr],
							this,
							Oper_Day,
							Oper_Day,
							V_ANNUITET,
							V_ONE_DAY);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;

			if not (V_PRC_RATE is null) then
				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					if not (P_HIGH_LEVEL_CR is null) then
						rSchemeHLC := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[HIGH_LEVEL_CR].[COMISS_ARR], Scheme_Name);
					end if;
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme_R(
							'НЕУЧТЕН_ПРОЦЕНТЫ',
							V_PRC_RATE,
							rScheme,
							V_CREDIT_ARR,
							this,
							DATE_BEGIN,
							greatest(Oper_Day, DATE_BEGIN),
							V_ANNUITET,
							V_ONE_DAY);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
	
					-- Если у транша и у линии одна процентная схема, то
					-- запретить редактировать ставку на первой закладке
					if not(rSchemeHLC is null) and not(rScheme is null) and rScheme = rSchemeHLC
					then [CSMD].Disable	(V_DEST_STR, 'V_PRC_RATE','V');
					else [CSMD].Enable	(V_DEST_STR, 'V_PRC_RATE','V');
					end if;
	
				end;
			end if;

			-- заполнять с признаком "только новые" чтобы не потереть схемы с заявки
			if P_HIGH_LEVEL_CR is null then
				-- берем всё что есть из вида кредита
				get_def_prc_schemes (P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, null, true);
			else
				-- 1. Копируем с линии
				[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, null, true, true); --контролируем признак "передавать в транш"
				-- 2. добавляем из вида кредита чего не взяли с линии
				[NEW_DOG_N].get_def_prc_schemes (P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, null, true); -- только новые схемы
			end if;

			-- Дополнительные свойства --
			V_PROPERTIES%delete;
			if not nvl(::[HOOK].[CRED_COPY_PROPS](this, DECL_ON_CRED_REF), false) then
				::[PROD_PROPERTY].[L].make_default_properties(V_PROPERTIES, V_CR_CLASS, DATE_BEGIN, P_KIND_CREDIT.[CODE]);
			end if;

			if not(CLIENT is null) and not(FT_CREDIT is null) then
				-- Устанавливаем клиента и валюту по заявке
				[CLIENT] := CLIENT;
				[FT_CREDIT] := FT_CREDIT;
				reqs_cl_tmp := null;
				[CLIENT_REQ] := reqs_cl_tmp;	-- Очищаем реквизиты клиента для расчетов по кредиту
				V_CLIENT_REQ	:= [GET_CUST_PROPS];	-- Получаем реквизиты клиента для расчетов по кредиту
			end if;

			V_DATE_GIVE := DATE_BEGIN;
			kind_cred := P_KIND_CREDIT;
			V_INVOICE := nvl( kind_cred.[INVOICE], false);
			if V_INVOICE then	-- BFS00027595
				V_DATE_ENDING_MAX := null;
				[DATE_ENDING_MAX] := null;
			end if;
			validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR);
			validate_invoice( V_INVOICE, V_DEST_STR, V_CR_CLASS);			
			if not(kind_cred.[WAY_CRED] is null) then
				P_OPER_WAY_OUT := kind_cred.[WAY_CRED];
			end if;
			if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then
				rPsOrg := CLIENT->([CL_CORP])[FORMA].[PS];
			else
				rPsOrg := null; -- BFS00027399
			end if;
			V_WAY_OUT_CODE := validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
			V_DATE_ENDING_MAX := get_date_ending_max(kind_cred,V_CR_CLASS,V_DATE_GIVE,DATE_BEGIN, sCalendar);

			[INVOICE] := V_INVOICE;
			[FT_CREDIT] := FT_CREDIT;
			[SUMMA_DOG] := SUMMA;
			[LIMIT_SALDO] := V_LIMIT_SALDO;
			[DATE_BEGIN] := DATE_BEGIN;
			[DATE_GIVE] := V_DATE_GIVE;
			[DATE_ENDING]	:= DATE_ENDING;
			[CLIENT]	:= CLIENT;
			CALC_NUM_DOG;
			[NUM_DOG]:=NUM_DOG;
			if nvl( V_EARLY_PAY.[USE_PRIVATE], false ) and nvl(::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY'), false) then
				begin
					V_EARLY_PAY.[DELETE#AUTO];
				exception when others then null;
				end;
			end if;
			v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);
			V_EARLY_PAY := ::[PR_CRED].[NEW_DOG_LIB].MakeEarlyPeny( v_kind_early, 'по договору № '||NUM_DOG );
			
			declare
				Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
			begin
				rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
				::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme_R(
						'НЕУЧТЕН_ПРОЦЕНТЫ',
						V_PRC_RATE,
						rScheme,
						V_CREDIT_ARR,
						this,
						DATE_BEGIN,
						greatest(Oper_Day, DATE_BEGIN),
						V_ANNUITET,
						V_ONE_DAY,
						FT_CREDIT);
				::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
			end;
			if fPenMainRate is not null then

				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_CREDIT_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
							'R',
							'ПЕНЯ_КРЕДИТ',
							fPenMainRate,
							rScheme,
							Prc_Arr(Find_Prc_Arr('ПЕНЯ_КРЕДИТ', Prc_Arr)).[Proc_Arr],
							this,
							DATE_BEGIN,
							Oper_Day,
							false,
							false,
							FT_CREDIT);		-- BS00133030
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;
			if fPenPrcRate is not null then
				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_PRC_PENY;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
							'R',
							'ПЕНЯ_ПРОЦЕНТЫ',
							fPenPrcRate,
							rScheme,
							Prc_Arr(Find_Prc_Arr('ПЕНЯ_ПРОЦЕНТЫ', Prc_Arr)).[Proc_Arr],
							this,
							DATE_BEGIN,
							Oper_Day,
							false,
							false,
							FT_CREDIT);		-- BS00133030

					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;
			end if;
			Fill_COMISS_ARR(this.[COMISS_ARR], kind_cred.[COMISS_ARR], P_DEPART);
			FillPrcTable (this.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, false, this, P_KIND_CREDIT, vUseFLRule);
			FillComissTable (this.[COMISS_ARR], V_COMISS_TBL);

			[OBJECTS_CRED] := P_OBJECTS_CRED;
			V_OBJ_CRED := [L_ALEX].get_main_obj(this);
			
			P_LOAN_PORT := get_port(this);
			
			balloon_validate;
			
			--заполним подразделения для выбора вида кредита
			::[PR_CRED].[EDIT_LAST].set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);

	 	elsif	p_info in ('DATE_BEGIN', '%VAR%.V_DATE_GIVE') then
	 		if V_DATE_GIVE < DATE_BEGIN and P_INFO='%VAR%.V_DATE_GIVE' then	-- BFS00027399
	 			pragma error ('Дата выдачи не может быть меньше даты начала действия договора');
	 		end if;
			if p_info = 'DATE_BEGIN' then
				V_DATE_GIVE := DATE_BEGIN;
				[DATE_BEGIN] := DATE_BEGIN;
				
				if P_HIGH_LEVEL_CR is not null then
					-- определим значение свойства на дату начала транша --
					glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																		, DATE_BEGIN
																		, propTRANSH_PERIOD_NUM
																		);
					if glHL_PERIOD_NUM is not null then
						PERIOD := glHL_PERIOD_NUM;
						glHL_PERIOD_UNIT = P_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
						P_PERIOD_WD := false;
					end if;
				end if;
			end if;
			this.[DATE_GIVE] := V_DATE_GIVE;

			for (select rSchemes
						(rSchemes.[PRC_SCHEME]: PRC_SCHEME,
						rSchemes.[DEBT]: DEBT,
						(select hist(min(hist.[DATE_BEG])) in rSchemes.[PRC_SCHEME].[LIST_SCH_PRC]
						) : SCH_DATE_BEGIN)
				in this.[COMISS_ARR]
				where not rSchemes.[PRC_SCHEME] is null)
			loop
				if DATE_BEGIN < nvl(rSchemes.SCH_DATE_BEGIN, DATE_BEGIN + 1) then
					::[PR_CRED].[NEW_DOG_LIB].EditDateBegPrc(
						DATE_BEGIN,
						rSchemes.[PRC_SCHEME],
						Prc_Arr(Find_Prc_Arr(rSchemes.[DEBT].[CODE], Prc_Arr)).[Proc_Arr]);
				end if;
			end loop;
			
	 		if not nvl(V_INVOICE, false) and PERIOD > 0 then
  				DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar);-- V_DATE_GIVE + PERIOD;
  				if P_HIGH_LEVEL_CR is not null then
					DATE_ENDING	:= least(DATE_ENDING, P_HIGH_LEVEL_CR.[DATE_ENDING]);
					::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
  				end if;
  				PR_CRED.[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
	 		end if;
	 		
	 		kind_cred := P_KIND_CREDIT;
	 		V_DATE_ENDING_MAX := get_date_ending_max(kind_cred,V_CR_CLASS,V_DATE_GIVE,DATE_BEGIN,sCalendar);

		 	Call_Check_Transh_Acc(This);
		 	bRebuildParam4Plan := true;
		 	
	  	elsif p_info in ('PERIOD', 'P_PERIOD_UNIT', 'P_PERIOD_WD') then
			if p_info = 'P_PERIOD_UNIT' then
				if P_PERIOD_UNIT = ::[UNITS_OF_TIME]([CODE]='D') then
					[CSMD].Enable(V_DEST_STR, 'P_PERIOD_WD');
				else
					[CSMD].Disable(V_DEST_STR, 'P_PERIOD_WD');
					P_PERIOD_WD := false;
				end if;
			elsif p_info = 'P_PERIOD_WD' then
				if P_PERIOD_WD then
					P_PERIOD_UNIT := ::[UNITS_OF_TIME]([CODE]='D');
				end if;
			end if;

			DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar); --nvl(V_DATE_GIVE, DATE_BEGIN) + PERIOD;
	  		if glHL_PERIOD_NUM is not null then
	  			if DATE_ENDING > P_HIGH_LEVEL_CR.[DATE_ENDING] then
	  				pragma error('Ошибка! Срок транша превышает срок договора верхнего уровня.');
	  			end if;
	  		end if;
	  		::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);

  			Call_Check_Transh_Acc(This);
			bRebuildParam4Plan := true;
			[DATE_ENDING] := DATE_ENDING;
			
	  	elsif p_info = 'DATE_ENDING' then
	  		if glHL_PERIOD_NUM is not null then
	  			if DATE_ENDING > P_HIGH_LEVEL_CR.[DATE_ENDING] then
	  				pragma error('Ошибка! Срок транша превышает срок договора верхнего уровня.');
	  			end if;
	  		end if;

	  		[DATE_ENDING] := DATE_ENDING;
	  		::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, P_CALENDAR_NAME);
	  		::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, V_CALENDAR);
	  		Call_Check_Transh_Acc(This);
			bRebuildParam4Plan := true;
			
	 	elsif p_info = '%VAR%.P_HIGH_LEVEL_CR'	then
			if nvl (P_HIGH_LEVEL_CR.[INVOICE], false) then
				pragma error ('Нельзя открывать транши к линии "До востребования", необходимо запустить операцию "Предъявить к востребованию" на линии.');
			end if;
			
			-- Если изменили КВУ, процентные схемы будут вводиться заново => очищаем реквизиты и переменные, связанные с процентными схемами
			
			V_CREDIT_ARR := null;
			V_PRC_RATE := null;
			
			Check_Res_Filial(This);	-- BS00140713
			
			if P_HIGH_LEVEL_CR is null then
				glHL_PERIOD_NUM = glHL_PERIOD_UNIT := null;
				
			elsif not P_HIGH_LEVEL_CR is null then
	 			if V_GEN_AGR is not null and V_GEN_AGR.[VALUTA] != P_HIGH_LEVEL_CR.[FT_CREDIT] then
	 				pragma error('Валюта договора верхнего уровня не совпадает с валютой ген. соглашения');
	 			end if;
				if P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] then
					DATE_ENDING	:= P_HIGH_LEVEL_CR.[DATE_ENDING];
					::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
				else
					glHL_PERIOD_UNIT:= null;
					glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																		, DATE_BEGIN
																		, propTRANSH_PERIOD_NUM
																		);
					if glHL_PERIOD_NUM is not null then
						PERIOD := glHL_PERIOD_NUM;
						glHL_PERIOD_UNIT = P_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
						P_PERIOD_WD := false;
						DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd(coalesce(V_DATE_GIVE, DATE_BEGIN)
																						,PERIOD
																						,P_PERIOD_UNIT
																						,null
																						,null
																						,P_PERIOD_WD
																						,sCalendar);
						DATE_ENDING	:= least(DATE_ENDING, P_HIGH_LEVEL_CR.[DATE_ENDING]);
						::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
					end if;
				end if;
		 			
			 	FT_CREDIT	:= P_HIGH_LEVEL_CR.[FT_CREDIT];
			 	V_GEN_AGR	:= null;
			 	CLIENT	:= P_HIGH_LEVEL_CR.[CLIENT];
				
			 	P_FILIAL := P_HIGH_LEVEL_CR.[FILIAL];
			 	[FILIAL] := P_FILIAL;
				Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
			 	
			 	V_LIMIT_CR	:= ::[PR_CRED].[L].GetSumDebt(P_HIGH_LEVEL_CR, &LCONST.VD_LIMIT, Oper_Day);
			 	
			 	v_old_info := P_INFO;
			 	P_INFO	:= 'CLIENT';
			 	if P_KIND_CREDIT is null or P_KIND_CREDIT != nvl(P_HIGH_LEVEL_CR.[KIND_CREDIT].[LINE_TRANSH], KindCredits_06) then
					P_KIND_CREDIT	:= nvl(P_HIGH_LEVEL_CR.[KIND_CREDIT].[LINE_TRANSH], KindCredits_06);
					on_change_kind_credit(this
										, P_KIND_CREDIT
										, P_CALENDAR_NAME
										, DATE_BEGIN
										, DATE_ENDING
										, DECL_ON_CRED_REF
										, DIC_TYPE_CRED
										, FT_CREDIT
										, NUM_DOG
										, PERIOD
										, P_CALC_TYPE
										, P_DEPART
										, P_FOR_OPEN_YEAR
										, P_HIGH_LEVEL_CR
										, P_OPER_WAY_OUT
										, P_OVD_ACCOUNT
										, P_PERIOD_UNIT
										, P_PRODUCT
										, V_COMISS_TBL
										, V_CREDIT_ARR
										, V_CR_CLASS
										, V_DATE_ENDING_MAX
										, V_DATE_GIVE
										, V_DEST_STR
										, V_EARLY_PAY
										, V_GEN_AGR
										, V_INVOICE
										, V_IS_FOR_CRED_CARD
										, V_OPEN_DEP
										, V_PRC_ADD
										, V_PRC_RATE
										, V_PRC_SCH_TBL
										, V_PRJ_KIND_CRED
										, V_SCHM_CHANGE
										, V_WAY_OUT_CODE
										, P_PERIOD_WD
										, SUMMA
										, (P_CO_PROD is null));
				end if;
			 	[KIND_CREDIT]	:= P_KIND_CREDIT;
			 	V_PRJ_KIND_CRED := P_KIND_CREDIT.[TYPE_PROJECT];
			 	
			 	DIC_TYPE_CRED	:= &LCONST.TC_CRED_CONT;
			 	
			 	P_DEPART		:= P_HIGH_LEVEL_CR.[DEPART];
			 	[DEPART]		:= P_DEPART;
			 	
			 	P_NUM_CONTR		:= P_HIGH_LEVEL_CR.[NUM_CONTR];
			 	V_OKONH			:= P_HIGH_LEVEL_CR.[OKOHX];
			 	V_CLIENT_REQ	:= P_HIGH_LEVEL_CR.[CLIENT_REQ];
			 				 	
			 	P_CALENDAR_NAME	:= P_HIGH_LEVEL_CR.[CALENDAR_NAME];		
			 	
				oChangeRuleHR := null;
				for (select x(x : id) in ::[CHANGE_RULE] all where x.[CRED] = P_HIGH_LEVEL_CR and x.[DATE_REG] = P_HIGH_LEVEL_CR.[DATE_BEGIN])
				loop
					oChangeRuleHR := x.id;
					exit;
				end loop;
				
				if oChangeRuleHR%id is not null then
					V_CHANGE_RULE := constructor('CHANGE_RULE');
					if not isNUK then
					 	-- поищем условия реструктуризации в линии
					 		oChangeRuleHR%init(true, true);
							V_CHANGE_RULE := oChangeRuleHR;
					 		V_RESTR_KIND := oChangeRuleHR.[KIND];
							-- минимальный платеж с линии тянуть спорно, но можно он не мешает линии но может распространяться на транши
							V_RESTR_MIN_PAY := oChangeRuleHR.[MIN_PAY];
							V_CHANGE_RULE.[STATUS]:= null;
					else				
						V_CHANGE_RULE.[RT_NUK] := oChangeRuleHR.[RT_NUK];
						V_CHANGE_RULE.[RT_VALUE_HIST].[ADD_CURRENT]();
						[CHANGE_RULE]::[NEW#AUTO].reloadTuneValue(V_CHANGE_RULE, V_CHANGE_RULE.[RT_NUK]);
					end if;
				end if;
				
				P_OBJECTS_CRED%delete;
			 	for (select x(x.[OBJ_CRED]:p_obj, x.[NOTES]:p_note, x.[MAIN_OBJ]:p_main)
			 		 in P_HIGH_LEVEL_CR.[OBJECTS_CRED]
			 		 )
			 	loop
			 		P_OBJECTS_CRED.[NEW#AUTO](x.p_obj, x.p_note, char_bool(x.p_main));
			 	end loop;
			
			 	V_SUMMA_PAY		:= P_HIGH_LEVEL_CR.[SUMMA_PAY];
				CALC_NUM_DOG;
				-- 1. Копируем с линии
				[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, null, null, true); --контролируем признак "передавать в транш"
				-- 2. добавляем из вида кредита чего не взяли с линии
				[NEW_DOG_N].get_def_prc_schemes (P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, null, true); -- только новые схемы
				
				-- переносим комиссии из вида кредита
				v_copy_priors := P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false);
				::[PR_CRED].[NEW_DOG_N].Fill_COMISS_ARR(this.[COMISS_ARR], P_KIND_CREDIT.[COMISS_ARR], P_DEPART, v_copy_priors);
				
			end if;
			
			--v-- BS00133979 После определения вида кредита через КВУ удалим заданные правила, если их нельзя использовать для нового вида кредита
			if [FL_RATE_RULE].[LIB].FindPrcRule(this) then
				for (
					select r(distinct r.[DEBT] :debt)
					in ::[FL_RATE_RELATION] all
					where r.[PRODUCT] = this)
				loop
					if not [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR, r.[DEBT]) then
						delete rlt in ::[FL_RATE_RELATION] where rlt.[PRODUCT] = this and rlt.[DEBT] = r.[DEBT];
						[CSMD].MessageBox(V_DEST_STR, 'Удаление правил расчета ставки при смене вида кредита', 'Правила для задолженности '||substr(r.[DEBT].[CODE],1,60)||' будут удалены');
					end if;
				end loop;				
			end if;
			
			-- Проверим возможность работы с правилами	
			if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR) then
				fl_rule_on;
			else
				fl_rule_off;
			end if;
			--^-- BS00133979			 	
		 	
			FillPrcTable (this.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, false, this, P_KIND_CREDIT, vUseFLRule);
			FillComissTable (this.[COMISS_ARR], V_COMISS_TBL);

			if not (P_HIGH_LEVEL_CR is null) then
				rSchemeHLC := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[HIGH_LEVEL_CR].[COMISS_ARR], &LCONST.VD_CALC_PRC);
				rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC);

				if not(rSchemeHLC is null) and not(rScheme is null) and rScheme = rSchemeHLC then
					[CSMD].Disable(V_DEST_STR, 'V_PRC_RATE','V');
				else
					[CSMD].Enable(V_DEST_STR, 'V_PRC_RATE','V');
				end if;
			end if;

			validate_form(P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR);
			Call_Check_Transh_Acc(This);
			kind_cred := P_KIND_CREDIT;
			V_DATE_ENDING_MAX := get_date_ending_max(kind_cred,V_CR_CLASS,V_DATE_GIVE,DATE_BEGIN, sCalendar);
		end if;
		
		-- если на ЭФО изменили номер КВУ (вид кредита, даты), массив "Варианты расчета индивидуальных приоритетов"
		-- скопируем/удалим в договор в зависимости от заполненности номера КВУ
		if P_INFO in ('P_KIND_CREDIT', 'DATE_BEGIN', 'DATE_ENDING', '%VAR%.P_HIGH_LEVEL_CR')
			or v_old_info = '%VAR%.P_HIGH_LEVEL_CR' then
			if (P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false)) and P_KIND_CREDIT is not null then
				get_calc_vertion (this, P_KIND_CREDIT, DATE_BEGIN, DATE_ENDING);
			else
				delete_calc_version (this);
			end if;
		end if;
		
		if P_HIGH_LEVEL_CR is not null
		and (  p_info in ('P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED', '%VAR%.P_HIGH_LEVEL_CR')
			or v_old_info = '%VAR%.P_HIGH_LEVEL_CR'
			)
		then
			--нужно чистить v_old_info сразу после использования
			v_old_info := null;
			if V_USE_PLAN_RULE then
				--при смене ДВУ перестроить ПП при работе через конструктор
				call_make_plan_pr();
			else
				-- спросим, копировать ли параметры планирования из КВУ
				V_COPY_HL_PP := true;
				for
				(	select pp(pp)
					in P_HIGH_LEVEL_CR.[PARAM_FOR_PLAN]
					where pp.[COPY_TO_TRANSH] = true
				)
				loop
					if [FP_TUNE].[LIB].get_bool_value('COPY_HIGH_LEVEL_PP',
										::[FP_TUNE].[LIB].set_canons('METACLASS', this%class
																	, 'DEPART', P_HIGH_LEVEL_CR.[DEPART]%id
																	, 'KIND_PROJECT', P_KIND_CREDIT.[TYPE_PROJECT]%id
																	, 'KIND_CREDITS', P_KIND_CREDIT%id)
														, '0')
					then
						V_DEST_STR := V_DEST_STR || NL$ || ' vAns = MsgBox ("Копировать параметры планирования из КВУ?", vbYesNo)'
											||nl$||'if vAns = vbNo then'||nl$||'V_COPY_HL_PP = false'||nl$||'end if';
						exit;
					end if;
				end loop;
			end if;
					
		elsif p_info = '%VAR%.V_GEN_AGR' then
			if not(P_HIGH_LEVEL_CR is null) then
				V_GEN_AGR := null;
			end if;
	    	if V_GEN_AGR is not null then
				  V_LIMIT_CR	:= V_GEN_AGR.[SUMMA];
			      P_NUM_CONTR	:= V_GEN_AGR.[NUM_CONTRACT];
			      P_OBJECTS_CRED%delete;
			      P_OBJECTS_CRED.[NEW#AUTO](V_GEN_AGR.[AIM], null, null);
			      V_OBJ_CRED := [L_ALEX].get_main_obj(this);
     		end if;
     	elsif p_info = 'P_OBJECTS_CRED' then
			V_OBJ_CRED := [L_ALEX].get_main_obj(this);
		elsif p_info = 'CANCEL' then		
			::[CRED_INTERFACE].[PRX_ZALOG].Set_ref_prod(null);
			executor.set_context('ZALOG_PROD', null);
			executor.set_context('CRED_BUS_PROC', null);
			executor.set_context('$FL_RATE$SET$PROD', null);
			executor.set_context('$FL_RATE$SET$DEBT', null);
			executor.set_context('$FL_RATE$SET$CLCALSS', null);
			executor.set_context('$FL_RATE$SET$SCHEME', null);
			::[CRED_INTERFACE].[PRX_PRC_SCHEME].SetVariablesNewSimple(p_names == ',CR_DOG,', CR_DOG == null);
			
			Gl_rDepart_Res := null;	-- BS00140713
			
			--v-- BS00133979 Если договор не создаем, то удалим правила расчета ставок
			delete flr_relation in ::[FL_RATE_RELATION] all where flr_relation.[PRODUCT] = this;
			--^-- BS00133979
			
			-- откатываем всё и выходим
			::[PR_CRED].[CACHE_LIB].StopBusProcOnError;
			
			V_CHANGE_RULE.[DELETE#AUTO]();
	--v-- Параметры планирования (начало)

		-- Нажали кнопку "Добавить"
		elsif p_info = 'AddP4P' then
			::[CRED_INTERFACE].[PRX_PLAN].PFP_Set_Edit_Auto_v_Cred( this );
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				if Form1.ScriptPlayEx("<% PLPCALL %VAR%.V_PARAM_FOR_PLAN_REF := [PARAM_FOR_PLAN].[NEW#AUTO]() %>") then
					Call Form1.ScriptServerValidate(Nothing, "ADDING_P4P")
					Execute DEST_STR.TEXT					
					GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
				end if
			' || NL$;
		
		-- Добавили новый параметр планирования, обрабатываем это
		elsif p_info = 'ADDING_P4P' then
			if CheckP4P(This) then
				V_PARAM_FOR_PLAN_A%insert(V_PARAM_FOR_PLAN_REF);
				Update_P4P_Grid(This);
			else
				[CSMD].MessageBox(V_DEST_STR, 'Ошибка','Нельзя указать параметр планирования, для которого вид операции совпадает с плановой операцией одной из задолженностей массива "Задолженности МОП" в алгоритме расчета МОП.');
			end if;

		-- Нажали кнопку "Изменить"
		elsif p_info = 'EditP4P' then
			if V_P4P_GRID.exists(V_P4P_IDX) then
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_Set_Edit_Auto_v_Cred( this );
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					if Form1.ScriptPlayEx("<% CALL PARAM_FOR_PLAN EDIT#AUTO '||V_PARAM_FOR_PLAN_REF||' %>") then
						tmpIdx = V_P4P_IDX.TEXT
						GridParam4Plan.DeleteRow(GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT))
						Call Form1.ScriptServerValidate(Nothing, "EDITING_P4P")
						Execute DEST_STR.TEXT
						V_P4P_IDX.TEXT = tmpIdx
						GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
					end if
				' || NL$;
			end if;

		-- Изменили параметр планирования, обрабатываем это
		elsif p_info = 'EDITING_P4P' then
			Update_P4P_Grid(This);

		-- Удалили параметр планирования, обрабатываем это
		elsif p_info = 'DELETING_P4P' then
			if V_P4P_GRID.exists(V_P4P_IDX) then
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_DELETE_AUTO(V_PARAM_FOR_PLAN_REF);
				V_PARAM_FOR_PLAN_REF := null;
				Update_P4P_Grid(This);
			end if;

		-- Нажали кнопку "Умолчания"
		elsif p_info = 'Умолчания' then
			--если конструктор планирования, то индивидуальные настройки сбрасываются, восстанавливается конструктор с вида кредита
			--и запускается перестроение параметров планирования
			call_make_plan_pr();

		-- Нажали кнопку "Планировать"
		elsif p_info = 'Планировать' then
			if V_P4P_GRID.exists(V_P4P_IDX) then
				SaveComissTable (this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);
				pragma get_this;
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				
				-- установим вид льготного периода, именно перед началом планирования так как мы могли менять вид кредита и планирование завязано на записи истории льготных периодов
 				if P_KIND_CREDIT.[GRACE_VAR] is not null then
 					-- чтобы не добавлялись некорректные записи в историю почистим историю
 					if coalesce(dateHist, DATE_BEGIN)	< DATE_BEGIN then
 						::[GRACE_VAR_HIST].[LIB].DelGrace(this);
 					end if;
 					::[GRACE_VAR_HIST].[LIB].pSetGrace(this, DATE_BEGIN, P_KIND_CREDIT.[GRACE_VAR]);
 					dateHist := DATE_BEGIN;
 				else
 					::[GRACE_VAR_HIST].[LIB].DelGrace(this);
 				end if;
				bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				if bMop then
					::[CRED_INTERFACE].[PRX_PLAN].PLAN_MOP(this ,this.[DATE_BEGIN]);
				end if;
				::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, V_PARAM_FOR_PLAN_REF, nvl(V_PLAN_ALL, false), null);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_delete_all_plan_dates(V_PARAM_FOR_PLAN_A, V_PARAM_FOR_PLAN_REF, nvl(V_PLAN_ALL, false), null, P_KIND_CREDIT);
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					Do While GridParam4Plan.Rows > 1
						GridParam4Plan.DeleteRow(GridParam4Plan.Rows - 1)
					Loop
					Call Form1.ScriptServerValidate(Nothing, "PLAN_P4P")
					GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
				' || NL$;
				
			end if;

		-- Спланировали, обновляем грид
		elsif p_info = 'PLAN_P4P' then
			Update_P4P_Grid(This);

		-- Пересчитали сумму аннуитета, обрабатываем это
		elsif p_info = 'RECALC_RAP' then
			Update_P4P_Grid(This);
			
		elsif p_info = '%VAR%.V_USE_PLAN_RULE' then
			--изменение значение признака "Конструктор планирования"
			--валидация фрейма с возможными действиями по конструктору планирования
			::[PR_CRED].[NEW_DOG_LIB].validateUsePlanRule(V_USE_PLAN_RULE, V_DEST_STR);
			
			--валидация МОП
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if not V_USE_PLAN_RULE and (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = true');
			else
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = false');
				P_MOP_TYPE := null;
			end if;
			
			--пересоздаем параметры планирования
			call_make_plan_pr();
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
			
		elsif p_info = 'BtnPRGeneral' then
			--настройка общих правил планирования
			&sp(ChangeRule)
			g_clickBtnRule := true;
			
			tPeriodPlanOnCred.delete;
			tPeriodPlanOnCred := ::[PR_DEBT].[LIB_GENERAL_RULE].getPeriodTuneOnPrCred(this, coalesce(DATE_GIVE, DATE_BEGIN), DATE_ENDING);
			&debug('.validate: tPeriodPlanOnCred '||tPeriodPlanOnCred.count,0)
			
			::[PR_CRED].[NEW_DOG_LIB].clickBtnGeneral(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
			
		elsif p_info = 'BtnPRSeason' then
			--настройка правил сезонности
			&sp(prSeason)
			g_clickBtnSeason := true;
			
			::[PR_CRED].[NEW_DOG_LIB].clickBtnSeason(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
		
		elsif p_info = 'SEASON_CANCEL' then
			--отмена в сезонности
			g_clickBtnSeason := false;
			&rb(prSeason)
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
		
		elsif p_info = 'BtnPRPoint' then
			--настройка дополнительных точек
			::[PR_CRED].[NEW_DOG_LIB].clickBtnPoint(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
		
		elsif p_info = 'BtnPRRecalc' then
			--пересоздаем параметры планирования
			call_make_plan_pr();
		
		elsif p_info = 'CHANGE_PLAN_RULE' then
			
			--вышли из общих правил
			if g_clickBtnRule then
				declare
					bChangeDayPay			boolean;
					bChangePeriod			boolean;
					bChangePrSum			boolean;
				begin
					--доступность "Настроить заново"
					V_NEED_DROP := false;
					::[PR_DEBT].[PR_DROP_POINT].dropGeneralPoint(null, this, bChangeDayPay, bChangePeriod, bChangePrSum, null, tPeriodPlanOnCred);
					&debug(' bChangeDayPay '||bool_char(bChangeDayPay)||' bChangePeriod '||bool_char(bChangePeriod)||' bChangePrSum '||bool_char(bChangePrSum),0)
					if bChangeDayPay or bChangePeriod or bChangePrSum then
						g_needDropPoint := true;
					end if;
				end;
			end if;
			
			--вышли из форм операций по настройке конструктора планирования. необходимо пересчитать параметры планирования
			call_make_plan_pr();
		
		elsif p_info = 'CANCEL_DROP' then
			V_NEED_DROP 	:= false;
			g_needDropPoint := false;
			deleteSavepoint();
			
		elsif p_info = 'BtnPlanOnLine' then
			--вызов операции по визуализации графика на линии
			stdio.put_line_buf('<% PLPCALL [PLAN_OPER].[PLAN_ON_LINE](%PARAM%.P_CRED =>'''|| this%id || ''') %>');
			
	--^-- Параметры планирования (конец)
		
		elsif p_info = '+' then
			CALC_NUM_DOG;--Расчет номера договора
			change_scheme_name ( this);
		elsif p_info = 'X' then
			if P_OVD_ACCOUNT is not null then
				SUMMA := ::[PR_CRED].[CALC_LIMIT](P_OVD_ACCOUNT, null, DATE_BEGIN);
				if not (SUMMA is null) and not(FT_CREDIT is null) then
					V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(SUMMA, FT_CREDIT.[CUR_SHORT]);
				end if;
			else
				pragma error ('Не указан счет, по которому предоставлен овердрафт');
			end if;
		elsif p_info = 'NUM_DOG' then
			[NUM_DOG]	:= NUM_DOG;
			change_scheme_name ( this );

			v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);			
			if v_kind_early.[USE_PRIVATE] and not V_EARLY_PAY is null and ::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY') then					
				V_EARLY_PAY.[NAME] := v_kind_early.[NAME] || ' по договору № ' || NUM_DOG;
			end if;

		elsif p_info = 'P_DEPART' then
			[DEPART] := P_DEPART;
			P_FILIAL := nvl(P_DEPART.[FILIAL], P_FILIAL);--Филиал заменить на филиал выбранного подразделения
						
			--заполним подразделения для выбора вида кредита
			::[PR_CRED].[EDIT_LAST].set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);
			
		elsif p_info = 'P_FILIAL' then
			[FILIAL] := P_FILIAL;
			-- При изменении филиала заново проверяем возможность формировать резервы в другом филиале
			Check_Res_Filial(This);	-- BS00140713
		
		elsif p_info in ('%VAR%.V_PRC_RATE', '%VAR%.V_CREDIT_ARR', 'SAVE_RATE_YES') then
			if p_info = '%VAR%.V_CREDIT_ARR' then
				sign := 'A';
			else
				sign := 'R';
			end if;
			
			declare
				Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
			begin
				rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
				
				-- проверим использование схемы другими договорами
				if p_info = '%VAR%.V_PRC_RATE' then
					bCanSaveRate := true;
					bChangeRate := true;
					V_CAN_PRC_SCH := 1;
					-- если схема общая
					Check_Scheme(rScheme);
				end if;
				
				-- если пользователь сохраняет ставку
				if bCanSaveRate then
					if ::[PROL_CONTRACT].[LIB_FIND_REF].is_exists_scheme_in_tp(rScheme) then			
						stdio.put_line_buf('Схема начисления процентов сформирована автоматически. Ручное редактирование запрещено!');
						V_PRC_RATE := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
						-- обновить в таблице значение ставки
						if not (V_PRC_SCH_TBL.first is null) then
							for idx_prc in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
								where V_PRC_SCH_TBL(idx_prc).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
								V_PRC_SCH_TBL(idx_prc).[PRC] = V_PRC_SCH_TBL(idx_prc).[RES_RATE]	:= V_PRC_RATE;
							end loop;
						end if;
						return;
					end if;
					&debug('Пользователь выбрал вариант изменения процентной схемы V_CAN_PRC_SCH = '||V_CAN_PRC_SCH,0)
					if V_CAN_PRC_SCH = 2 then
						--выбрали копирование схемы
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
						rScheme := null;
						V_CREDIT_ARR := null;
					end if;
				
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
							sign,
							'НЕУЧТЕН_ПРОЦЕНТЫ',
							V_PRC_RATE,
							rScheme,
							V_CREDIT_ARR,
							this,
							DATE_BEGIN,
							greatest(Oper_Day, DATE_BEGIN),
							V_ANNUITET,
							V_ONE_DAY,
							FT_CREDIT);
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
					-- обновить в таблице
					if not (V_PRC_SCH_TBL.first is null) then
						for idxPrc in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
							where V_PRC_SCH_TBL(idxPrc).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
							V_PRC_SCH_TBL(idxPrc).[PRC_REF]	:= ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC);
							V_PRC_SCH_TBL(idxPrc).[PRC]		:= V_PRC_RATE;
							V_PRC_SCH_TBL(idxPrc).[PRC_ARR]	:= V_CREDIT_ARR;
							V_PRC_SCH_TBL(idxPrc).[RES_RATE]:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(idxPrc).[PRC_REF], Oper_Day);
							V_PRC_ADD						:= 'Ставка: '||to_char(V_PRC_SCH_TBL(idxPrc).[RES_RATE], '99990D00000000')||' %';
							exit;
						end loop;
					end if;
				end if;
			end;
			bRebuildParam4Plan := true;
		-- OscaR Банк обслуживания кредита
		elsif p_info = '%VAR%.V_BOK' then
			if V_BOK is not null and V_CLIENT_REQ.[1].[2] is null then
				V_CLIENT_REQ.[0] := 2;
				V_CLIENT_REQ.[2].[2] := CLIENT.[NAME];
				V_CLIENT_REQ.[2].[3] := V_BOK.[RC].[CLIENT].[BANK];
				V_CLIENT_REQ.[2].[PART] := V_BOK.[RC].[CLIENT];
			end if;
		-- End OscaR Банк обслуживания кредита
		
		elsif p_info = 'P_OVD_ACCOUNT' and P_OVD_ACCOUNT is not null then
				P_PRODUCT := locate_product (P_OVD_ACCOUNT);
				locate_over_by_product(P_PRODUCT);
				if not P_OVD_ACCOUNT is null then
					CLIENT := P_OVD_ACCOUNT.[CLIENT_V];
					old_val := FT_CREDIT;
					FT_CREDIT := P_OVD_ACCOUNT.[FINTOOL];
					V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
					V_CLIENT_REQ.[1].[1] := CLIENT;
					V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;
					if old_val != FT_CREDIT then
						this.[COMISS_ARR]%delete;
						if P_HIGH_LEVEL_CR.[COPY_TO_TRANSH] then
							get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], P_HIGH_LEVEL_CR.[FT_CREDIT], DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this, true);
						else
		 					get_def_prc_schemes (P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);
						end if;
					end if;
				end if;
		
		elsif p_info = 'P_PRODUCT' then
			if P_PRODUCT is null then
				P_OVD_ACCOUNT := null;
				V_CLIENT_REQ.[0] := 1;
				V_CLIENT_REQ.[1].[1] := null;
				V_CLIENT_REQ.[1].[2] := null;
			else
				locate_over_by_product(P_PRODUCT);
				P_OVD_ACCOUNT := P_PRODUCT.[GET_ACC_PROD](::[TIP_ACC]([COD]='MAIN_PROD_ACCOUNT'));
				if not P_OVD_ACCOUNT is null then
					CLIENT := P_OVD_ACCOUNT.[CLIENT_V];
					FT_CREDIT := P_OVD_ACCOUNT.[FINTOOL];
					V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
					V_CLIENT_REQ.[1].[1] := CLIENT;
					V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;
				end if;
			end if;

		end if;
		
		if V_CR_CLASS = 'OVERDRAFTS' then
			if p_info = 'P_G_AGRIMENT' then
				P_ACCOUNT		:= null;
				if P_G_AGRIMENT is null then
					this%collection := null;
				else
					insert this into P_G_AGRIMENT.[OVERDRAFTS];
					set_from_gen_agr(This);
				end if;
			end if;
			
			if p_info != 'CANCEL' then
				if not P_G_AGRIMENT is null then
					if DATE_BEGIN is not null and DATE_BEGIN < P_G_AGRIMENT.[DATE_BEGINING] then
						pragma error('Дата начала не может быть меньше даты начала Ген. Соглашения');
					end if;
					
					if DATE_ENDING is not null and DATE_ENDING > P_G_AGRIMENT.[DATE_ENDING] then
						DATE_ENDING := P_G_AGRIMENT.[DATE_ENDING];
					end if;
					
					if P_G_AGRIMENT.[SUMMA] is not null and SUMMA is not null and SUMMA > P_G_AGRIMENT.[SUMMA] then
						pragma error ('Сумма договора '||SUMMA||' не может быть больше лимита кредитования генерального соглашения '||P_G_AGRIMENT.[SUMMA]);
					end if;
				end if;
			end if;
		
			[CSMD].Disable(V_DEST_STR, 'V_DATE_ENDING_MAX','V');
		else
			[CSMD].Enable(V_DEST_STR, 'V_DATE_ENDING_MAX','V');
		end if;
		
		if p_info = 'V_CLIENT_REQ.1.1' then
			if V_CLIENT_REQ.[1].[1] is null or V_CLIENT_REQ.[1].[2].[CLIENT_V] != V_CLIENT_REQ.[1].[1] then
				V_CLIENT_REQ.[1].[2] := null;
			end if;
		elsif p_info = 'V_CLIENT_REQ.1.2' then
			if V_CLIENT_REQ.[1].[1] is null or V_CLIENT_REQ.[1].[2].[CLIENT_V] != V_CLIENT_REQ.[1].[1] then
				V_CLIENT_REQ.[1].[1] := V_CLIENT_REQ.[1].[2].[CLIENT_V];
			end if;
		-- OscaR - Проверка счета на правильность заполнения
		elsif p_info in ('V_CLIENT_REQ.2.1', 'V_CLIENT_REQ.2.3', 'V_CLIENT_REQ.2.FRIENDS') then
			sErrMess := ::[PR_CRED].[L_2].check_client_req(V_CLIENT_REQ, p_info);
			if sErrMess is not null then
				[CSMD].Command(V_DEST_STR, 'MsgBox "'||sErrMess||'", , "Предупреждение"');
			end if;			
		end if;
		-- End OscaR - Проверка счета на правильность заполнения

		if p_info in ('DATE_BEGIN', 'DATE_ENDING', 'PERIOD', 'P_PERIOD_UNIT') then
			pragma set_this;
			::[HOOK].[CRED_SET_DEF_DAT](this);
		end if;
		
		-- поработаем со сроком для транша, устанавливаемом на КВУ --
		if p_info in ('%VAR%.V_TRANSH_PERIOD_NUM'
					, '%VAR%.V_COPY_TO_TRANSH'
					, 'P_KIND_CREDIT'
					, 'DATE_BEGIN'
					, 'DATE_ENDING'
					, '%VAR%.V_DATE_GIVE'
					, 'P_PERIOD_UNIT'
					, 'PERIOD'
					)
		then
			ValidateTranshPeriodNum(p_info
									,V_DEST_STR
									,V_TRANSH_PERIOD_NUM
									,PERIOD
									,V_TRANSH_PERIOD_UNIT
									,P_PERIOD_UNIT
									,V_COPY_TO_TRANSH
									,V_DATE_GIVE
									,DATE_BEGIN
									,DATE_ENDING
									,DIC_TYPE_CRED
									,V_CR_CLASS
									,P_PERIOD_WD
									,sCalendar);
		end if;
		----------------------------------------------------------------
		
		if p_info in ('DATE_BEGIN', 'DATE_ENDING', 'PERIOD', 'P_PERIOD_UNIT','FT_CREDIT', 'SUMMA','P_BALLOON_PAYMENT') then			
			if ISBalloon then
				pragma set_this;
	  			[STR].set_par(sADDS,'P_INFO',P_INFO);
				::[HOOK].[CRED_CALC_BAL](SUMMA,P_BALLOON_PAYMENT,this,sADDs);
			end if;
		end if;

		if p_info in ( 'CLIENT', 'P_FILIAL', 'P_DEPART', 'FT_CREDIT', 'P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED' ) then
			this.[FILIAL] := P_FILIAL;
			this.[DEPART] := P_DEPART;
			this.[FT_CREDIT] := FT_CREDIT;
			this.[KIND_CREDIT] := P_KIND_CREDIT;
			this.[CLIENT] := CLIENT;
			this.[DATE_GIVE] := DATE_GIVE;
			this.[DATE_BEGIN] := DATE_BEGIN;
			this.[DATE_ENDING] := DATE_ENDING;
			
			pragma set_this;
			P_LOAN_PORT := get_port ( this);
			Check_Res_Filial(This); 	-- BS00140713 При выборе портфеля, обновим контролы для в другом филиале
		end if;
			
		&msg(&METHOD$ || 'p_info = ' || p_info);
		if p_info = 'MAKE_DEPAULT_PP' or p_info = 'OK' then
			-- Запуск пересчета параметров планирования, если это необходимо (по ОК или при переходе на вкладку "Планирование")
			
			--Чтобы корректно рассчитать ПП по комиссиям, нужно сохранить таблицы процентов и тарифов на договоре
			[NEW_DOG_N].SaveComissTable (this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);
			pragma get_this;
			
			if bRebuildParam4Plan then
				begin
					call_make_plan_pr();
					if ::[FACTOR_MP].[LIB].ParamUseFactor(V_PARAM_FOR_PLAN_A) then
						InitFactorTune(This);
					end if;
					V_DEST_STR := V_DEST_STR || NL$ || ' Call Form1.ScriptServerValidate(Nothing, "Планировать")';
				exception
					when others then
						bRebuildParam4Plan := false;
					raise;
				end;
			end if;
		end if;
		if p_info in ('P_KIND_CREDIT', '%VAR%.V_INVOICE') then
			if	(this%class in ('KRED_CORP', 'KRED_PERS') and P_KIND_CREDIT.[REG_RULES].[PS] is not null) or
				(nvl(V_INVOICE, false)) or
				(this%class = 'OVERDRAFTS' and P_KIND_CREDIT.[REG_RULES] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and P_KIND_CREDIT.[LINE_TRANSH] is not null)
			then
				[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = true');
			else
				[CSMD].Command(V_DEST_STR, 'Gridcol33.Visible = false');
			end if;
		end if;
		
		--v-- BS00140713 При выборе портфеля, обновим контролы для в другом филиале
		if p_info = 'P_LOAN_PORT' then			
			Check_Res_Filial(This);
		end if;
		--^-- BS00140713
		
		--v-- BS00133979. Запрос на копирование правил с КВУ в транш, обнуление сис. контекста
		if p_info = 'FLR_COPY_TRUE' then
			vCopyFLRule := true;
		elsif p_info = 'OK' then
			if not bChangeRate then
				declare
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
				
					-- если схема общая
					Check_Scheme(rScheme);
				end;	
			end if;

			vCopyFLRule := false;
			if this.[HIGH_LEVEL_CR] is not null and [FL_RATE_RULE].[LIB].FindPrcRule(this.[HIGH_LEVEL_CR]) then
				[CSMD].ShowMsgDlg( V_DEST_STR
								, 'Form1'
								, 'Правила расчета ставок'
								, 'Копировать правила расчета процентных ставок с КВУ?'
								, 'FLR_COPY_TRUE');
			end if;
			executor.set_context('CRED_BUS_PROC', null);
			executor.set_context('$FL_RATE$SET$PROD', null);
			executor.set_context('$FL_RATE$SET$DEBT', null);
			executor.set_context('$FL_RATE$SET$CLCALSS', null);
			executor.set_context('$FL_RATE$SET$SCHEME', null);
		end if;
		--^-- BS00133979
		if p_info = '%VAR%.V_CALENDAR' then
			P_CALENDAR_NAME := V_CALENDAR;
			PR_CRED.[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			this.[CALENDAR_NAME] := P_CALENDAR_NAME;
		end if;
		if p_info = 'SET_PROD_TUNE' then
			--индивидуальные настройки планирования
			V_DEST_STR := V_DEST_STR||NL$||
				'
				if Form1.ScriptPlayEx("<% PLPCALL %VAR%.V_SET_TUNE_CR_CHANGE := %THIS%.[SET_TUNE_CR](%PARAM%.P_PR_CRED => '''||this%id||''') %>") then
					Call Form1.ScriptServerValidate(Nothing, "SET_TUNE_CR_CHANGE")
				end if
				'
				||NL$;
		
		elsif p_info = 'SET_TUNE_CR_CHANGE' then
			--если изменились индивидуальные настройки, то нужно перестроить параметры планирования
			&debug('.validate: V_SET_TUNE_CR_CHANGE '||V_SET_TUNE_CR_CHANGE, 0)
			if not V_SET_TUNE_CR_CHANGE is null and V_USE_PLAN_RULE then
				--пересоздаем параметры планирования
				call_make_plan_pr();
			end if;
		end if;
	
		if p_info = '%VAR%.V_RT_NUK' then			
			if V_CHANGE_RULE is null then
				V_CHANGE_RULE := constructor('CHANGE_RULE');
				V_CHANGE_RULE.[RT_NUK] := V_RT_NUK;
				V_CHANGE_RULE.[DATE_REG] := DATE_BEGIN;
				V_CHANGE_RULE.[RT_VALUE_HIST].[ADD_CURRENT]();
			else
				V_CHANGE_RULE.[RT_NUK] := V_RT_NUK;
				rValueHist := ::[RT_VALUE_HIST].[LIB].get_actual(V_CHANGE_RULE.[RT_VALUE_HIST]);
				rValueHist.[RT_NUK] := V_RT_NUK;
			end if;
			
			if not V_CHANGE_RULE.[RT_NUK] is null then
				V_CHANGE_RULE.[CRED] := this;
				[CHANGE_RULE]::[NEW#AUTO].reloadTuneValue(V_CHANGE_RULE, V_CHANGE_RULE.[RT_NUK]);
			end if;
		end if;
		if p_info = '%VAR%.V_CHANGE_RULE.RT_TUNE_VALUE' then
			dDate_reg := V_CHANGE_RULE.[DATE_REG];
			if DATE_BEGIN != dDate_reg then
				pragma error ('Дата регистрации условий реструктуризации должна быть равна дате начала договора!');
			end if;
		end if;
		if p_info = 'SET_TUNE_LIMIT' then
			stdio.put_line_buf('<% PLPCALL %THIS%.[SET_TUNE_LIMIT]() %>');
		end if;
		if p_info = 'SET_IND_RATES' then
			stdio.put_line_buf('<% PLPCALL [IND_RATES].[SET_IND_RATES](%PARAM%.P_PRODUCT =>'''|| this%id || ''') %>');
		end if;
		if p_info in ('DATE_BEGIN', 'P_KIND_CREDIT') then
			-- определим профиль гашения
			v_distr_profile := get_profile(this%id, coalesce(DATE_BEGIN, Oper_Day), P_KIND_CREDIT);
		end if;
		
		if p_info in ('P_KIND_CREDIT', 'DATE_BEGIN', '%VAR%.V_DATE_GIVE') then
			if V_FACTOR_MP is not null then
				if V_FACTOR_MP.[CRED] = this then
					V_FACTOR_MP.[DELETE_AUTO]();
					V_FACTOR_MP := null;
				end if;
				bRebuildParam4Plan := true;
			end if;
		end if;
	
		if p_info = 'DATE_ENDING' and V_FACTOR_MP is not null then
			this.DATE_ENDING := DATE_ENDING;
			RecalcFactorTune(This);
		end if;
		
		if p_info = '%VAR%.V_SUM_PAYMENT' then
			if ::[FACTOR_MP].[LIB].IsFactorMPForCred(rFirstFactorMPRec) then
				V_FACTOR_MP := this.[MAKE_DEF_MP]
					( P_KIND_CREDIT	== P_KIND_CREDIT
					, P_DATE_BEGIN	== coalesce(V_DATE_GIVE, DATE_BEGIN)
					, P_PLAN		== false
					, P_DATE_SYNCH	== null
					, P_SUM_PAYMENT	== case p_info when 'DATE_BEGIN' then null else V_SUM_PAYMENT end
					);
				InitFactorTune(This);
				&msg(&METHOD$ || '.Validate: После изменения первого платежа: Дата начала = ' || to_char(rFirstFactorMPRec.[DATE_BEGIN], 'dd/mm/yy') || ', Сумма = ' || rFirstFactorMPRec.[SUM_PAYMENT]);
			end if;
		end if;
		
		if p_info = 'FACTOR_MP_DEFAULT' then
			V_FACTOR_MP := this.[MAKE_DEF_MP]( P_KIND_CREDIT	== P_KIND_CREDIT
											, P_DATE_BEGIN	== coalesce(V_DATE_GIVE, DATE_BEGIN)
											, P_PLAN		== false
											, P_DATE_SYNCH	== null);
											
			if not V_FACTOR_MP is null then
				V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			end if;
			RecalcFactorTune(This);
		end if;

		if p_info in ('P_KIND_CREDIT', 'SUMMA') then
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079')  then
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = true');
				--если указан комплексный договор, то смена вида кредита не должна менять МОП
				if p_info = 'P_KIND_CREDIT' and P_CO_PROD is null then
					P_MOP_TYPE := P_KIND_CREDIT.[MOP_TYPE];
				end if;
			else
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = false');
				P_MOP_TYPE := null;
			end if;
		end if;
		
		if p_info = 'TarifMOP' and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') and P_KIND_CREDIT.[MOP_TYPE] is not null then
			stdio.put_line_buf('<% PLPCALL %THIS%.[SET_IND_MOP]() %>');
		end if;
		
		if p_info = 'TYPE_PROJECT_DEFAULT' then
			V_PRJ_KIND_CRED := P_KIND_CREDIT.[TYPE_PROJECT];
		end if;
		
		if p_info='Add_prop' then
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				if Form1.ScriptPlayEx("<%  PLPCALL %VAR%.V_REF_PROP:= [PROPERTY_PROD].[NEW_AUTO](%PARAM%.P_PROD =>'''|| this%id||''', %PARAM%.P_DATE_BEGIN => '''|| null || ''', %PARAM%.P_DATE_END => ''' || null|| ''', %PARAM%.P_KIND_PROP => ''' || null ||''',  %PARAM%.P_VALUE_PROP => '''|| null||''') %>") then
					Call Form1.ScriptServerValidate(Nothing, "AFTER_ADD_PROP")
					V_OTHERS_TERM.Row = V_OTHERS_TERM.RowByIndex(V_OTHERS_TERM_IDX.TEXT)
				end if
			' || NL$;
		end if;
		if p_info='AFTER_ADD_PROP' then
			V_OTHERS_TERM(nvl(V_OTHERS_TERM.last,0)+1) := V_REF_PROP;
			if V_REF_PROP.[KIND_PROP].[TYPE_VALUE]='BOOLEAN' then
				if V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]='1' then
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Да';
				else
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Нет';
				end if;
			end if;
			V_OTHERS_TERM_IDX := V_OTHERS_TERM.last;
		end if;
		if p_info='Edit_prop' then
			if V_OTHERS_TERM.count != 0 and V_OTHERS_TERM_IDX!=0 then
				V_REF_PROP%id := V_OTHERS_TERM(V_OTHERS_TERM_IDX)%id;
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					if Form1.ScriptPlayEx("<%  PLPCALL  %VAR%.V_REF_PROP.[EDIT_AUTO](%PARAM%.P_PROD =>'''|| this%id||''', %PARAM%.P_DATE_BEGIN => '''|| V_REF_PROP.[DATE_BEGIN]
							|| ''', %PARAM%.P_DATE_END => ''' || V_REF_PROP.[DATE_END]|| ''', %PARAM%.P_KIND_PROP => ''' || V_REF_PROP.[KIND_PROP]%id ||''',  %PARAM%.P_VALUE_PROP => '''|| V_REF_PROP.[VALUE_PROP]||''') %>")
					then
						Call Form1.ScriptServerValidate(Nothing, "AFTER_EDIT_PROP")
					end if
				' || NL$;
			end if;
		end if;
		if p_info='AFTER_EDIT_PROP' then
			V_OTHERS_TERM(V_OTHERS_TERM_IDX) := V_REF_PROP;
			if V_REF_PROP.[KIND_PROP].[TYPE_VALUE]='BOOLEAN' then
				if V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]='1' then
					V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]:='Да';
				else
					V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]:='Нет';
				end if;
			end if;
		end if;
		if p_info = 'Del_prop' then
			if V_OTHERS_TERM.count != 0 then
				V_REF_PROP%id := V_OTHERS_TERM(V_OTHERS_TERM_IDX)%id;
				V_DEST_STR := V_DEST_STR || NL$ ||
					'
						V_OTHERS_TERM.DeleteRow(V_OTHERS_TERM.RowByIndex(V_OTHERS_TERM_IDX.TEXT))
						V_OTHERS_TERM_IDX.TEXT = V_OTHERS_TERM.IndexByRow(V_OTHERS_TERM.Row)
					' || NL$;
				V_REF_PROP.[DELETE_AUTO];
			end if;
		end if;
		if p_info in ('ADDING_P4P', 'EDITING_P4P', 'DELETING_P4P' ) then
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = true');
			else
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = false');
				P_MOP_TYPE := null;
			end if;
		end if;
		if p_info = 'P_MOP_TYPE' and P_MOP_TYPE is not null then
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if bMop then
				for p4p in V_PARAM_FOR_PLAN_A where p4p.[OPER] <> ::[VID_OPER_DOG]([CODE]='ГАШЕНИЕ_МОП' ) loop
					for mt in P_MOP_TYPE.[DEBTS_MOP] where mt.[PLAN_OPER] = p4p.[OPER] loop
						pragma error('Нельзя указать алгоритм МОП, в котором для задолженности в массиве "Задолженности МОП" указана плановая операция, совпадающая с существующей плановой операцией в параметре планирования кредитного договора.');
					end loop;
				end loop;
			end if;
		end if;
		
		if p_info='CRED_ASSURED' then
			stdio.put_line_buf('<% PLPCALL %THIS%.[SET_OBESP_CRED]() %>');
		end if;
		
		if p_info = 'CANCEL' then
			--сброс значений локальных переменных
			clearVars();
		end if;
		
		-- событие расчета существенности комиссий
		if p_info like 'CALC_IMPT_COM_%' then
			begin
				nIdxCmsRow := substr(p_info, 15);
				&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
				if V_COMISS_TBL.exists(nIdxCmsRow) and V_COMISS_TBL(nIdxCmsRow).[PRIORITY] is not null then
					V_COMISS_TBL(nIdxCmsRow).[IMPORTANCE] := setImportanceDebt(V_COMISS_TBL(nIdxCmsRow), this);
				end if;
			exception
				when INVALID_NUMBER then
					--не смогли определить номер строки - ничего не делаем
					&debug('.validate: не определили строку массива комиссий ' || p_info, 0)
					null;
			end;
		end if;

		-- событие расчета существенности процентов
		if p_info like 'CALC_IMPT_PRC_%' then
			declare
				oDebtComis		[DEBT_COMISS_PRC];
			begin
				nIdxCmsRow := substr(p_info, 15);
				&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
				if V_PRC_SCH_TBL.exists(nIdxCmsRow) and V_PRC_SCH_TBL(nIdxCmsRow).[PRIORITY] is not null then
					oDebtComis.[PRC_SCHEME] := V_PRC_SCH_TBL(nIdxCmsRow).[PRC_REF];
					oDebtComis.[DEBT] := V_PRC_SCH_TBL(nIdxCmsRow).[DEBT];
					V_PRC_SCH_TBL(nIdxCmsRow).[STOP_CALC] := setImportanceDebt(oDebtComis, this);
				end if;
			exception
				when INVALID_NUMBER then
					-- не смогли определить номер строки - ничего не делаем
					&debug('.validate: не определили строку массива процентных схем ' || p_info, 0)
					null;
			end;
		end if;

		--событие изменения данных в таблице комиссий и тарифов
		if p_info like 'GRID_COMISS_CHNG%' then
			nIdxCmsRow := substr(p_info, 18);
			&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
			if V_COMISS_TBL.exists(nIdxCmsRow) then
				rTypeDebt := V_COMISS_TBL(nIdxCmsRow).[DEBT].[TYPE_DEBT];
				&debug('.validate: тип задолженности '||rTypeDebt.[CODE], 0)
				-- 1) затрата, 2) комиссия, null) - прочее
				V_COMISS_TBL(nIdxCmsRow).[PRIORITY] := case rTypeDebt
											when &LCONST.TD_EXPENSE then 1
											when &LCONST.TD_COMMISS_PRC then 2
											else null
										end;
				&debug('.validate: тип задолженности '||rTypeDebt.[CODE]||' Затрата='||V_COMISS_TBL(nIdxCmsRow).[CHK], 0)
			end if;
		end if;
		
	end if;
end;

execute is
	curator				ref [USER];
	bMop				boolean := false;
	
	rTarifMop			ref [CR_TARIF_MOP];
	oTarifMop			[CR_TARIF_MOP];
	
	iPeriod				integer;
	oChange_Rule		[CHANGE_RULE];
	sCalendar			varchar2(100);
begin
	iPeriod := PERIOD;
	P_DEF_IND := coalesce (P_DEF_IND, false);
	sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(this, this.[CALENDAR_NAME]);
	if P_DEPART is null then
		P_DEPART := [STDLIB].userid.[DEPART];
		P_FILIAL := P_DEPART.[FILIAL];
		stdio.put_line_buf('Внимание! Выбранный филиал был заменен на "'||P_FILIAL.[SHORTLABEL]||'", поскольку подразделение не было заполнено.');
	end if;

	P_FILIAL := coalesce(P_FILIAL, [STDLIB].userid.[FILIAL]);
	if P_FILIAL is null then
		pragma error ('Не указан филиал.');
	end if;
	
	Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);

	err_mess := null;
	parent_class := this%parentclass;

	if parent_class = 'GEN_AGREEMENT' then
		P_G_AGRIMENT := this%parent;
	elsif parent_class = 'GEN_AGREEM_FRAME' then
		V_GEN_AGR := this%parent;
	end if;
	
	if V_GEN_AGR is not null then
		if ::[PR_CRED].[NEW_DOG_LIB].check_gen_agreem_frame(this, DATE_BEGIN, DATE_ENDING, iPeriod, FT_CREDIT, CLIENT, SUMMA, P_FILIAL, P_DEPART, P_OBJECTS_CRED, V_LIMIT_SALDO, P_HIGH_LEVEL_CR, P_KIND_CREDIT, err_mess) = false then
			pragma error(err_mess);
		end if;
	end if;

	if P_G_AGRIMENT is not null then
		if P_G_AGRIMENT.[GET_TUNE]('ЛИМИТ_В_ГЕН_СОГЛ_ОВЕРДРАФТ').bool then
			if SUMMA > nvl(P_G_AGRIMENT.[SUMMA], 0) then
				pragma error ('Сумма договора '||SUMMA||' не может быть больше лимита кредитования генерального соглашения '||P_G_AGRIMENT.[SUMMA]);
			end if;
		end if;
		
		if DATE_BEGIN < P_G_AGRIMENT.[DATE_BEGINING] then
			pragma error ('Договор не может быть открыт раньше даты открытия генерального соглашения '||to_char(P_G_AGRIMENT.[DATE_BEGINING]));
		end if;
		
		if DATE_ENDING > P_G_AGRIMENT.[DATE_ENDING] then
			pragma error ('Дата окончания не может быть больше даты окончания генерального соглашения '||to_char(P_G_AGRIMENT.[DATE_ENDING]));
		end if;
	end if;

	if P_TURNOVER.[NUM_INTERVALS] is not null and P_TURNOVER.[UNIT_INTERVALS] is not null then
		if ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd(coalesce(V_DATE_GIVE, DATE_BEGIN)
															,P_TURNOVER.[NUM_INTERVALS]									
															,P_TURNOVER.[UNIT_INTERVALS]
															,null
															, null
															,null
															,sCalendar)
														> DATE_ENDING + 1
		then
			pragma error('Максимальный срок выдачи не может быть больше срока договора!');
		end if;
	end if;

	-- Условия востребования ---
	if V_INVOICE then
		declare
			nInvoiceSum	[SUMMA];
			iIdx		number;
		begin
	  		nInvoiceSum := 0;
	  		iIdx := V_INVOICE_COND.first;
			loop
				exit when iIdx is null;
				
				if V_INVOICE_COND(iIdx).[PLAN_PERCENT] then
					if V_INVOICE_COND(iIdx).START_SUMMA is null or V_INVOICE_COND(iIdx).START_SUMMA > 100 then
						pragma error('Не корректно указаны условия востребования');
					end if;
					V_INVOICE_COND(iIdx).START_SUMMA := SUMMA*V_INVOICE_COND(iIdx).START_SUMMA/100;
				end if;

				nInvoiceSum := nInvoiceSum + nvl(V_INVOICE_COND(iIdx).START_SUMMA,0);
				iIdx := V_INVOICE_COND.next(iIdx);
			end loop;
			
			if nInvoiceSum > SUMMA then
				pragma error('Общая сумма востребования превышает сумму договора');
			end if;
			
			::[PR_CRED].[NEW_DOG_LIB].FillOpersInvoice([LIST_PLAN_PAY], FT_CREDIT, SUMMA, V_INVOICE_COND);
			
		end;
	end if;
	this.[INVOICE]	:= V_INVOICE;
	----------------------------
	
	this.[COPY_TO_TRANSH]:= nvl(V_COPY_TO_TRANSH, false);
	--------------
	if	P_HIGH_LEVEL_CR is null then --DVZ 19.05.03
		this.[SUMMA_PAY] 	:= V_SUMMA_PAY;
	end if;

	SaveComissTable (this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);
	
	if ::[FACTOR_MP].[LIB].ParamUseFactor([PARAM_FOR_PLAN]) then
		::[FACTOR_MP].[LIB].RecalcAnnuityPayments(this, V_FACTOR_MP_ARR);
	end if;
	
	-- установим вид льготного периода, именно перед началом планирования так как мы могли менять вид кредита и заходить при этом на вкладку планирования
 	if P_KIND_CREDIT.[GRACE_VAR] is not null then
 		-- чтобы не добавлялись некорректные записи в историю почистим историю
 		if coalesce(dateHist, DATE_BEGIN)	< DATE_BEGIN then
 			::[GRACE_VAR_HIST].[LIB].DelGrace(this);
 		end if;
 		::[GRACE_VAR_HIST].[LIB].pSetGrace(this, DATE_BEGIN, P_KIND_CREDIT.[GRACE_VAR]);
 	else
 		::[GRACE_VAR_HIST].[LIB].DelGrace(this);
 	end if;
 	
	bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], null);
	
	begin
		if bMop then
			::[CRED_INTERFACE].[PRX_PLAN].PLAN_MOP(this ,this.[DATE_BEGIN]);
		end if;
		::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, null, true, null);
		::[CRED_INTERFACE].[PRX_PLAN].PFP_delete_all_plan_dates([PARAM_FOR_PLAN], null, true, null, P_KIND_CREDIT);
	exception
		when others then
			stdio.put_line_buf ('Ошибка при построении планового графика '||sqlerrm);
	end;

 	::[CRED_INTERFACE].[PRX_ZALOG].Set_ref_prod(null);
 	::[CRED_INTERFACE].[PRX_PRC_SCHEME].SetVariablesNewSimple(p_names == ',CR_DOG,', CR_DOG == null);

	if ::[FP_TUNE].[LIB].get_bool_value('ROUTING_ORDER', null, '0') then
		curator := ::[LOAN_INSPECTOR].[LIB_01].actual_insp_user(this);
		if curator is not null and this.[PROD_INS_HISTORY]%size(0) = 0 then
			this.[CHNG_PROD_INSP](curator, DATE_BEGIN, null, null, null);
		end if;
		check_cred_insp(V_CRED_INSP, this);
	else
		if this.[PROD_INS_HISTORY]%size(0) = 0 then
			this.[CHNG_PROD_INSP]([STDLIB].UserId, DATE_BEGIN, null, null, null);
		end if;
	end if;
	this.[ONE_DAY]		:= 	nvl(V_ONE_DAY, false);
	-- проверка лимитов кредитования
	-- <Akil> - лимиты кредитования (клиент, филиал, группа клиентов)
	--- 		проверяются в CHECK_CRED_DOG по справочнику уровней проверок.
	--------------------------------
	if P_ACCOUNT is not null then
		this.[ACCOUNT] := P_ACCOUNT;
		-- Пропишем продукт по счету
		P_ACCOUNT.[PRODUCTS].[NEW#AUTO](	this			--P#PROD_REF
											,'ACCOUNT'		--P#PROPERTY
											,this%class	);	--P#PROD_NAME
		declare
			acc_dog_ref	ref [HOZ_OP_ACC];
			req_acc			[REQ_CLIENT];
		begin
			req_acc.[0] := 1;
			req_acc.[1].[1] := CLIENT;
			req_acc.[1].[2] := P_ACCOUNT;
			acc_dog_ref := [ARRAY_DOG_ACC].NEW#AUTO(::[TIP_ACC]([NAME_REQ]='ACCOUNT' and upper([PRODUCT]) like 'КРЕД%')/*P#NAME_ACCOUNT*/,
													req_acc/*P#ACCOUNT_DOG*/,
													null/*P_CASH*/,
													null/*P_VEK*/,
													null/*P_NS*/,
													DATE_BEGIN/*P_DATE_BEG*/);
		end;
	end if;

	--	Для вексельной подсистемы
pragma IF_DEF(VEKS_INST);
	this.[ISSUE_VEK] := P_ISSUE_VEK;
	if P_ISSUE_VEK is not null then
		this.[ISSUE_VEK].[MAIN_PROD] := this;
	end if;
pragma END_IF;

	if V_CLIENT_REQ.[0] = 2 then
		err_mess := ::[PR_CRED].[L_2].check_client_req(V_CLIENT_REQ);
		if err_mess is not null then
			pragma error('Ошибка в реквизитах для расчетов по кредиту:'||err_mess);
		end if;
	end if;
	::[REQ_CLIENT].[LIBS].Refresh(V_CLIENT_REQ);
	if P_DATE_PAYOUT_LTD is not null then
		if DATE_ENDING is not null and P_DATE_PAYOUT_LTD > DATE_ENDING then
			err_mess := err_mess || 'Предельная дата выдач не может быть больше даты окончания договора';
		end if;
		if nvl(DATE_GIVE,DATE_BEGIN) > P_DATE_PAYOUT_LTD then
			err_mess := err_mess || 'Предельная дата выдач не может быть меньше даты выдачи или даты начала действия';
		end if;
	end if;
	if DIC_TYPE_CRED is null then
		err_mess := err_mess || 'Не заполнено правило учета договора.';
	elsif this.[DIC_TYPE_CRED] = &LCONST.TC_CRED_OVER then
		if V_MAX_LIMIT_SALDO is not null and nvl(V_LIMIT_SALDO, SUMMA) > V_MAX_LIMIT_SALDO then
			err_mess := err_mess || 'Значение максимального лимита задолженности должно быть больше лимита задолженности';
		end if;
 	end if;
	
	if err_mess is not null then
		pragma error (err_mess);
	end if;
	
	this.[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;
	this.[DATE_BEGIN]		:= DATE_BEGIN;
	this.[PERIOD_UNIT]		:= P_PERIOD_UNIT;
	this.[NOTES]			:= NOTES;
	this.[FT_CREDIT]		:= FT_CREDIT;
	this.[DATE_ENDING]		:= DATE_ENDING;
	this.[DATE_ENDING_MAX]	:= V_DATE_ENDING_MAX;
	this.[CLIENT]			:= CLIENT;
	this.[SUMMA_DOG]		:= SUMMA;
	this.[CREATE_USER]		:= [STDLIB].userid;
	this.[DIC_TYPE_CRED]	:= DIC_TYPE_CRED;
	this.[OBJECTS_CRED]		:= P_OBJECTS_CRED;
	this.[OPER_WAY_OUT]		:= P_OPER_WAY_OUT;
	this.[KIND_CREDIT]		:= P_KIND_CREDIT;
	this.[OKOHX]			:= V_OKONH;
	this.[PRJ_KIND_CRED]	:= V_PRJ_KIND_CRED;
	this.[EARLY_PAY] 		:= V_EARLY_PAY;
	this.[CALENDAR_NAME]	:= P_CALENDAR_NAME;
	-- особенности овердрафтов
	if V_CR_CLASS = 'OVERDRAFTS' then
		this->(::[OVERDRAFTS])[CALC_TYPE] := P_CALC_TYPE;-- вид сальдирования овердрафта
		if not P_G_AGRIMENT is null then				-- копирование счетов в рамках ген. соглашения
			for over
				in P_G_AGRIMENT.[OVERDRAFTS]
				where over%id != this%id
					and over.[COM_STATUS] != &LCONST.STATUS_CLOSE
					and over.[DATE_CLOSE] is null
				order by over.[DATE_BEGIN] desc
			loop
				::[PR_CRED].[LIB_EXT].copy_acc_dog ( over, this);
			end loop;
		end if;
	end if;
	
	if NUM_DOG is null then	-- Расчет номера договора
		NUM_DOG := this.[GET_NEW_NUM_DOG](P_KIND_CREDIT.[NUM_SHABL]);
	end if;

	this.[NUM_DOG] := NUM_DOG;
	P_KIND_CREDIT.[SET_NUM_SHABL];-- Установить шаблон номера договора

	this.[TURNOVER]		:= P_TURNOVER;
	this.[CREATE_USER]	:= [STDLIB].userid;
	this.[FILIAL]		:= P_FILIAL;
	this.[DEPART]		:= P_DEPART;

	--Вставка данных по комиссии за открытие лимита/счета
	this.[FOR_OPEN_PAY]	:= P_FOR_OPEN_PAY;
	this.[FOR_OPEN_BOOL]	:= P_FOR_OPEN_BOOL;
	this.[FOR_OPEN_YEAR]	:= P_FOR_OPEN_YEAR;
	P_FOR_OPEN_FN	:= nvl(P_FOR_OPEN_FN, FT_CREDIT);
	this.[FOR_OPEN_FN]	:= P_FOR_OPEN_FN;
	if nvl(P_LMT_DAY_TO_PAY, 0) > 0 then
		::[PROPERTY_PROD].[LIB].AddProperty(
			  rProd == this
			, dDateBeg == DATE_BEGIN
			, dDateEnd == null
			, rKindProp == &propLimitDayToPay
			, sValueProp ==	to_char(P_LMT_DAY_TO_PAY)
		);
	end if;

	this.[GEN_AGR]		:= V_GEN_AGR;
	this.[DATE_GIVE]		:= V_DATE_GIVE;
	this.[NUM_CONTR]		:= P_NUM_CONTR;
	this.[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;
	this.[DATE_PAYOUT_LTD] := P_DATE_PAYOUT_LTD;

	this.[CLIENT_REQ]:= V_CLIENT_REQ;
	::[PRODUCT].[LIB_01].SetMainReqClient(this, V_CLIENT_REQ);
	-------------------------------------
	if DECL_ON_CRED_REF is not null then
		DECL_ON_CRED_REF.[DECL_PRD] := this;
		DECL_ON_CRED_REF%state := 'EXECUTION';
		-- добавим историю изменения заявки
		::[DOCUMENT].[DOC_LIB].add_history_state(DECL_ON_CRED_REF, DECL_ON_CRED_REF%state, TO_CHAR(Oper_Day, 'DD.MM.YYYY'), null, null);
	end if;
	if this.[DIC_TYPE_CRED] = &LCONST.TC_CRED_OVER   then
		if nvl(V_LIMIT_SALDO, 0) = 0 then
			V_LIMIT_SALDO := SUMMA;
	 	end if;
		this.[LIMIT_SALDO] := V_LIMIT_SALDO;
		this.[MAX_LIMIT_SALDO] := V_MAX_LIMIT_SALDO;
	else
		this.[LIMIT_SALDO] := null;
		this.[MAX_LIMIT_SALDO] := null;
	end if;

	if P_HIGH_LEVEL_CR is not null and not nvl(P_HIGH_LEVEL_CR.[INVOICE], false) then
		-- копирование счетов из одного договора в другой
		::[PR_CRED].[LIB_EXT].copy_acc_dog(P_HIGH_LEVEL_CR, this);
	end if;

	this.[COM_STATUS]	:= &LCONST.STATUS_WAIT_CONF;
	
	--если указан комплексный договор, то нужно обратиться в CO_PROD за подключением и получение тарифов
	if not P_CO_PROD is null then
		declare
			rAlgMopAfterConnect ref [CR_CALC_MOP];
		begin
			::[RUNTIME].[STR].set_par(V_ADDS, 'GET_TARIF_ON_KIND_CREDIT', 1);
			::[RUNTIME].[STR].set_par(V_ADDS, 'CHANGE_TARIF_ON_PR_CRED', 0);
			
			::[CRED_INTERFACE].[PRX_TARIF_PLAN].AddConnection(p_id_prd		== this
															, p_class_prd	== 'PR_CRED'
															, p_co_prod 	== P_CO_PROD
															, p_date 		== DATE_BEGIN
															, p_status		== 'A'
															, p_adds 		== V_ADDS);
			
			--проверим алгоритм МОП. Если он установлен при подключении, то сбросим значение, установленное на ЭФ
			rAlgMopAfterConnect := ::[CR_CALC_HIST].[LIB].fGetMop(this, this.[DATE_BEGIN]);
			&debug('алгоритм МОП после подключения '||rAlgMopAfterConnect%id, 0)
			if not rAlgMopAfterConnect is null then
				P_MOP_TYPE := null;
			end if;
			
			--выполняем удаление зависимостей для автоматического расчета реквизитов
			&debug('Удаление зависимостей по процентным ставкам для автоматического расчета реквизитов', 0)
			::[PR_CRED].[LIB_TARIF_PLAN].deleteDepSchemeOnPrc(this, DATE_BEGIN);
		end;
	end if;

	-- OscaR банк обслуживания кредита
	if V_BOK is not null then
		this.[CREDIT_BANKS].[NEW#AUTO](V_BOK, DATE_BEGIN, null);
	end if;
	-- End OscaR банк обслуживания кредита
	::[HOOK].[CRED_SET_DEF_DAT](this);	-- вызов заполнения дат по умолчанию в массиве "схемы зависимостей"

	-- отнесение в портфель, до проверок и подписания с открытием счетов
	ATTACH_TO_PORT.attach(this, P_LOAN_PORT, DATE_BEGIN, DATE_BEGIN);

	if V_OPEN_DEP then
		P_PRODUCT := ::[PR_CRED].[NEW_DOG_LIB].CreateDepnContract(this);
	end if;
	this.[OVER_ON_PROD] := P_PRODUCT;	-- продукт, по которому предоставлен кредит	

	--v-- BS00133979. Перед проверками рассчитаем процентные ставки по правилам если они были добавлены
	if vUseFLRule then
		FLR_FirstCalcRules (this, this.[DATE_BEGIN]);
	end if;
	--^-- BS00133979
	
	if V_TRANSH_PERIOD_NUM is not null then
		::[PROPERTY_PROD].[LIB].AddProperty(this, DATE_BEGIN, null, propTRANSH_PERIOD_NUM, V_TRANSH_PERIOD_NUM);
	end if;

	this.[CHECK_CRED_DOG]( &cBP_REGISRATION );

	--v-- реструктуризация в начале договора (сохраним значения если есть, до подписания)
	if not isNUK then
		if V_CHANGE_RULE is null and not V_RESTR_KIND is null then
			V_CHANGE_RULE := constructor('CHANGE_RULE');
		end if;
		
		V_CHANGE_RULE.[DATE_REG] := DATE_BEGIN;
		oChange_Rule := V_CHANGE_RULE;
		
		if not V_RESTR_KIND is null
			and nvl(oChange_Rule.[STATUS], -1) != ::[COM_STATUS_PRD]([CODE] = 'WORK')
			and this.[DIC_TYPE_CRED].[PS] is null
		then			
			-- принудительно обновим план
			::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, null, true, null);
			
			if this.[LIST_PLAN_PAY]%size(0) > 0 then
				-- рассчитаем даты исходя из вида реструктуризации
				V_CHANGE_RULE.[DATE_FROM] := nvl(this.[DATE_GIVE], this.[DATE_BEGIN]);				
				V_CHANGE_RULE.[KIND] := V_RESTR_KIND;
				oChange_Rule := V_CHANGE_RULE;					
				::[CHANGE_RULE].[NEW#AUTO].Set_PrcRestr_Dates(this, oChange_Rule);
				::[CHANGE_RULE].[NEW#AUTO].check_req(this, V_RESTR_MIN_PAY, oChange_Rule.[DATE_FROM], oChange_Rule.[DATE_TO], true, V_RESTR_KIND, (nAdd_First = 0));
				V_CHANGE_RULE := oChange_Rule;
			end if;
		end if;
		SetRestr(this, V_RESTR_KIND, V_RESTR_MIN_PAY, oChange_Rule);
		
	else
		if V_CHANGE_RULE is not null and nvl(V_CHANGE_RULE.[STATUS], -1) != ::[COM_STATUS_PRD]([CODE]='WORK') then
			-- принудительно обновим план
			::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, null, true, null);
			dDate_reg := V_CHANGE_RULE.[DATE_REG];
			if DATE_BEGIN != dDate_reg then
				pragma error ('Дата регистрации условий реструктуризации должна быть равна дате начала договора!');
			end if;
			::[RT_NUK].[LIB_TUNE].calc_tune(p_change_rule == V_CHANGE_RULE, p_bus_process == ::[BUS_PROCESS]([CODE] = 'RT_УМОЛЧАТ'), p_validator_lines == V_DEST_STR, p_adds == V_ADDS);	
			::[RT_NUK].[LIB_TUNE].calc_tune(p_change_rule == V_CHANGE_RULE, p_bus_process == ::[BUS_PROCESS]([CODE] = 'RT_СОХРАНИТЬ'), p_validator_lines == V_DEST_STR, p_adds == V_ADDS);		
		end if;
	end if;
	--^-- реструктуризация в начале договора (сохраним значения если есть, до подписания)
	
	if P_SIGN_UP then
		this.[SIGN_UP](nvl(P_OPEN_ACC, false),null,null,null,null,P_DEF_IND);
	end if;

	if this.[GR_RISK_HIST]%size(0) = 0 then
		this.[CALC_GR_RISK]( DATE_BEGIN, false, false, null, true, null);
	end if;
	
	if not(isNUK and V_CHANGE_RULE is not null and P_SIGN_UP) then
		::[CRED_INTERFACE].[PRX_PLAN].PLAN_HIST_ADD_CURRENT(this.[PLAN_HIST]);
	end if;
	::[PR_CRED].[GET_CONTROL_VAL].Flush();

	update_bki(this, nvl(V_TO_BKI, false), Oper_Day); -- <Akil> -- обновить массив разрешений для БКИ

  	--v-- BS00140713. Сохраним значение признака в массиве RES_OTHER_FIL
  	if Gl_rDepart_Res is not null then
  		::[PRODUCT].[L_RES].save_res_fil_sign(this.[RES_OTHER_FIL], P_FILIAL_RES.[0] = 2, least(Oper_Day, DATE_BEGIN), true);
  		Gl_rDepart_Res := null;
  	end if;
  	--^-- BS00140713
	
	--v-- BS00133979. Если получено согласие на копирование правил с КВУ в транш, вызовем соответствующую операцию
	if vCopyFLRule then
		vCopyFLRule := null;
		stdio.put_line_buf('<% PLPCALL %THIS%.[FLR_COPY_RULES]() %>');
	end if;	
	--^-- BS00133979
	
	if P_HIGH_LEVEL_CR is not null then
		this.[NEW_REQ_CLIENT].copy_accs_to_transh(this);
	end if;

	P_PERIOD_WD := nvl(P_PERIOD_WD, false);
	-- сохраняем только если были изменения по галочкам
	if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE')) = '1', false) <> P_PERIOD_WD then
		-- сначала удаляем исходное значение в настройке
		::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE'));
		-- затем добавляем
		::[PROPERTY_PROD].[LIB].AddProperty(this,
						DATE_BEGIN,
						null,
						::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE'),
						P_PERIOD_WD);
	end if;
	P_TURNOVER_WD := nvl(P_TURNOVER_WD, false);
	if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD')) = '1', false) <> P_TURNOVER_WD then
		-- сначала удаляем исходное значение в настройке
		::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'));
		-- затем добавляем
		::[PROPERTY_PROD].[LIB].AddProperty(this,
						DATE_BEGIN,
						null,
						::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'),
						P_TURNOVER_WD);	
	end if;

	set_balloon_payment(this, DATE_BEGIN, P_BALLOON_PAYMENT);
	
	Oper_Day := null;
	
	if v_distr_profile is not null then
 		::[CR_DISTR_PR_HIST].[LIB].Set_Hist(this				--Продукт
											, date_begin		--Дата начала действия
											, null				--Дата окончания действия
											, nvl(v_distr_profile, -1));
 	end if;
 	
 	if not P_MOP_TYPE is null then
 		rTarifMop := ::[CR_CALC_HIST].[LIB].fGetTarifMop(this, this.[DATE_BEGIN]);
 		if rTarifMop is null then
 			oTarifMop := this.[KIND_CREDIT].[TARIF_MOP];
 		else
 			oTarifMop := rTarifMop;
 		end if;
 		::[CR_CALC_HIST].[LIB].pSetTypeMop(this, this.[DATE_BEGIN], P_MOP_TYPE, oTarifMop);
 	end if;
 	
	if not coalesce(V_DO_FACTORING, true) and P_HIGH_LEVEL_CR is null then
		::[PROPERTY_PROD].[LIB].AddProperty(this, DATE_BEGIN, null, ::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING'), false); 	
	end if;

 	--Категория информации
	::[CATEGORY_INFO].[LIB].GetCategoryInfo(null, this, null, null, this.[CATEGORY_INFO]);
	
	--сброс значений локальных переменных
	clearVars();
end;
end;
end;
