class PR_CRED;

/**
@comment
Операция "Открыть договор"
Операция регистрации в системе нового кредитного договора.
Выполняется привязка ссудного счета к договору: открывается новый счет или указывается открытый ранее счет. Контрагент (кредитуемая организация) привязывается к договору из списков клиентов банка, и потому  он должен быть предварительно зарегистрирован в системе. 
Выполняемые функции: 
Пользователю предлагается экранная форма операции (окно), позволяющая  ввести параметры договора и  подтвердить или отменить вызов операции (выбором соответствующей "кнопки" экранной формы). Ввод параметров договора выполняется через заполнение значениями соответствующих полей экранной формы. При отказе от выполнения операции новый договор не создаётся, а введенные данные игнорируются.
Экранная форма операции.
Предлагает ввести следующие пункты договора:
·	Клиент договора, обязательный для заполнения пункт
·	Сумма кредита
·	Валюта  кредита,  значение по умолчанию ? национальная валюта.
·	Дата начала кредитного договора, значение по умолчанию ? дата текущего операционного дня.
·	Дата окончания кредитного договора
·	Тип кредита ? возможен выбор значения из справочника "Типы кредитов" (значения: кредит, кредитная линия)
·	Путь выдачи кредита - возможен выбор значения из справочника "Пути выдачи кредита" (значения: выдача наличными, перечислением на расчетный счет, перечислением на депозит т. д.)
·	Объект кредитования - возможен выбор значения из справочника "Объекты кредитования".
·	Проценты по кредиту -  процентная схема текущего кредитного договора.
·	Залоги  - массив записей о залогах
·	Гарантии ? массив записей о гарантиях кредита
·	Плановые операции по кредиту (массив операций)
      Открытие ссудного счета
·	Балансовый счет ? обязательный для заполнения пункт, если  не указан конкретный 
       лицевой счет (пункт ? Номер счета).
·	Номер счета ? обязательный для заполнения пункт, если не указан балансовый счет (пункт Балансовый счет). Если балансовый счет определен, данный пункт можно не водить, и тогда при выполнении операции будет открыт лицевой счет с первым свободным номером  внутри указанного балансового счета.
·	Примечания
Элементы управления
·	ОК ? "кнопка" подтверждения удаления текущего договора
·	Отмена ? "кнопка" отказа от выполнения удаления


*/
@import_plsql(true)
@name('S226. Редактировать договор')
@tag('COPIED')
method S226_EDIT_LAST is
@name('Класс кредита')                                            public V_CR_CLASS                    [STRING_100];
@name('Класс клиента')                                            public CL_CLASS                      [STRING];
@name('Заявка на получение кредита')                              public DECL_ON_CRED_REF              [DECL_ON_CRED_REF];
@name('Генеральное соглашение по кредитным линиям')               public V_GEN_AGR                     [GEN_AGREEM_F_REF];
@name('Подписать сразу')                                          public P_SIGN_UP                     [BOOLEAN];
@name('Лимит остатка ссудной задолженности')                      public V_LIMIT_SALDO                 [SUMMA];
@name('Процентная ставка за кредит')                              public V_PRC_RATE                    [NUM_16_8];
@name('История правил начисления процентов')                      public V_CREDIT_ARR                  [ARR_ARC_SCH_PRC];
@name('Дата выдачи')                                              public V_DATE_GIVE                   [DATE];
@name('Сумма прописью')                                           public V_SUM_STR                     [STRING_1000];
@name('Кредит верхнего уровня')                                   public P_HIGH_LEVEL_CR               [PR_CRED_REF];
@name('Открыть счета')                                            public P_OPEN_ACC                    [BOOLEAN];
@name('Аннуитетный платеж')                                       public V_ANNUITET                    [BOOLEAN];
@name('Реквизиты  клиента  для расчетов по кредиту')              public V_CLIENT_REQ                  [REQ_CLIENT];
@name('Плановые операции по кредиту')                             public V_LIST_PLAN_PAY               [PLAN_OPER_REF];
@name('Кредит для всех плановых операций')                        public V_PL_CRED                     [PR_CRED_REF];
@name('Текущая группа риска')                                     public V_RISK_GROUP                  [CRED_RISK_REF];
@name('Лимит кредитования')                                       public V_LIMIT_CR                    [SUMMA];
@name('Однодневный кредит')                                       public V_ONE_DAY                     [BOOLEAN];
@name('До востребования')                                         public V_INVOICE                     [BOOLEAN];
@name('Условия востребования')                                    public V_INVOICE_COND       table of [PARAM_FOR_PLAN];
@name('Индекс таблицы условий востребования')                     public V_INVOICE_IDX                 [STRING_32];
@name('Статус Договора')                                          public V_COM_STATUS                  [COM_STATUS_P_REF];
@name('Валюта платы за откр. лимита')                             public P_FOR_OPEN_FN                 [FT_MONEY_REF];
@name('Параметр планирования')                                    public V_PARAM_FOR_PLAN              [PARAM_FOR_PLAN];
@name('Параметр планирования, ссылка')                            public V_PARAM_FOR_PLAN_REF          [PARAM_FOR_PL_REF];
@name('Параметры планирования, массив')                           public V_PARAM_FOR_PLAN_A            [PARAM_FOR_PL_ARR];
@name('Плановые операции (массив)')                               public V_LIST_PLAN_PAY_ARR           [PLAN_OP];
@name('Вид операции')                                             public V_VID_OPER                    [VID_OP_KRED_REF];
@name('Планировать все')                                          public V_PLAN_ALL                    [BOOLEAN];
@name('Состояние записи')                                         public V_STATUS                      [STRING_1];
@name('Срок линии распространять на транш')                       public V_COPY_TO_TRANSH              [BOOLEAN];
@name('Обеспечение')                                              public V_ZALOG_CHOICE                [ZALOG_REF];
@name('Код ОКОНХ')                                                public V_OKONH                       [OKONH_REF];
@name('Командная строка валидатора')                              public V_DEST_STR                    [STRING_32000];
@name('Тип проекта')                                              public V_PRJ_KIND_CRED               [KIND_PROJECT_REF];
@name('Созаемщики')                                               public V_DEBTORS                     [DEBTORS_ARR];
@name('Условия досрочного погашения')                             public V_EARLY_PAY                   [EARLY_PAY_REF];
@name('Дополнительные свойства')                                  public V_PROPERTIES                  [PROPERTIES_ARR];
@name('Пути выдачи кредита')                                      public V_WAY_OUT_CODE                [STRING_2];
@name('Максимальная дата окончания')                              public V_DATE_ENDING_MAX             [DATE];
@name('Коды подразделений')                                       public V_STRING_DEPARTS              [STRING_32000];
@name('Дополнительное условие по классу')                         public V_ADD_CLASS                   [STRING_100];
@name('Ссудный счет')                                             public P_ACCOUNT                     [AC_FIN_REF];
@name('Список комиссий')                                          public V_COMISS_TBL         table of [DEBT_COMISS_PRC];
@name('Список процентных схем')                                   public V_PRC_SCH_TBL        table of [VIEW_PRC_SCH];
@name('Информация о базовой схеме')                               public V_PRC_ADD                     [STRING_100];
@name('Основной объект кредитования')                             public V_OBJ_CRED                    [OBJ_KRED_REF];
@name('Предоставлять информацию в БКИ')                           public V_TO_BKI                      [BOOLEAN];
@name('Таблица параметров планирования')                          public V_P4P_GRID           table of [PARAM_FOR_PL_REF];
@name('Индекс таблицы параметров планирования')                   public V_P4P_IDX                     [STRING_32];
@name('Карточный договор')                                        public V_IS_FOR_CRED_CARD            [BOOLEAN];
@name('Открыть депозитный договор')                               public V_OPEN_DEP                    [BOOLEAN];
@name('Вид кредита')                                              public V_KIND_CREDIT                 [KIND_CREDITS_REF];
@name('Максимальный лимит задолженности')                         public V_MAX_LIMIT_SALDO             [SUMMA];
@name('Вариант обновления схем')                                  public V_SCHM_CHANGE                 [SHORT1];
@name('Процентные схемы для правил расчета')                      public V_SCHM_FOR_RULE               [STRING_2000];
@name('Вид реструктуризации')                                     public V_RESTR_KIND                  [CHANGE_KIND_REF];
@name('Минимальный платеж')                                       public V_RESTR_MIN_PAY               [SUMMA];
@name('Выбранный календарь')                                      public V_CALENDAR                    [REFERENCE];
@name('Копировать ПП из КВУ')                                     public V_COPY_HL_PP                  [BOOLEAN];
@name('Условие реструктуризации')                                 public V_CHANGE_RULE                 [CHANGE_RULE_REF];
@name('Настройка универсального конструктора')                    public V_RT_NUK                      [RT_NUK_REF];
@name('Профиль гашения')                                          public V_DISTR_PROFILE               [CR_DISTR_PRO_REF];
@name('Настройки ежемесячных платежей')                           public V_FACTOR_MP                   [FACTOR_MP_REF];
@name('Ежемесячные платежи')                                      public V_FACTOR_MP_ARR               [FACTOR_MP_REC_AR];
@name('Размер платежа в первый год')                              public V_SUM_PAYMENT                 [SUMMA];
@name('Ежемесячные платежи (для просмотра)')                      public V_FACTOR_MP_VIEW_ARR          [FACTOR_MP_REC_AR];
@name('Прочие условия')                                           public V_OTHERS_TERM        table of [PROPERTY_PROD];
@name('Индекс таблицы прочих условий')                            public V_OTHERS_TERM_IDX             [STRING_32];
@name('Ссылка на свойство')                                       public V_REF_PROP                    [PROPERTY_PRO_REF];
@name('Возможность изменять ставку')                              public V_CAN_PRC_SCH                 [SHORT1];
@name('Индекс списка процентных схем')                            public V_PRC_SCH_TBL_IDX             [SHORT7];
@name('Согласие на продажу договора')                             public V_DO_FACTORING                [BOOLEAN];
@name('Срок транша. Количество периодов')                         public V_TRANSH_PERIOD_NUM           [DIG_6];
@name('Срок транша. Единица измерения периода')                   public V_TRANSH_PERIOD_UNIT          [REF_UNIT_OF_TIME];
@name('Дополнительные параметры')                                 public V_ADDS                        [STRING_32000];
@name('Конструктор планирования')                                 public V_USE_PLAN_RULE               [BOOLEAN];
@name('Параметры планирования. Конструктор планирования')         public V_P4P_PLAN_RULE               [PARAM_FOR_PL_ARR];
@name('Результат изменения индивидуальных настроек планирования') public V_SET_TUNE_CR_CHANGE          [STRING_1000];
@name('Ссылка на кредитный договор для скрипта')                  public V_CRED_VBS                    [PR_CRED_REF];
@name('Признак вызова сброса')                                    public V_NEED_DROP                   [BOOLEAN];
@name('Признак наличия первоначального признания')                public V_INI_RECOG                   [BOOLEAN];
@name('График уплаты затрат')                                     public V_LIST_EXP_PAY_ARR            [PLAN_OP];
@name('Стадии обесценения')                                       public V_DEVAL_HIST         table of [DEVAL_HIST_REF];
@name('Ссылка на кредит для фильтра')                             public V_THIS                        [PR_CRED_REF];
@name('Ссылка на УИД')                                            public V_UID                         [UID_REF];
	/*
 * Дата     Автор       BFS         Описание
 * --------	-----------	-----------	---------------------------------------------------------------------------------------
 * 16.04.02 Maxlime					Создание операции
 * 28.07.06 AEliseev	BFS00024402	Если у транша и у линии одна процентная схема, то...
 * 31.07.06 AEliseev	BFS00024285	Скорректирована работа пересчета суммы аннуитетного...
 * 01.08.06 Orlov		BFS00023664 Добавлена обработка нового реквизита "Вид сальдирования овердрафта"
 * 04.08.06	VFedoseev	BFS00024406	По нажатию кнопки "Умолчание" (закладка "Планирование") проверяется, имеется ли по договору заявка...
 * 14.08.06	VFedoseev	BFS00025373	Параметр операции "Вид сальдирования овердрафта" сделан необязательным (умолчательное значение - null).
 * 15.08.06	afrantsuzov	BFS00023316	В клиент-скрипте сделано ограничение на поле "Сумма", можно ввести не больше 14 символов
 * 20.09.06	VFedoseev	BFS00017703	В процедуре call_make_plan_pr добавлена установка значения реквизита "Кредит верхнего уровня"...
 * 21.09.06	AFrantsuzov	BFS00025578 При смене вида кредита значение реквизита "тип проекта" меняется только в том случае, если...
 * 12.10.06	AFrantsuzov	BFS00027105	При заполнении доп. свойств договора добавлен вызов хука.
 * 28.11.06	VFedoseev	BFS00027688	При ручном изменении ссылки	на заявку на первой	закладке ЭФ, для получения реквизитов клиента...
 * 28.11.06	VFedoseev	BFS00027851	При ручном изменении ссылки на заявку на первой закладке ЭФ, путь выдачи кредита берется...
 * 28.11.06	VFedoseev	BFS00027595	Если перед вызовом процедуры validate_invoice, которая делает недоступным контрол "Максимальная дата окончания",...
 * 29.11.06	VFedoseev	BFS00027399	При валидации контролов "Клиент" и "Валюта" (при условии, что оба эти контрола заполнены, а в виде кредита...
 * 30.11.06	VFedoseev	BFS00027399	Установлен фильтр для представления "Список всех кредитов верхнего уровня", вызываемого при нажатии на кнопку...
 * 12.12.06	AFrantsuzov	BFS00028913	Вызов функции get_def_prc_schemes из NEW_DOG_N приведен в соответствие с изменениями ее параметров для...
 * 18.01.07	VFedoseev	BFS00029749	При очистке массива комиссий и процентных схем, выполняемой при смене вида кредита, очищаются также...
 * 22.01.07	JBokhan		BFS00029539 Добавлен контроль на непустое значение реквизита "Правило учета".
 * 24.01.07	AFrantsuzov	BFS00029592 При выборе заявки добавлен вызов функции validate_form. На ЭФ поле "Срок" ограничено 4 символами.
 * 09.02.07	VFedoseev	BFS00031365	На первую закладку ЭФ выведен регистрационный номер клиента.
 * 									Из ветки DEFAULT валидатора убран перенос инф-ции о непроцентных видах задолженностей (из вида кредита).
 * 21.02.07	VFedoseev	BFS00030875	При смене вида кредита валюта заполняется по виду кредита, а если она там не указана - указываем нац.валюту.
 * 									Это заполнение производится только в случае, если не указано генеральное соглашение. При смене вида кредита
 * 									процентные схемы подтягиваются из вида кредита даже для траншей линии, у которой установлен признак копирования условий.
 * 09.03.07 Judge       BFS00027409 Переменная V_PRC_RATE, определяющая дату начала действия процентной ставки теперь определяется как минимальная из дат начала договора и опердня, раньше дата определялась как дата опердня.
 *                                  Изменена логика построения условий досрочного погашения при смене вида кредита. Теперь эталонные условия выбираются сначала из заявки, и только, если условия в заявке не указаны, или заявка не указана, условия выбираются из вида кредита.
 *                                  Раньше эталонные условия выбирались только из вида кредита. Теперь новый реквизит заявки "Условия досрочного погашения" стал более приоритетным.
 * 07.06.07	VFedoseev	BFS00035280	При смене вида кредита (и отсутствии ген.соглаш. по кред.лин.) валюта заполняется
 * 									по виду кредита, а если она там не указана, то по валюте КВУ. Если валюта не определилась и по КВУ  - указываем нац.валюту.
 * 17.07.07	AEliseev	BFS00035549	Запрещено для прямого редактирования грид параметров планирования
 * 24.07.07	AEliseev	BFS00037105	Корректно отрабатывается пересчет суммы аннуитета
 * 09.08.07	Ponomarev	BFS00033049 На экранную форму на закладку "Дополнительно" помещен массив "Информация из БКИ"
 * 22.01.08	AEliseev	BS00061254	Очищаем сумму лимита для простых договоров
 * 04.03.08 Horoshun	BS00032826  Удалена кнопка "Пересчитать" с экранной формы.
 * 26.03.08	Horoshun	BS00065670	Удален вызов функции validate_vek, в которой была жесткая зависимость от кода вида кредита с кодом "2". Только для него разрешалось
 * 									заполнение ссылки на договор продажи векселей.
 * 09.04.08	Horoshun	BS00068082	Добавлено удаление рассчитанных процентов при изменении даты начала договора или даты выдачи кредита.
 * 30.07.08	Horoshun	BS00076417	Исправлена очистка реквизита "Способ обработки выписки" у схемы начисления процентов -
 * 									реквизит очищается только в том случае, если договор перешел из однодневного
 * 									кредита в многодневный.
 * 04.08.08	JBokhan		BF00075964	1. Вместо обращения к удаленному реквизиту [OVER_ON_PROD] таблицы [OVERDRAFTS]
 * 									выполнено обращение к новому реквизиту [OVER_ON_PROD] таблицы [PR_CRED].
 * 									2. Для карточных договоров сделаны доступным для изменения продукт и счет, по которому выдается кредитный договор.
 * 15.08.08	JBokhan		BS00076590	1. Добавлена переменная на форму операции V_OPEN_DEP и ее обработка.
 * 									2. Доработан функционал для договоров до востребования.
 * 18.12.08	Horoshun	BS00088230	Добавлен фильтр по валюте на условия досрочного погашения.
 * 23.03.08	Akil		BS00095464	Добавлен параметр для использования в фильтре параметра вида кредита, чтобы текущее значение пропускалось фильтром
 * 01.09.09	Evmenov		BS00114117	Удалено заполнение реквизитов [PR_CRED].[NOT_AUTO_PLAN] и [OVERDRAFTS].[NOT_AUTO_GASH]
 * 30.09.09	Dmiv		BS00110460	Добавлена работа с реквизитом MAX_LIMIT_SALDO
 * 23.11.09	Akil 		BS00121931	Добавлена инициализация MAX_LIMIT_SALDO из реквизита
 * 03.12.09	Akil 		BS00120654	Копирование %% схем по новой технологии, передавать в транш, условия линии заменено на срок передавать в транш
 * 18.01.10	Ponomarev	BS00125880	Для договоров, по которым могут открываться транши, в гриде процентных схем отображаем колонку "В транш"
 * 25.01.10	Evmenov		BS00128949	Если правило учета "CRED_OVER", то реквизиту LIMIT_SALDO присваивается значение параметра SUMMA
 * 05.02.10	Dmiv		BS00128102	Замена получение остатка по счету учета лимита, на сумму задолженности ЛИМИТ
 * 									В функцию check_gen_agreem_frame передается параметр P_KIND_CREDIT.
 * 28.04.10 Nesterenko	BS00135391	Добавлено упорядочевание записей в гридах Процентные схемы (V_PRC_SCH_TBL), Список комиссий (V_COMISS_TBL),
 *  								Параметры планирования (V_P4P_GRID), Условия востребования (V_INVOICE_COND).
 * 01.06.10 Nesterenko	BS00133030	При создании процентной схемы, схема создается в валюте договора.
 * 03.06.10	Nesterenko	BS00133979	Добавлена работа с правилами расчета плавающих ставок
 * 08.09.10	Ponomarev	BS00107373	Добавлено копирование вариантов расчета инд.приоритетов из вида кредита
 * 01.10.10 Azaikov		BS00140573	Добавлен вывод итоговой %-ставки
 * 11.10.10 Jbokhan		BS00147936	Изменен вызов с ::[PR_CRED].[NEW_DOG_N].find_acc_by_prd(P_PRODUCT) на P_PRODUCT.[GET_ACC_PROD],
 *									в которую передается ссылка на тип счета "MAIN_PROD_ACOUNT".
 * 03.11.10	Ponomarev	BS00138426	Удалено изменение клиента для расчетов при поднятии формы
 * 27.09.10 Nesterenko	BS00140713  Добавлена возможность использования технологии "Урегулирование резерва в другом филиале".
 * 22.11.10	Nesterenko	BS00144998	При изменении на ЭФО Вида кредита происходит безусловное обновление Типа проекта.
 * 11.01.11 AGanin		BS00156795	Разрешено редактирование %% ставки в таблице "Процентные схемы" только в состоянии "Ожидает подтверждения"
 * 14.01.10 AGanin		BS00149547	Использование системного флага CR_REZ_LN заменено на одноименную настройку
 * 20.01.11	Akil		BS00158671	Контролы для условий реструктуризации в начале договора. Проверка и сохранение условий если контролы заполнены
 * 11.02.11 AGanin		BS00159051	Переменная V_PL_STR (varchar2) заменена на V_PL_CRED (ref PR_CRED), изменен фильтр V_LIST_PLAN_PAY для корректного отображения всех плановых операций
 * 28.02.11 Jbokhan		BS00161065	При добавлении/редактировании реквизитов клиента для расчетов - реквизиты сохраняются в справочнике LIST_REQ_CLIENT
 *									("Кредиты. Расчетные счета клиентов") с приоритетом 1.
 * 19.04.11 AGanin		BS00162480	При смене типа проекта, вида кредита запрос о варианте изменения %%схем выводится только если они заполнены и выбран непустой вид кредита
 * 05.05.11 Ponomarev	BS00165490	Блокируется контрол "Предоставлять информацию в БКИ" если нет прав на KB_FORM_EVENT
 * 16.06.11 Azaikov		BS00166579	При редактировании %-ставки в гриде обновление в истории производится в дату опер.дня
 * 22.06.11	Ponomarev	BS00168802	Действия при смене вида кредита вынесены в отдельную процедуру
 * 22.08.11 Ponomarev	BS00167431	Исправлены фильтры на выбор типа проекта и вида кредита. Вызов операций через интерфейсы
 * 29.08.11	Tkach		BS00163265	Добавлена обработка реквизита CALENDAR_NAME
 * 11.09.11 Pyshkin		BS00174100	Исправлен фильтр для реквизита "Виды кредитов": в представление попадают только экземпляры, у которых признак "Архивный" либо не установлен, либо false.
 * 06.12.11 Pyshkin		BS00180629	Исправлена ситуация с копированием лишних процентных схем.
 * 16.12.11 Banas		BS00180222	Доп. параметр "P_HIST_DATE" заполняется датой опер.дня перед вызовом операции CHECK_CRED_DOG
 * 30.01.12 Madyarov	BS00183953	Теперь, если к "Типу проекта" не привязан вид кредита, то при загрузке формы вид кредита показывается из реквизита договора
 * 01.02.12	Ponomarev	BS00185816	На форму операции добавлена кнопка для установки индивидуальных настроек
 * 15.02.12	Banas		BS00187375 	Добавлен вызов копирования р/c с КВУ в транш copy_accs_to_transh
 * 01.03.12 Iljushevich	BS00189002	Добавлена переменная P_PERIOD_WD, P_TURNOVER_WD и логика ее обработки при определении сроков договора
 * 22.03.12 AGanin		BS00180159	На вкладку дополнительно добавлена кнопка "Индивидуальные настройки", переработана форма для большей понятности
 * 30.03.12 Iljushevich	BS00191407	Сделана инициализация переменных P_PERIOD_WD и P_TURNOVER_WD
 * 03.04.12 Pyshkin		BS00190618	Оптимизирован фильтр реквизита "Вид кредита"
 * 10.04.12	SOmelchenko BS00192288	Добавлено заполнение реквизита договора OVER_ON_PROD перед формирование номера договора
 * 19.04.12 Iljushevich BS00192680  Изменен алгоритм выбора способа выдачи кредита, в связи с изменением структуры справочника WAY_KRED. Теперь в справочнике возможно только одно значение записи для конкретного кода.
 * 07.06.12 Iljushevich	BS00201736	Добавлена обработка нового реквизита "Последний платеж"
 * 06.07.12	Iljushevich	BS00211466	На ЭФ для реквизита P_OPER_WAY_OUT указано наименование для представления.
 * 06.07.12 Zheleznov	BS00186322	Добавлен вызов операции редактирования индивидуальных курсов по продукту
 * 30.08.12 Iljushevich	BS00449956	На ЭФ для реквизита "Вид сальдирования овердрафта" выводимая колонка заменена на "Наименование вида сальдирование"
 * 08.10.12 Zheleznov	BS00462488	Добавлена установка срока по умолчанию из вида кредита
 * 30.10.12 Guseynov	BS00463475	Добавлено блокирование поля на ЭФ "Максимальная дата окончания" для овердрафтов
 * 30.11.12 Guseynov	BS00466717	Добавлен вызов хука CRED_CALC_BAL, для расчета размера последнего платежа договоров с Balloon
 * 22.01.13 chebotarev	BS00469895	Добавлено обновление даты начала действия записи истории планового графика при изменении даты начала договора
 * 13.05.13 Iljushevich	BS00477230	Конструктор реструктуризации (kabakov, guseinov)
 * 03.06.13 Iljushevich	BS00480852	Убран деструктор переменной v_change_rule в блоке OK и CANCEL.
 * 05.06.13 Reznik		BS00481274	Для приложения 1B290204 "Автоматическое досрочное гашение" добавлен параметр P_EARLY_PAY - ссылка на виды заявок на досрочное гашение, сохраняется в доп.свойствах договора
 * 18.06.13 Kabakov		BS00481914	Для параметра P_OPER_WAY_OUT выводимая колонка заменена на "Полное наименование"
 *						BS00482210	Для параметра P_CALC_TYPE выводимая колонка заменена на "Наименование"
 * 03.10.13 Lakomov		BS00553274  Добавлено скрытие контрола вид заявки на досрочное погашение при выключенном приложении 1B290204.
 * 04.10.13	zakirov		BS00506511	Добавлены переменные операции: "Настройки ежемесячных платежей" (V_FACTOR_MP), "Ежемесячные платежи" (V_FACTOR_MP_ARR), "Размер платежа в первый год" (V_SUM_PAYMENT), "Ежемесячные платежи (для просмотра)" (V_FACTOR_MP_VIEW_ARR).
 *									На вкладку "Планирование" экранной формы добавлена группа элементов управления настроек ежемесячных платежей. В серверную и клиентскую валидацию добавлена обработка настроек ежемесячных платежей и связанных с ними элементов экранной формы.
 *									На экранной форме группа элементов "Реструктуризация в начале договора" перенесена с вкладки "Планирование" на новую вкладку "Реструктуризация".
 * 04.10.13 Jbokhan		BS00559613	На вид кредита наложен фильтр, исключающий из доступа виды кредитов для составных продуктов.
 *									Добавлена проверка, если вызов над "траншем" составного продукта через PLPCALL, то не выполнять CHECK_CRED_DOG, заблокировать доступ к редактированию элементов ЭФО, как при состоянии "Работает".
 *									Удалена копия процедуры get_calc_vertion, обращение get_calc_vertion переведено на get_calc_vertion в NEW_DOG_N.
 * 29.10.13	drozhzhin	BS00566269	Приведение к одной размерности V_PRC_RATE и V_PRC_ADD
 * 31.10.13	Saraskin	BS00482213	Добавлена валидация платежных реквизитов клиента с использованием библиотечных функций
 * 01.11.13	drozhzhin	BS00571943	На ЭФО реквизитов для расчетов в раздел "Не клиент банка" добавлен контрол КПП.
 * 05.11.13	gruntovskiy	BS00577295	В тело операции вставлен вызов операции RecalcAnnuityPayments из библиотеки [FACTOR_MP].[LIB]. Вызов операции выполняется если добавляется
 *									договор с ежемесячными платежами. В конец процедуры RecalcFactorTune вставлен вызов операции RecalcAnnuityPayments.
 *
 * 28.11.13 Saraskin	BS00595219 	Проверка ключевания счета в режиме "не клиент" вынесена в библиотечную функцию. Логика работы с контролами Счет и Клиент в режиме "клиент" приведена к общей для продукта.
 * 11.12.13 ABorisov	BS00621333	Исправлен фильтр для вида кредита.
 * 25.12.13 ABorisov	BS00653186	Поле период на ЭФ увеличено до 6 символов. Элементы ЭФ скорректированы чтоб вместить период.
 * 13.01.14 drozhzhin	BS00692405	Добавлен параметр P_MOP_TYPE, контрол для вызова операции индивидуальной установки Тарифа МОП + добавления по коду по работу с Алгоритмом МОП(планирование).
 * 17.12.13 Chebotarev	AIZHK		Добавлена обработка функционала ежемесячного платежа при вызове операции из конструктора составного продукта.
 * 20.02.14 sfedorischenko	BS00737265 В секцию "переменные" добавлены три переменные: "Прочие условия", "Индекс таблицы прочих условий", "Ссылка на свойство". На ЭФО добавлена вкладка "Прочие условия" и  соответствующие контролы
 *										Кнопка "Дополнительные свойства" перенесена с вкладки "Открыть договор" на "Прочие условия". Добавлен валидатор для добавления/редактирования записей в гриде "Прочие условия"
 * 20.02.14 AKozlov		BS00559922	Добавлена проверка на права пользователя при изменении ставки в общей процентной схеме. При наличии прав на операцию [PRC_SCHEME].[PRC_SCH_ACCESS]
 *									пользователю предлагается выбор, либо изменить общую процентную схему, либо скопировать схему в договор.
 * 25.02.14 Saraskin	BS00665975	Добавлен флаг создания составного продукта bCreateComposit. При валидации даты выдачи во время создания части составного продукта производится перерасчет параметров планирования
 * 26.02.14 Saraskin	BS00650043	Обращение к check_client_req переведено на библиотеку L_2, добавлена валидация реквизита V_CLIENT_REQ.1.2
 * 27.02.14 aromanenko	BS00714196	Добавлено получение условий досрочного погашения из массива на виде кредита при валидации параметров "Вид Кредита", "Валюта" и "Номер договора"
 * 03.03.14	drozhzhin	BS00796443	Исправлена перерасчет ЕП при изменении даты начала договора
 * 19.03.14 gerasev		BS00808271	Добавлен перерасчет ЕП при изменении даты окончания кредитного.
 * 08.04.14 sfedorischenko	BS00814458	В секции проверка при удалении прочего условия меняем номер текущего элемента в гриде. При добавлении прочего условия, индекс делаем равным последней записи в гриде
 * 14.04.14 ABorisov	BS00821572	В секции проверка для кнопки планировать добавлен анализ моп/не моп перед вызовом plan_mop.
 * 30.04.14 Saraskin	BS00827153	В клиент-скрипте текущее значение ячейки грида сохраняется в переменную для сравнения с новым значением (т.к. метод Value(Row,Col) грида возвращает для дробей меньше единицы не старое значение, а новое).
 									Изменено условие валидации для грида %VAR%.V_PRC_SCH_TBL чтобы исключить ложные срабатывания.
 * 05.05.14 Spinu		BS00744040  Добавлена возможность указать Алгоритм МОП, в случае если на виде кредита не настроен параметр планирования "Гашение МОП" а в параметрах планирования есть операция "Гашение МОП" 									
 * 08.05.14	Reznik		BS00827858	Добавлена логическая переменная "Согласие на продажу"(V_DO_FACTORING)  и ее обработка (353ФЗ)
 * 12.05.14	Chebotarev	BS00827688	В списке видов сальдирование исправлено отображение на наименование.
 * 21.05.14 Bakovkin	BS00828617	Исправлено условие установки переменной "Показывать вид кредита" (V_SHOW_KIND_CREDIT).
 									Исправлено условие для фильтрации вида кредита на ЭФО: теперь архивный вид кредита корректно отображается на форме в поле "Вид кредита".
 * 27.05.14	Reznik		BS00827779	Добавлена функция GetDateCalcMop для определения даты, на которую нужно планировать МОП, блокируем кнопку "Создать по умолчанию" на вкладке "Планирование" если договор с МОП и не в статусе "Ожидает подтверждения"
 * 26.05.14	drozhzhin	BS00829069	Тариф МОП.
 * 29.05.14 Bakovkin	BS00828617	Исправлено условие для фильтрации вида кредита на ЭФО: если не найден тип проекта на виде кредита уже открытого договора и к типу проекта не привязан вид кредита,
 *									то показываем вид кредита из переменной "Вид кредита" (V_KIND_CREDIT) кредитного договора.
 * 30.05.14	Jbokhan		BS00665910	При автоматическом формировании настроек ЕП, если задана, анализируется "дата выдачи".
 * 18.06.14	Reznik		BS00831454	Принудительное перепланирование перенесено в условие для реструктуризации
 * 20.06.14 bakovkin	BS00821568	При вызове функций, определяющих алгоритм МОП (fGetMop) и профили гашения (get_profile), параметр дата, на которую рассчитывается значение, заменен с "Дата начала" (DATE_BEGIN) на дату опердня (Oper_day).
 * 24.06.14 Bakovkin	BS00831708	На ЭФО на вкладке "Проценты и комиссии" изменена ширина колонок "Ставка", "Итоговая ставка".
 * 26.06.14 Bakovkin	BS00821458	Вызов ::[PR_CRED].[NEW_DOG_N].fCheckMop заменен на ::[PR_CRED].[LIB_EXT].fCheckMop.
 * 02.07.14	Jbokhan		RP0025547	В блоке проверке по 'DEFAULT' добавлено определение пользовательского контекста 'CRED_BUS_PROC'.
 * 09.07.14	Timofeev	RP0066232	В процедуру PrcScheme_Clear в новый параметр передается obj_cred.[COMISS_ARR].
 * 11.07.14	Akhmadeeva	BS00469475	Добавлено заполнение реквизита [CATEGORY_INFO].
 * 17.07.14	Azarov		RP0026767	При валидации контролов "Клиент" и "Валюта", если валюта заполнена а счет клиента нет, добавлено условие CLIENT%class != 'CL_PRIV' при определении признака счета rPsOrg.
 * 27.08.14 sfedorischenko	RP0014527	На ЭФО добавлена кнопка "Обеспеченность договора". В валидаторе реализована обработка нового контрола
 * 03.09.14 Timofeev	RP0072850	Добавлена установка вида льготного периода в истории.
 * 30.09.14 Timofeev	RP0107160	Заполнение истории льготных периодов перенесено перед планированием.
 									Добавлено удаление истории льготных периодов в случае если выбран вид кредита без льготного периода.
 * 06.11.14 Timofeev	RP0133934	Строка определения класса продукта должна содержать символы ';'.
 * 19.11.14 babiiv		RP0014235	На ЭФО добавлена кнопка "Категория потреб. кредита". В валидаторе реализована обработка нового контрола.
 * 10/12/14 ABorisov	RP0154487	Удалена переменная V_SHOW_KIND_CREDIT и вся связанная с ней логика.
 * 16.01.15 Reznik		RP0066301	На ЭФО добавлена надпись, в случае когда филиал расчетного счета не совпадает с филиалом кредитного договора.
 * 19.01.15	Timofeev	RP0145964	Запрещено изменение процентной ставки схемы, созданной из тарифной подсистемы.
 									Добавлена установка на договор схемы, выбранной в списке процентных схем.
 * 12.03.15 Azarov		RP0211988	В фильтре для вида кредита убраны условия проверки отсутствия класса FACTORING в списке классв, если создание кредитного договора вызвано из факторинга.
 									Добавлено заполнение переменной V_ADD_CLASS для овердрафта.
 									Выполнена оптимизация кода - избавление от exception, locate, select переделан на for (select..)
 * 20.02.15 Jbokhan		RP0132331	Добавлены переменные V_TRANSH_PERIOD_NUM и V_TRANSH_PERIOD_UNIT. При определении срока транша добавлен анализ доп.свойства "TRANSH_PERIOD_NUM".
 *									Исправлена обработка переменной V_COPY_HL_PP: устанавливаем значение по умолчанию = true и исключаем анализ настройки "COPY_HIGH_LEVEL_PP" из цикла по ПП договора.
 *									Исправлено определение опердня с учетом филиала договора, для этого используется функция ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial.
 *									В вызовах calc_period_units и DayPeriodAdd первым параметром везде исправлено на coalesce(V_DATE_GIVE, DATE_BEGIN).
 * 08.05.15	Dyadichkin	RP0207816	Удален параметр P_EARLY_PAY и вся связанная с ним логика.
 * 12.05.15 Dyadichkin	RP0232397	Добавлен параметр P_CO_PROD. Добавлена переменная V_ADDS. При p_message = 'DEFAULT' добавлен функционал по заполнению параметра P_CO_PROD через вызов
 									::[CRED_INTERFACE].[PRX_TARIF_PLAN].GetCoProdOnProduct и вывод сообщения пользователю если кредитный договор включен в комплексный договор.
 * 09.06.15	rogalenko	RP0271422	В секции валидации в случае не совпадения филиала КД и филиала расчетного счета меняем значение текстового полю Label38
 * 17.07.15	Gorbash		RP0294809	В секции валидации в случае наличия плановых операций гашения МОП, блокируем кнопку Планировать на закладке планирования.
 * 28.01.16	Kabakov		RP0469162	В секции валидации в случае изменения КВУ производится очистка массива счетов транша, чтобы избежать дублирования счетов при подписании.
 * 25.02.16 dyadichkin	RP0478153	В процедуре Check_Res_Filial при выборе данных по кредитному договору добавлен модификатор all.
 * 16.03.16 kljushin	RP0487722	В тело добавлена pragma error для случая, когда филиал не установлен и не вычислен по-умолчанию.
 * 18.03.16 perkov		RP0421137	Добавлен вызов интерфейса по показателям ::[CRED_INTERFACE].[PRX_UU_NCB_INT].InsRecTA.
 * 30.05.16 karabanov	RP0514939	В секции "Проверка" добавлено копирование из вида кредита/удаление элементов массива "Варианты расчета индивидуальных приоритетов" в регистрируемом договоре при удалении/заполнении номера КВУ на ЭФО.
 * 07.06.16	JBokhan		RP0477870	В секции "Проверка" на валидацию контролов ('PERIOD', 'P_PERIOD_UNIT', 'P_PERIOD_WD') и 'DATE_ENDING' добавлена проверка, если у КВУ указан срок для транша и срок транша превышает срок КВУ, выдается сообщение об ошибке.
 * 02.09.16  			RP0371334 	Конструктор планирования.
 * 12.01.17	Gruntovskiy	RP0545982	Реализован контроль банкротства заемщика.
 * 03.03.17 Polezhaev	RP0551049	При помещении записи в историю об устанавливаемом на договоре профиле погашения, удалена передача даты окончания договора в качестве параметра даты окончания действия профиля
 * 21.03.17 Podkovko	RP0552303	В процедуру on_change_kind_credit добавлена проверка попадания даты окончания на выходной день при автоматическом расчете срока.
 * 27.07.17 Kljushin	RP0565493	В валидации добавлена логика соответствия филиала подразделению:
 * 									 - при изменении филиала очищается подразделение;
 * 									 - выбор подразделения осуществляется из списка подразделений выбранного филиала или полного списка в случае отсутствия филиала;
 * 									 - при выборе подразделения устанавливается филиал из выбранного подразделения.
 * 01.08.17 Gruntovskiy	RP0565578	Реализован запрет изменения сложной процентной ставки.
 * 09.10.17 Podkovko	RP0571025	Доработана логика фильтрации видов кредитов.
 * 30.11.17 Karabanov	RP0572592	Добавлена возможность выбора реквизитов клиента для расчетов по кредиту из справочника контрагентов.
 * 29.12.17	Podkovko	RP0567195	Доработка реструктуризации.
 * 30.01.18 Karabanov	RP0579948	В процедуру set_departs добавлен параметр, определяющий необходимость проверки и сброса вида кредита в зависимости от указанного в нем подразделения.
 * 29.05.18 Kljushin	RP0588716	Валидация создания массива процентных ставок реализована через таймер.
 * 26.03.18 Gorbash 				Проверка приложения 1B290093 заменена настройкой.
 * 13.04.18 shlikov		RP0583365	Добавлена переменная для определения характеристик МСФО.
 * 10.08.18 verevkina	RP0593791 	Из проверки удалено объявление переменной bMop. Добавлена очистка истории алгоритмов МОП, если выбран вид кредита без алгоритма МОП. Добавлено сохранение алгоритма МОП с вида кредита при удалении ссылки на алгоритм МОП.
 * 23.08.18 kljushin	RP0586689	В грид комиссий и затрат добавлен признак существенности и его расчет. Добавлена кнопка графика уплаты затрат.
 * 31.08.18	Gorbash		RP0583741	Добавлены переменные и контрол на форму для работы со стадиями обесценения МСФО.
 * 12.11.18 pkartashev	RP0598618	Добавлена обработка признака существенности для процентных задолженностей
 * 11.01.19 shlikov		RP0601426	Добавлена обработка настройки логики продукта IFRS_DEFAULT
 * 28.03.19 kljushin	RP0605036	Добавлено ведение комиссии за открытие лимита/счета в массиве комиссий.
 * 30.09.19 Anoshkin	RP0613997	Добавлена переменная Ссылка на УИД
 * 17.01.20 janus		RP0615121	Добавлено получение календаря из функции GetCurCalendarName.
 * 03.08.20	janus		RP0625728	Изменена логика получения индивидуального календаря.
 * 02.09.20	shlikov		RP0624933	Добавлена логика обновления PN в структурах МСФО при смене клиента.
 * 07.05.21 vfilchak	RP0636011	При валидации поля "Клиент" поиск реквизитов происходит всегда. Повторяющийся код вынесен в процедуру SetClient().
*/
pragma include (::[SYSTEM].[PRODUCTS]);
pragma include (::[PR_CRED].[LIB_MACRO]);
pragma include (::[DEBUG_TRIGGER].[MACRO_LIB]);
pragma include (::[RUNTIME].[MACRO_LIB]);

Oper_Day	date;

gen_frame	ref [GEN_AGREEM_FRAME];
kind_cred	[KIND_CREDITS];
sign 		varchar2(5);
cnt			number := 0;

nShift_First	integer; -- Сдвиг гашений
nAdd_First		integer; -- Отсрочка гашений по кредиту
rPsOrg		ref [PS];

bDisableOverOnProd	boolean;

Prc_Arr ::[PR_CRED].[NEW_DOG_N].Proc_Arr;

bCanSaveRate	boolean; -- подтверждение на сохранение общей ставки
v_old_kind		ref [KIND_CREDITS];
v_old_info		varchar2(100);
v_copy_priors	boolean;

vUseFLRule boolean;		-- BS00133979

Gl_rDepart_Res	ref [DEPART];	-- BS00140713
Gl_Change_Res_Fil boolean;		-- BS00140713

oChangeRuleHR	[CHANGE_RULE]; 		-- реструктуризация в начале действия договора кредита верхнего уровня
isNUK				boolean;		-- наличие установленного конструктора реструктуризации
rValueHist 		ref [RT_VALUE_HIST];
dDate_reg			date;
b_Kind_Cred_Changed	boolean;

rFactorMPKind		ref	[FACTOR_MP];	-- Настройки ежемесячных платежей из вида кредита
rFirstFactorMPRec	ref	[FACTOR_MP_REC];-- Ежемесячный платеж первого периода (для платежей с причислением процентов)
bCopyMPTune			boolean := null;	-- Необходимость копирования настроек ежемесячных платежей из вида кредита

bComposit		boolean := false; 	-- признак работы с составным продуктом
bCreateComposit	boolean := false; 	-- признак создания договора составного продукта
bIgnorCheck		boolean := false;	-- признак необходимости не выполнять [CHECK_CRED_DOG] в теле операции
isEditCompositPart	boolean := false; 	-- признак вызова с формы конструктора составного продукта

bMop			boolean;
dCalcMop		date;
dateHist		date;	-- дата начала истории льготных периодов

glHL_PERIOD_NUM 		[DIG_6];			-- Для транша: срок и единица измерения срока от КВУ --
glHL_PERIOD_UNIT		ref [UNITS_OF_TIME];
propTRANSH_PERIOD_NUM 	ref [KIND_PROP_PROD] := ::[KIND_PROP_PROD]([CODE] = 'TRANSH_PERIOD_NUM');

bRebuildParam4Plan	 	boolean := false;	--необходимость пересчета параметров планирования
bRebuildPlanRule		boolean := false;	--перестроение конструктора планирования
bRecalcOnChangeLimit	boolean := false;	--признак того, что был выполнен виртуальный пересчет планового графика траншей по плановым операциям изменения лимита
g_needDropPoint			boolean := false;	--признак того, что необходимо сбросить точки, т.к. изменены общие правила
g_clickBtnRule			boolean := false;
g_clickBtnSeason		boolean := false;	--признак настройки сезонности

tPeriodPlanOnCred		::[PR_DEBT].[LIB_CREATE_PP].TPeriodOnVidDebtTable;

--
pragma macro(CSMD_Visible, 'if ([4]) then [CSMD].Show([1], [2], [3]); else [CSMD].Hide([1], [2], [3]); end if', substitute);
pragma macro(CSMD_VisibleS, 'if ([3]) then [CSMD].ShowS([1], [2]); else [CSMD].HideS([1], [2]); end if', substitute);
pragma macro(CSMD_Enabled, 'if ([4]) then [CSMD].Enable([1], [2], [3]); else [CSMD].Disable([1], [2], [3]); end if', substitute);
pragma macro(CSMD_EnabledS, 'if ([3]) then [CSMD].EnableS([1], [2]); else [CSMD].DisableS([1], [2]); end if', substitute);
pragma macro(propLimitDayToPay, '::[KIND_PROP_PROD]([CODE] = ''LIMIT_DAY_TO_PAY'')', substitute);

pragma macro(IsCredLine,
			'V_CR_CLASS != ''OVERDRAFTS'' -- не овердрафт
			 and coalesce(DIC_TYPE_CRED, &LCONST.TC_CRED_CONT) in (&LCONST.TC_CRED_LINE, &LCONST.TC_CRED_OVER)'
			);

-----------------------------------------------------------------------------------------------------------------
-- Получение индекса в массиве по p_info для %VAR%.V_PRC_SCH_TBL.
-----------------------------------------------------------------------------------------------------------------
function GetIndexPrc ( p_info varchar2(1000), sField in out varchar2(1000) ) return integer is
	str		varchar2(100);
begin
	str := substr(p_info, 21);	-- отрезать "%VAR%.V_PRC_SCH_TBL."

	if str is null then
		return null;
	end if;

	sField := substr(str, 1, instr(str, '[')-1);
	str := replace(substr(str, instr(str, '[') + 1), ']');

	return to_number(str);

exception when others then
	return null;
end;


public procedure set_departs( p_dep ref [DEPART], p_string_dep in out varchar2(32000), p_kind in out ref [KIND_CREDITS], p_dest in out varchar2(32000), p_bCheckKindCred boolean := true )
is
begin
	p_string_dep := null;
	[CSMD].Command(p_dest, 'Combo10.Refresh()');
	if p_dep is not null then
		for (
			select dep (dep.[CODE] :code)
			in ::[DEPART] all
			connect by prior dep.[HIGH] = dep
			start dep = p_dep
		) loop
			p_string_dep := p_string_dep || ';' || dep.code;
		end loop;
		p_string_dep := p_string_dep || ';';
		
		if p_bCheckKindCred and p_kind is not null and coalesce(instr(p_string_dep, p_kind.[DEPART].[CODE]), 1) = 0 then
			--если вид кредита не подходит в к выбранному подразделению то сбрасываем
			p_kind := null;
			[CSMD].Command(p_dest, 'Call Form1.ScriptServerValidate(Nothing, "P_KIND_CREDIT")');
		end if;
	elsif p_bCheckKindCred and p_kind.[DEPART] is not null then
		p_kind := null;
		[CSMD].Command(p_dest, 'Call Form1.ScriptServerValidate(Nothing, "P_KIND_CREDIT")');
	end if;		
end;

procedure disable_when_gen_frame is
begin
	[CSMD].Disable(V_DEST_STR, 'CLIENT');
	[CSMD].Disable(V_DEST_STR, 'FT_CREDIT');
	[CSMD].Disable(V_DEST_STR, 'P_FILIAL');
	[CSMD].Disable(V_DEST_STR, 'P_DEPART');
end;


procedure init_decl(cred_id ref [PRODUCT])
is
begin
	DECL_ON_CRED_REF := null;
	for (select decl(decl : id) in ::[DECL_ON_GET_CRED] where decl.[DECL_PRD] = cred_id)
	loop
		DECL_ON_CRED_REF := decl.id;
		exit;
	end loop;
end;

--v-- BS00133979 Процедуры включения/отключения работы с правилами на ЭФО ---
procedure fl_rule_on is
begin
	[CSMD].Show(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULE_TYPE','V');
	[CSMD].Show(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULES','V');
	vUseFLRule := true;
end;

procedure fl_rule_off is
begin
	[CSMD].Hide(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULE_TYPE','V');
	[CSMD].Hide(V_DEST_STR, 'V_PRC_SCH_TBL.FL_RULES','V');
	vUseFLRule := false;
end;
--^-- BS00133979  ------------------------------------------------------------

procedure set_balloon_payment (
	pCred			[PR_CRED],
	date_begin		date,
	nSummaBalloon	number
)
is
	Oper_Day date;
begin
	-- проверяем значение суммы последнего платежа
	if nSummaBalloon >= pCred.[SUMMA_DOG] then
		pragma error ('Сумма последнего платежа не может быть большей или равной сумме кредита');
	end if;
	
	Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(pCred.[FILIAL]);
	
	if nSummaBalloon is null then
		-- удаляем старое значение
		::[PROPERTY_PROD].[LIB].DelProperty(pCred%id, ::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'));
	elsif nvl(::[PROPERTY_PROD].[LIB].GetPropVal(pCred%id, greatest(Oper_Day, nvl(date_begin, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT')),0) <> nSummaBalloon then
		-- удаляем старое значение
		::[PROPERTY_PROD].[LIB].DelProperty(pCred%id, ::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'));
		-- сохраняем новое
		::[PROPERTY_PROD].[LIB].AddProperty(pCred%id,
											date_begin,
											null,
											::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'),
											nSummaBalloon);	
	end if;
end;

subtype t_tbl_DEBT_COMISS_PRC is ::[PR_CRED].[NEW_DOG_N].t_tbl_DEBT_COMISS_PRC;
subtype t_tbl_VIEW_PRC_SCH is ::[PR_CRED].[NEW_DOG_N].t_tbl_VIEW_PRC_SCH;

procedure on_change_kind_credit(p_cred							ref	[PR_CRED]
								, P_KIND_CREDIT					ref [KIND_CREDITS]
								, P_CALENDAR_NAME					[NAME]
								, DATE_BEGIN			in out		[DATE]
								, DATE_ENDING			in out		[DATE]
								, DECL_ON_CRED_REF		in out	ref	[DECL_ON_GET_CRED]
								, DIC_TYPE_CRED			in out	ref	[TYPES_CRED]
								, FT_CREDIT				in out	ref	[FT_MONEY]
								, NUM_DOG				in out		[PRODUCT_NUM]
								, PERIOD				in out		[DIG_6]
								, P_CALC_TYPE			in out	ref	[OVER_BALANCE]
								, P_DEPART				in out	ref	[DEPART]
								, P_HIGH_LEVEL_CR		in out	ref	[PR_CRED]
								, P_OPER_WAY_OUT		in out	ref	[WAY_KRED]
								, P_OVD_ACCOUNT			in out	ref	[AC_FIN]
								, P_PERIOD_UNIT			in out	ref	[UNITS_OF_TIME]
								, P_PRODUCT				in out	ref	[PRODUCT]
								, V_COMISS_TBL			in out		t_tbl_DEBT_COMISS_PRC
								, V_CREDIT_ARR			in out		[ARR_ARC_SCH_PRC]
								, V_CR_CLASS			in out		[STRING_100]
								, V_DATE_ENDING_MAX		in out		[DATE]
								, V_DATE_GIVE			in out		[DATE]
								, V_DEST_STR			in out		[STRING_32000]
								, V_EARLY_PAY			in out	ref	[EARLY_PAY]
								, V_GEN_AGR				in out	ref	[GEN_AGREEM_FRAME]
								, V_INVOICE				in out		[BOOLEAN]
								, V_IS_FOR_CRED_CARD	in out		[BOOLEAN]
								, V_OPEN_DEP			in out		[BOOLEAN]
								, V_PRC_ADD				in out		[STRING_100]
								, V_PRC_RATE			in out		[NUM_16_8]
								, V_PRC_SCH_TBL			in out		t_tbl_VIEW_PRC_SCH
								, V_PRJ_KIND_CRED		in out	ref	[KIND_PROJECT]
								, V_SCHM_CHANGE			in out		[SHORT1]
								, V_WAY_OUT_CODE		in out		[STRING_2]
								, P_PERIOD_WD			in out		[BOOLEAN])
is
	obj_cred [PR_CRED];
	v_kind_early ref [EARLY_PAY];
	sErr [MEMO];
	sCalendar		varchar2(100);
begin
	if P_KIND_CREDIT is not null then
		kind_cred := P_KIND_CREDIT;
		obj_cred := p_cred;
		
		if kind_cred.[REG_RULES] is null then
			pragma error('У вида кредита не заполнено правило учета.');
		end if;
		
		if kind_cred.[DEF_PERIOD_MS] is not null
		and kind_cred.[DEF_PERIOD_NUM] is not null
		and glHL_PERIOD_NUM is null
		then
			PERIOD := kind_cred.[DEF_PERIOD_NUM];
			P_PERIOD_UNIT := kind_cred.[DEF_PERIOD_MS];
			P_PERIOD_WD := false;
		end if;
		
		P_OPER_WAY_OUT := nvl(kind_cred.[WAY_CRED], P_OPER_WAY_OUT);
		
		-- 1. предварительная очистка COMISS_ARR
		
		::[PR_CRED].[NEW_DOG_LIB].PrcScheme_Clear(obj_cred%id, obj_cred.[COMISS_ARR]);
		
		V_CREDIT_ARR:= null;		-- BFS00029749
		V_PRC_RATE 	:= null;			-- BFS00029749
		V_PRC_ADD 	:= null;			-- BFS00029749
			
		if V_GEN_AGR is null then	-- BFS00030875 Добавлена проверка на отсутствие ген.соглашения (как в операции открытия договора)
			-- BFS00035280
			FT_CREDIT	:= kind_cred.[CURRENCY];
			if FT_CREDIT is null and not(P_HIGH_LEVEL_CR is null) then
				FT_CREDIT	:= P_HIGH_LEVEL_CR.[FT_CREDIT];
			end if;
			if FT_CREDIT is null then
				FT_CREDIT	:= ::[SYSTEM].[VARIABLES].NatCur;
			end if;
		end if;
		
		V_IS_FOR_CRED_CARD := kind_cred.[IS_FOR_CRED_CARD];
		DIC_TYPE_CRED	:= kind_cred.[REG_RULES];
		P_CALC_TYPE		:= kind_cred.[CALC_TYPE];
		V_INVOICE		:= kind_cred.[INVOICE];

		if V_CR_CLASS != 'OVERDRAFTS' and not nvl(V_IS_FOR_CRED_CARD, false) then
			P_OVD_ACCOUNT = P_PRODUCT := null;
			V_OPEN_DEP := false;
		end if;
		
		::[PR_CRED].[NEW_DOG_N].validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR);

		if V_INVOICE then	-- BFS00027595
			V_DATE_ENDING_MAX := null;
			p_cred.[DATE_ENDING_MAX] := null;
		end if;
		::[PR_CRED].[NEW_DOG_N].validate_invoice( V_INVOICE, V_DEST_STR, V_CR_CLASS);
		V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		if V_INVOICE then
			DATE_ENDING		:= null;
			PERIOD			:= null;
			P_PERIOD_UNIT	:= null;
			P_HIGH_LEVEL_CR	:= null;
			P_PERIOD_WD		:= false;
		else
			if PERIOD is null then
				P_PERIOD_UNIT := nvl( kind_cred.[PERIOD_UNIT], ::[UNITS_OF_TIME]([CODE] = 'D'));
			else
				sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(obj_cred%id, obj_cred.[CALENDAR_NAME]);
				DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD);
				if DATE_ENDING is not null and ::[PR_CRED].[L_2].strong_check_hollydays_bool(DATE_ENDING, sErr,obj_cred%class, sCalendar) then
					stdio.put_line_buf(sErr||NL$);
					DATE_ENDING := null;
					PERIOD		:= null;
				end if;			
			end if;
			if kind_cred.[MAX_PERIOD_NUM] is not null and kind_cred.[MAX_PERIOD_MS] is not null then
				V_DATE_ENDING_MAX := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), kind_cred.[MAX_PERIOD_NUM], kind_cred.[MAX_PERIOD_MS], null, null, kind_cred.[PERIOD_WD]);
			end if;
		end if;
		if V_EARLY_PAY.[USE_PRIVATE] then
			begin
				V_EARLY_PAY.[DELETE#AUTO];
			exception
				when others then null;
			end;
		end if;
		v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);	
		V_EARLY_PAY := ::[PR_CRED].[NEW_DOG_LIB].MakeEarlyPeny( nvl(DECL_ON_CRED_REF.[EARLY_PAY], v_kind_early), 'по договору № '||NUM_DOG );
		bRebuildParam4Plan := true;
		
		-- 2. заполнить комиссии с инд. приоритетами из вида кредита
		-- Приоритеты погашения переносить всегда, кроме: (заполнена ссылка на КВУ) AND (договор КВУ не является ?До востребования?).
		--v_copy_priors := not ((not P_HIGH_LEVEL_CR is null) and (not nvl(P_HIGH_LEVEL_CR.[INVOICE], false)));
		if p_kind_credit is not null then
			v_copy_priors := P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false);
			::[PR_CRED].[NEW_DOG_N].Fill_COMISS_ARR(obj_cred.[COMISS_ARR], kind_cred.[COMISS_ARR], P_DEPART, v_copy_priors);	
			::[PR_CRED].[NEW_DOG_N].FillComissTable(obj_cred.[COMISS_ARR], V_COMISS_TBL);			

			-- 3. обработать вариант обновления схемы пользователем
			-- решение пользователя о варианте обновления %% схем
			-- 0 - нажал отмену (валидация должна заблокироваться выше и сюда не зайдет)
			-- 1 - Всё отчистить заполнить из вида кредита (стандартный вариант)
			-- 2 - Всё зачистить взять с КВУ, добавить из вида кредита
			-- 3 - Всё зачистить взять с КВУ, потом из вида кредита затирая КВУ
			-- null - не запрашивали пользователя (это не транш)
			if nvl(V_SCHM_CHANGE, 1) = 1 then -- отрабатываем как обычно по виду кредита
				-- BFS00030875 подтягиваем % схемы (даже если это транш, а у соответствующей линии имеется признак копирования условий в транши)
				::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred);
			elsif V_SCHM_CHANGE > 1 then -- взять с КВУ
				if V_SCHM_CHANGE = 2 then --добавить из вида кредита
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, null, true); --контролируем признак "передавать в транш"
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, true); -- только новые сехмы
				else -- из вида кредита затирая КВУ
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred);
					::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (P_HIGH_LEVEL_CR.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, obj_cred.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, p_cred, null, true, true); -- только новые, контролируем признак "передавать в транш"
				end if;
			end if;

			--v-- BS00133979 После изменения вида кредита проверяем используются ли для него Пл. ставки
			if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR) or [FL_RATE_RULE].[LIB].FindPrcRule(p_cred) then
				fl_rule_on;
			else
				fl_rule_off;
			end if;
			
			if vUseFLRule and obj_cred.[KIND_CREDIT] != P_KIND_CREDIT then
				-- Переинициализируем КЭШ с учетом изменения вида кредита
				[FL_RATE_RULE].[LIB].ProdInit(p_cred, P_KIND_CREDIT);
			end if;
			--^-- BS00133979
			
			::[PR_CRED].[NEW_DOG_N].FillPrcTable(obj_cred.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, true, p_cred, P_KIND_CREDIT, vUseFLRule);
			
			V_PRJ_KIND_CRED := nvl(kind_cred.[TYPE_PROJECT], V_PRJ_KIND_CRED);
		end if;
		
	end if;
	b_Kind_Cred_Changed := false;
end;

function GetDateCalcMop(ArrPp [PARAM_FOR_PL_ARR], ArrPpKind [PARAM_FOR_PL_ARR])
return date
is
dCalc	date;
begin
	dCalc := null;
	for (select pp(pp.[PAY_BEGIN_DATE] : dt)
			 in ArrPp
		  where pp.[OPER] = ::[VID_OPER_DOG]([CODE] = 'ГАШЕНИЕ_МОП'))
	loop
		dCalc := pp.dt;
		exit;
	end loop;
	if dCalc is null then
		for (select pp(pp.[PAY_BEGIN_DATE] : dt)
				 in ArrPpKind
			  where pp.[OPER] = ::[VID_OPER_DOG]([CODE] = 'ГАШЕНИЕ_МОП'))
		loop
			dCalc := pp.dt;
			exit;
		end loop;
	end if;
	return dCalc;
end;
S226_EDIT_LAST (
	@name('Номер договора')                                               NUM_DOG           in [PRODUCT_NUM],
	@name('Клиент')                                                       CLIENT            in [CLIENT_REF],
	@name('Валюта')                                                       FT_CREDIT         in [FT_MONEY_REF],
	@name('Сумма')                                                        SUMMA             in [SUMMA],
	@name('Дата начала')                                                  DATE_BEGIN        in [DATE],
	@name('Дата окончания')                                               DATE_ENDING       in [DATE],
	@name('Тип кредита')                                                  DIC_TYPE_CRED     in [TYPE_CRED_REF],
	@name('Объект кредитования')                                          P_OBJECTS_CRED    in [OBJECT_CRED_ARR],
	@name('Примечания')                                                   NOTES             in [MEMO],
	@name('Плановые операции')                                            P#LIST_PLAN_PAY   in [PLAN_OP],
	@name('Оборачиваемость')                                              P_TURNOVER        in [TIME_PERIOD],
	@name('Филиал')                                                       P_FILIAL          in [BRANCH_REF],
	@name('Срок размещения')                                              PERIOD            in [DIG_6],
	@name('Вид кредита')                                                  P_KIND_CREDIT     in [KIND_CREDITS_REF],
	@name('Сумма / процент')                                              P_FOR_OPEN_PAY    in [SUMMA],
	@name('Признак процента')                                             P_FOR_OPEN_BOOL   in [BOOLEAN],
	@name('Плата за лимит в % годовых')                                   P_FOR_OPEN_YEAR   in [BOOLEAN],
	@name('Сумма гашения')                                                P_SUMMA_PAY       in [SUMMA],
	@name('Номер контракта')                                              P_NUM_CONTR       in [STRING_250],
	@name('Подразделение')                                                P_DEPART          in [DEPART_REF],
	@name('Путь выдачи')                                                  P_OPER_WAY_OUT    in [WAY_KRED_REF],
	@name('Договор продажи векселей')                                     P_ISSUE_VEK       in [NS_OPER_DOG_REF],
	@name('Единица измерения периода')                                    P_PERIOD_UNIT     in [REF_UNIT_OF_TIME],
	@name('Генеральное соглашение')                                       P_G_AGRIMENT      in [GEN_AGREEMEN_REF] default null,
	@name('Продукт, которому предоставлен овердрафт')                     P_PRODUCT         in [A_PROD_REF]       default null,
	@name('Счет, по которому предоставлен овердрафт')                     P_OVD_ACCOUNT     in [AC_FIN_REF]       default null,
	@name('Предельная дата выдач')                                        P_DATE_PAYOUT_LTD in [DATE]             default null,
	@name('Портфель')                                                     P_LOAN_PORT       in [SIM_LOAN_POR_REF] default null,
	@name('Вид сальдирования овердрафта')                                 P_CALC_TYPE       in [OVER_BALANCE_REF] default null,
	@name('Выбор филиала для урегулирования резерва')                     P_FILIAL_RES      in [CASE_BETWEEN_TWO] default null,
	@name('Принадлежность к календарю')                                   P_CALENDAR_NAME   in [NAME]             default null,
	@name('Период - рабочие дни')                                         P_PERIOD_WD       in [BOOLEAN]          default null,
	@name('Оборачиваемость - рабочие дни')                                P_TURNOVER_WD     in [BOOLEAN]          default null,
	@name('Последний платеж')                                             P_BALLOON_PAYMENT in [SUMMA]            default null,
	@name('Алгоритм МОП')                                                 P_MOP_TYPE        in [CR_CALC_MOP_REF]  default null,
	@name('Комплексный договор')                                          P_CO_PROD         in [CO_PROD_REF]      default null,
	@name('Определить характеристики МСФО')                               P_DEF_IFRS        in [BOOLEAN]          default null,
	@name('Количество дней для уплаты комиссии за открытие лимита/счета') P_LMT_DAY_TO_PAY  in [NUM10]            default null
) is

validate is
	-- Пересчет суммы ежемесячного платежа первого периода (для платежей с причислением процентов)
	procedure RecalcPaySumma
	is
		dDATE_BEGIN	date;
	begin
		dDATE_BEGIN := coalesce(V_DATE_GIVE, DATE_BEGIN);
		
		&msg(&METHOD$ || '.Обновление настроек ЕП: Массив периодов #' || to_char(V_FACTOR_MP_ARR));
		
		if (V_FACTOR_MP_ARR is not null) then
			rFirstFactorMPRec := ::[FACTOR_MP].[LIB].GetFirstRec(V_FACTOR_MP_ARR);
		else
			rFirstFactorMPRec := null;
		end if;
		&msg(&METHOD$ || '.Обновление настроек ЕП: Первый период #' || rFirstFactorMPRec%id);
		
		if (rFirstFactorMPRec is not null) then
			V_SUM_PAYMENT := rFirstFactorMPRec.[SUM_PAYMENT];
		else
			V_SUM_PAYMENT := null;
			if (rFactorMPKind is not null) then
				declare
					rFirstFactorMPRecKind	ref [FACTOR_MP_REC];
				begin
					&msg(&METHOD$ || '.RecalcPaySumma: DATE_BEGIN = ' || to_char(dDATE_BEGIN, 'dd/mm/yy'));
					rFirstFactorMPRecKind := ::[FACTOR_MP].[LIB].GetFirstActiveFactor(rFactorMPKind.[FACTOR_MP_ARR], dDATE_BEGIN);
					if (rFirstFactorMPRecKind is not null) then
						V_SUM_PAYMENT := rFirstFactorMPRecKind.[SUM_PAYMENT];
					end if;
				end;
			end if;
		end if;
		&msg(&METHOD$ || '.Обновление настроек ЕП: Сумма платежа первого периода = ' || V_SUM_PAYMENT);
		
		&CSMD_Enabled(V_DEST_STR, 'V_SUM_PAYMENT', 'V', (rFirstFactorMPRec is not null) and (V_FACTOR_MP.[CRED] is not null) and (V_COM_STATUS = &LCONST.STATUS_WAIT_CONF or isEditCompositPart));
	end;
	
	-- Пересчет настроек ежемесячных платежей
	procedure RecalcFactorTune
	is
	begin
		&msg(&METHOD$ || '.Обновление настроек ЕП: Вид кредита #' || P_KIND_CREDIT%id);
		
		V_FACTOR_MP := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT, this);
		&msg(&METHOD$ || '.Обновление настроек ЕП: Настройки ЕП кредита #' || V_FACTOR_MP%id);
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		&msg(&METHOD$ || '.RecalcFactorTune: rFactorMPKind #' || rFactorMPKind%id);
		
		if (V_FACTOR_MP is not null) then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			V_FACTOR_MP_VIEW_ARR := V_FACTOR_MP_ARR;
		else
			V_FACTOR_MP_ARR := null;
			if (rFactorMPKind is not null) then
				V_FACTOR_MP_VIEW_ARR := rFactorMPKind.[FACTOR_MP_ARR];
			else
				V_FACTOR_MP_VIEW_ARR := null;
			end if;
		end if;
		&msg(&METHOD$ || '.RecalcFactorTune: V_FACTOR_MP_ARR #' || to_char(V_FACTOR_MP_ARR));
		&msg(&METHOD$ || '.RecalcFactorTune: V_FACTOR_MP_VIEW_ARR #' || to_char(V_FACTOR_MP_VIEW_ARR));
		
		&CSMD_Enabled(V_DEST_STR, 'V_FACTOR_MP_VIEW_ARR', 'V', V_FACTOR_MP_VIEW_ARR is not null);
		
		RecalcPaySumma();
		::[FACTOR_MP].[LIB].RecalcAnnuityPayments(this, V_FACTOR_MP_ARR);
	end;
	
	-- Определение необходимости автоматического копирования настроек ежемесячных платежей
	function RecalcCopyFPTune
	return boolean
	is
		bAutoCopyMPTune		boolean := false;
		aFactotMP			[FACTOR_MP].[FACTOR_MP_ARR]%type;
		bIsFactorsUsePeriod boolean;
		bIsFactorsUseSum	boolean;
	begin
		V_FACTOR_MP := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT, this);
		if V_FACTOR_MP is not null then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			if ::[FACTOR_MP].[LIB].GetFirstActiveFactor(V_FACTOR_MP_ARR) is not null then
				&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита уже заданы индивидуальные настройки ЕП. Копировать не нужно.');
				return false;
			else
				&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита есть индивидуальные настройки ЕП, но не задан ни один период.');
			end if;
		else
			&msg(&METHOD$ || '.RecalcCopyFPTune: У кредита нет индивидуальных настройки ЕП.');
		end if;
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		if rFactorMPKind is null then
			&msg(&METHOD$ || '.RecalcCopyFPTune: У вида кредита не заданы настройки ЕП. Копировать нечего.');
			return false;
		end if;
		aFactotMP := rFactorMPKind.[FACTOR_MP_ARR];
		bIsFactorsUsePeriod := not ::[FACTOR_MP].[LIB].IsFactorsUsePeriod(aFactotMP);
		bIsFactorsUseSum	:= ::[FACTOR_MP].[LIB].IsFactorsUseSum(aFactotMP);
		&msg(&METHOD$ || '.RecalcCopyFPTune: Настройки ЕП вида кредита используют даты? ' || bool_char(bIsFactorsUsePeriod, 'Да', 'Нет'));
		&msg(&METHOD$ || '.RecalcCopyFPTune: Настройки ЕП вида кредита используют суммы? ' || bool_char(bIsFactorsUseSum, 'Да', 'Нет'));
		if (bIsFactorsUsePeriod)
		and (bIsFactorsUseSum) then
			bAutoCopyMPTune := coalesce	(::[FP_TUNE].[LIB].get_bool_value
											( 'CRED_FACTOR_COPY'
											, ::[FP_TUNE].[LIB].set_canons
												( ::[METACLASS]%class, this%class
												, ::[KIND_CREDITS]%class, P_KIND_CREDIT
												)
											, false
											)
										, false
										);
			&msg(&METHOD$ || '.RecalcCopyFPTune: Для вида кредита указано автоматическое копирование настроек в договор? ' || bool_char(bAutoCopyMPTune, 'Да', 'Нет'));
		else
			bAutoCopyMPTune := true;
		end if;
		
		if (not bAutoCopyMPTune) then
			return false;
		end if;
		
		return true;
	end;
	
	-- Проверка настроек ежемесячных платежей
	procedure CheckMPTune
	is
		dDATE_BEGIN	date;
	begin
		dDATE_BEGIN := coalesce(V_DATE_GIVE, DATE_BEGIN);

		if (bCopyMPTune is null) then
			if P_KIND_CREDIT is not null then
				bCopyMPTune := RecalcCopyFPTune();
			end if;
			&msg(&METHOD$ || '.CheckMPTune: Рассчитанно bCopyMPTune = ' || bool_char(bCopyMPTune, 'Да', 'Нет'));
		else
			&msg(&METHOD$ || '.CheckMPTune: Уже рассчитанное bCopyMPTune = ' || bool_char(bCopyMPTune, 'Да', 'Нет'));
		end if;
		
		if not coalesce(bCopyMPTune, false) then
			return;
		end if;
		
		&msg(&METHOD$ || '.CheckMPTune: DATE_BEGIN = ' || to_char(dDATE_BEGIN, 'dd/mm/yy'));
		&msg(&METHOD$ || '.CheckMPTune: Копирование настроек ЕП из вида кредита...');
		V_FACTOR_MP := this.[MAKE_DEF_MP](P_KIND_CREDIT, dDATE_BEGIN, false);
		bCopyMPTune := false;
		if (V_FACTOR_MP is not null) then
			V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
		end if;
	end;
		
	-- Инициализация настроек ежемесячных платежей
	procedure InitFactorTune
	is
		bKindUseFactor		boolean := false;
		bCredUseFactor		boolean := false;
		bCheckApp			boolean := ::[PR_CRED].[LIB_SERVICE].check_app('1B290033');
	begin
		bCopyMPTune := null;
		&msg(&METHOD$ || '.InitFactorTune: Вид кредита #' || P_KIND_CREDIT%id);
		
		if P_KIND_CREDIT is not null then
			if bCheckApp then
				bKindUseFactor := ::[FACTOR_MP].[LIB].ParamUseFactor(P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			end if;
		end if;
		&msg(&METHOD$ || '.InitFactorTune: Вид кредита содержит параметр планирования ЕП? ' || bool_char(bKindUseFactor, 'Да', 'Нет'));
	
		&CSMD_VisibleS(V_DEST_STR, 'FrameFactor', bKindUseFactor);
		
		if bCheckApp then
			bCredUseFactor := ::[FACTOR_MP].[LIB].ParamUseFactor(V_PARAM_FOR_PLAN_A);
		end if;
		&msg(&METHOD$ || '.InitFactorTune: Кредит содержит параметр планирования ЕП? ' || bool_char(bCredUseFactor, 'Да', 'Нет'));
		
		&CSMD_EnabledS(V_DEST_STR, 'FrameFactor', bCredUseFactor);
		-- Скрыть/отобразить "Планирование -> Сумма погашения" в том числе и для конструктора планирования
		&CSMD_VisibleS(V_DEST_STR, 'FrameSumPay', (not bCredUseFactor and not coalesce(V_USE_PLAN_RULE, false)));
		
		rFactorMPKind := ::[FACTOR_MP].[LIB].Find(P_KIND_CREDIT);
		&msg(&METHOD$ || '.InitFactorTune: Настройки ЕП вида кредита #' || rFactorMPKind%id);
		
		&CSMD_EnabledS(V_DEST_STR, 'BTN_FACTOR_MP_DEFAULT', (rFactorMPKind is not null));
		
		CheckMPTune();
		RecalcFactorTune();
	end;
	
	-- Процедура обновления таблицы параметров планирования
	procedure Update_P4P_Grid is
		FoundP4P	boolean;
	begin
		V_P4P_GRID.delete;
		FoundP4P := false;
		-- BS00135391. Записи в гриде будут упорядочены по дате начала гашения, наименованию операции и ID записи
		for p4p in V_PARAM_FOR_PLAN_A order by p4p.[PAY_BEGIN_DATE], upper(p4p.[OPER].[SYS_NAME]), p4p%id loop
			V_P4P_GRID(nvl(V_P4P_GRID.last, 0) + 1) := p4p;
			if not(V_PARAM_FOR_PLAN_REF is null) and V_PARAM_FOR_PLAN_REF = p4p then
				V_P4P_IDX := V_P4P_GRID.last;
				FoundP4P := true;
			end if;
		end loop;
		if not FoundP4P then
			V_P4P_IDX := V_P4P_GRID.count;
		end if;
		InitFactorTune();
	end;
	
	--процедура снятия savepoint
	procedure deleteSavePoint
	is
	begin
		&debug('.deleteSavePoint: g_needDropPoint '||bool_char(g_needDropPoint)||' g_clickBtnRule '||bool_char(g_clickBtnRule)||' g_clickBtnSeason '||bool_char(g_clickBtnSeason), 0)
		if g_needDropPoint then
			&rb(recalcP4P)
			V_CRED_VBS := this;
			V_NEED_DROP := true;
			
		elsif g_clickBtnSeason then
			&rb(prSeason)
			g_clickBtnSeason := false;
			
		else
			&rb(ChangeRule)
			g_clickBtnRule := false;
		end if;
	end;
	
	procedure presaveThis is
		oCred		[PR_CRED];
	begin
		oCred := this;

		oCred.[SUMMA_DOG]		:= SUMMA;			--	Сумма договора
		oCred.[LIMIT_SALDO]		:= V_LIMIT_SALDO;	--	Лимит задолженности
		oCred.[KIND_CREDIT]		:= P_KIND_CREDIT;	--	Вид кредита
		oCred.[FT_CREDIT]		:= FT_CREDIT;		--	Валюта кредита
		oCred.[DATE_ENDING_MAX]	:= V_DATE_ENDING_MAX;	--	Максимальная дата окончания
		oCred.[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;	--  Кредит верхнего уровня
		oCred.[DATE_GIVE]		:= V_DATE_GIVE;		--	дата выдачи (не обязательно)
		oCred.[DATE_BEGIN]		:= DATE_BEGIN;		--	дата начала договора
		oCred.[DATE_ENDING]		:= DATE_ENDING;		--	дата окончания договора
		oCred.[INVOICE]			:= V_INVOICE;		--	признак "до востребования"
		oCred.[DIC_TYPE_CRED]	:= DIC_TYPE_CRED;	--	правило учета кредитного договора
		oCred.[TURNOVER]		:= P_TURNOVER;		--	максимальный срок выдачи
		oCred.[CALENDAR_NAME]	:= P_CALENDAR_NAME;	--  календарь договора
		-- 	комиссия за открытие лимита/счета
		oCred.[FOR_OPEN_PAY]	:= P_FOR_OPEN_PAY;
		oCred.[FOR_OPEN_BOOL]	:= P_FOR_OPEN_BOOL;
		oCred.[FOR_OPEN_YEAR]	:= P_FOR_OPEN_YEAR;
		oCred.[FOR_OPEN_FN]		:= P_FOR_OPEN_FN;

		set_balloon_payment(this, DATE_BEGIN, P_BALLOON_PAYMENT);	-- размер балуна

		this := oCred;
	end;
	
	-----------------------------------------------------------------------------------------------------------------
	-- Процедура call_make_plan_pr
	-----------------------------------------------------------------------------------------------------------------
	procedure call_make_plan_pr (bCheck boolean default true) is
		bCanCall	boolean	:= true;
		dOperDay	date;
	begin
		if g_needDropPoint then
			&sp(RecalcP4P)
		end if;
		
		presaveThis();
		
		--максимальный срок выдачи в рабочих днях
		P_TURNOVER_WD := nvl(P_TURNOVER_WD, false);
		dOperDay := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(this.[FILIAL]);
		if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(dOperDay, nvl(this.[DATE_BEGIN], dOperDay)),::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD')) = '1', false) <> P_TURNOVER_WD then
			-- сначала удаляем исходное значение в настройке, а затем создаем
			::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'));
			::[PROPERTY_PROD].[LIB].AddProperty(this, this.[DATE_BEGIN], null, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'), P_TURNOVER_WD);	
		end if;
		
		--изменим дату начала сезонности
		::[PR_CRED].[NEW_DOG_LIB].setDateBeginSeason(this, DATE_BEGIN);
		
		-- Проверка на присутствие значения во всех требуемых реквизитах
		-- (Если данную проверку не сделать, то MAKE_DEFAULT_PP может сломаться
		-- с соответствующим сообщением об ошибке)
		if bCheck then
			pragma macro
				( CheckAttr
				, 'bCanCall := bCanCall and (this.[1] is not null)'
				, substitute
				);
		
			&CheckAttr( [SUMMA_DOG] );
			&CheckAttr( [PARAM_FOR_PLAN] );
			&CheckAttr( [KIND_CREDIT] );
			&CheckAttr( [FT_CREDIT] );
			bCanCall := bCanCall and (::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) is not null);

			if not nvl(this.[INVOICE], false) then
				&CheckAttr( [DATE_ENDING] );
			end if;
			bCanCall := bCanCall and (not(this.[DATE_GIVE] is null and this.[DATE_BEGIN] is null));
		else
			bCanCall := true;
		end if;
		
		&debug('.call_make_plan_pr: bCanCall '||bool_char(bCanCall)||' bRebuildPlanRule '||bool_char(bRebuildPlanRule), 0)
		if bCanCall then
			--нужно ли перестроить конструктор?
			if bRebuildPlanRule then
				if V_USE_PLAN_RULE then
					--если по правилам планирования, то нужно перенести конструктор на договор
					::[PR_CRED].[NEW_DOG_LIB].clearPlanRule(this);
					::[PR_CRED].[NEW_DOG_LIB].makePlanRule(this, P_KIND_CREDIT, P_HIGH_LEVEL_CR, coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING);
				else
					::[PR_CRED].[NEW_DOG_LIB].clearPlanRule(this);
				end if;
				bRebuildPlanRule := false;
			end if;
		
			V_PARAM_FOR_PLAN_REF := null;
			::[CRED_INTERFACE].[PRX_PLAN].Cred_MAKE_DEFAULT_PP( this, true, null, coalesce(V_COPY_HL_PP, true), V_USE_PLAN_RULE);
			
			V_PARAM_FOR_PLAN_A := this.[PARAM_FOR_PLAN];
			V_P4P_PLAN_RULE := this.[PARAM_FOR_PLAN];
			Update_P4P_Grid;
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
			' || NL$;	
		end if;
		
		if bRebuildParam4Plan then
			bRebuildParam4Plan := false;
		end if;
		
		g_clickBtnRule := false;
		g_clickBtnSeason := false;
		
	exception when others then
		if g_needDropPoint or g_clickBtnRule or g_clickBtnSeason then
			deleteSavePoint();
			if g_needDropPoint then
				stdio.put_line_buf(sqlerrm);
			else
				raise;
			end if;
			
		elsif not coalesce(g_needDropPoint, false) then
			raise;
		end if;
	end;

	-----------------------------------------------------------------------------------------------------------------
	-- Процедура set_from_gen_agr
	-----------------------------------------------------------------------------------------------------------------
	procedure set_from_gen_agr is
		type T_GEN_AGREEMENT_REC is record(
			 id						ref [GEN_AGREEMENT]
			,agr_status				::[GEN_AGREEMENT].[COM_STATUS]%type
			,agr_to_prod			::[GEN_AGREEMENT].[AGREEM_TO_RPOD]%type
			,agr_to_prod_acc		::[GEN_AGREEMENT].[AGREEM_TO_RPOD].[ACCOUNT]%type
			,agr_ft_money			ref [FT_MONEY]
			,agr_filial				::[GEN_AGREEMENT].[FILIAL]%type
			,agr_depart				::[GEN_AGREEMENT].[DEPART]%type
			,agr_client				::[GEN_AGREEMENT].[AGREEM_TO_RPOD].[CLIENT]%type
			,agr_date_begining		::[GEN_AGREEMENT].[DATE_BEGINING]%type
			,agr_date_begin			::[GEN_AGREEMENT].[DATE_BEGIN]%type
			,agr_overdrafts			::[GEN_AGREEMENT].[OVERDRAFTS]%type
		);
		oRec	T_GEN_AGREEMENT_REC;
	Begin
		if not P_G_AGRIMENT is null then
			select ga(ga
					, ga.[COM_STATUS]
					, ga.[AGREEM_TO_RPOD]
					, ga.[AGREEM_TO_RPOD].[ACCOUNT]
					, ga.[AGREEM_TO_RPOD].[ACCOUNT].[FINTOOL]
					, ga.[FILIAL]
					, ga.[DEPART]
					, ga.[AGREEM_TO_RPOD].[CLIENT]
					, ga.[DATE_BEGINING]
					, ga.[DATE_BEGIN]
					, ga.[OVERDRAFTS]
					)
				in ::[GEN_AGREEMENT]
			where ga = P_G_AGRIMENT
			into oRec%rowtype;
		
			if nvl(oRec.agr_status, &LCONST.STATUS_CLOSE) != &LCONST.STATUS_WORK then
				pragma error('Ген. соглашение на овердрафт не находится в состоянии "Работает"');
			end if;
			P_PRODUCT		:= oRec.agr_to_prod;
			P_OVD_ACCOUNT	:= oRec.agr_to_prod_acc;
			FT_CREDIT		:= nvl(oRec.agr_ft_money,FT_CREDIT);
			P_FILIAL		:= nvl(oRec.agr_filial, P_FILIAL);
			P_DEPART		:= nvl(oRec.agr_depart, P_DEPART);
			CLIENT			:= oRec.agr_client;
			DATE_BEGIN		:= nvl(oRec.agr_date_begining, oRec.agr_date_begin);
			V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
			V_CLIENT_REQ.[1].[1] := CLIENT;
			V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;
			
			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
			
			for(
				select over(over.[DATE_ENDING] dEnd)	
					in oRec.agr_overdrafts
				 where over != this
				 order by over.[DATE_ENDING] desc
			)loop
				DATE_BEGIN := over.dEnd + 1;
				exit;
			end loop;
			DATE_ENDING := DATE_BEGIN + 29;
			for(
				select over(over.[COM_STATUS] 	COM_STATUS
						   ,over.[DATE_CLOSE]	DATE_CLOSE
						   ,over.[ACCOUNT]		ACCOUNT
						   ,over.[COMISS_ARR]	COMISS_ARR
						   )
			 		in oRec.agr_overdrafts
			 	 where over != this
				 order by over.[DATE_BEGIN] desc
			)loop
				if (over.COM_STATUS != &LCONST.STATUS_CLOSE and over.DATE_CLOSE is null) then			
					P_ACCOUNT			:= nvl(P_ACCOUNT, over.ACCOUNT);
				end if;

				declare
					rScheme ref [PRC_SCHEME];
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				begin
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							this.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.COMISS_ARR, Scheme_Name),
							Scheme_Name);
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					V_CREDIT_ARR := rScheme.[LIST_SCH_PRC];
					V_PRC_RATE	 := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
					rScheme.[P_PRIVATE]	:= false; -- снимаем признак индивидуального использования

					Scheme_Name := &LCONST.VD_PRC_PENY;
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							this.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.COMISS_ARR, Scheme_Name),
							Scheme_Name);

					Scheme_Name := &LCONST.VD_CREDIT_PENY;
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(
							this.[COMISS_ARR],
							::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(over.COMISS_ARR, Scheme_Name),
							Scheme_Name);
				end;
				exit;
			end loop;
			::[PR_CRED].[NEW_DOG_N].validate_gen_arg(P_G_AGRIMENT, V_DEST_STR);
		end if;
	End;

	----------------------------------------------------------------------------------
	-- Процедура Check_Res_Filial: проверяет необходимость отображения контрола P_FILIAL_RES на ЭФО
	----------------------------------------------------------------------------------
	procedure Check_Res_Filial
	is
		rLoanPort 		ref [SIM_LOAN_PORT];
		nTuneReservLine	number;
		bInvoice		boolean;
		bIsLine 		boolean;
		type T_KIND_CREDIT_REC is record
		(
			 for_cred_card		varchar2(1)
			, REG_RULES			::[KIND_CREDITS].[REG_RULES]%type
			, LINE_TRANSH		::[KIND_CREDITS].[LINE_TRANSH]%type
			, for_cred_card_Hl	varchar2(1)
		);
		oRec T_KIND_CREDIT_REC;
	begin
		-- проверим: включен ли договор в ПОС с признаком урегулировать резерв по портфелю
		rLoanPort := ::[SIM_LOAN_PORT].[LIB].GetPortByCred(this, Oper_Day, '1');
		oRec := null;
		
		select c(c.[KIND_CREDIT].[IS_FOR_CRED_CARD] 					
				, c.[KIND_CREDIT].[REG_RULES] 							
				, c.[KIND_CREDIT].[LINE_TRANSH] 							
				, c.[HIGH_LEVEL_CR].[KIND_CREDIT].[IS_FOR_CRED_CARD])
		in ::[PR_CRED] all
		where c%id = this%id
		into oRec%rowtype;
		
		nTuneReservLine := nvl(::[FP_TUNE].[LIB].get_num_value('CR_REZ_LN',::[FP_TUNE].[LIB].set_canons('DEPART',[DEPART])),0);
		if [HIGH_LEVEL_CR] is null then
			bInvoice := (nvl([INVOICE], false) or nvl(char_bool(oRec.for_cred_card), false));
		else
			bInvoice := (nvl([HIGH_LEVEL_CR].[INVOICE], false) or nvl(char_bool(oRec.for_cred_card_hl), false));
		end if;
		bIsLine := ::[PR_CRED].[L_2].Is_Line_Rules(this%class, oRec.REG_RULES, oRec.LINE_TRANSH);
				
		if rLoanPort is not null then
			-- резерв формируем по портфелю, берем настройку и признак с ПОСа
			Gl_rDepart_Res := ::[PRODUCT].[L_RES].get_tune_res_fil(rLoanPort.[FILIAL], 'SIM_LOAN_PORT', Oper_Day);		
		else
			Gl_rDepart_Res := ::[PRODUCT].[L_RES].get_tune_res_fil(P_FILIAL, this%class, Oper_Day);
		end if;
		
		if Gl_rDepart_Res is not null then
			[CSMD].Show(V_DEST_STR, 'P_FILIAL_RES');
			[CSMD].Command(V_DEST_STR, NL$||'ResFilial1.Caption = "Филиал договора ('||replace(P_FILIAL.[CODE],'"','""')||')"'||NL$);
			[CSMD].Command(V_DEST_STR, NL$||'ResFilial2.Caption = "Филиал из настройки RES_IN_OTHER_FILIAL ('||replace(Gl_rDepart_Res.[FILIAL].[CODE],'"','""')||')"'||NL$);
			
			if rLoanPort is not null then
				-- признак берется с портфеля, и он не доступен для редактирования
				if ::[PRODUCT].[L_RES].get_res_fil_sign(rLoanPort.[RES_OTHER_FIL]) then
					P_FILIAL_RES.[0] := 2;
				else
					P_FILIAL_RES.[0] := 1;
				end if;
				[CSMD].Disable(V_DEST_STR, 'P_FILIAL_RES');
			else
				if P_HIGH_LEVEL_CR is not null and  nTuneReservLine = 1 then
					-- берем признак с КВУ
					if ::[PRODUCT].[L_RES].get_res_fil_sign(P_HIGH_LEVEL_CR.[RES_OTHER_FIL]) then
						P_FILIAL_RES.[0] := 2;
					else
						P_FILIAL_RES.[0] := 1;
					end if;
				else
					if ::[PRODUCT].[L_RES].get_res_fil_sign(this.[RES_OTHER_FIL]) then
						P_FILIAL_RES.[0] := 2;
					else
						P_FILIAL_RES.[0] := 1;
					end if;
				end if;
				-- проверим доступен ли признак для редактирования
				if this.[COM_STATUS] in (::[COM_STATUS_PRD]([CODE] = 'WAIT_CONF'), ::[COM_STATUS_PRD]([CODE] = 'WORK'), ::[COM_STATUS_PRD]([CODE] = 'LOCK'))
					and (P_HIGH_LEVEL_CR is null or nTuneReservLine != 1 or bInvoice)
					and (not bIsLine or bInvoice or nTuneReservLine !=0)
				then
					-- признак доступен для редактирования только для договоров в статусе: WAIT_CONF, WORK, LOCK
					-- и если договор не является траншем при действующей настройке CR_REZ_LN
					-- и не является КВУ при не действующей настройке CR_REZ_LN
					[CSMD].Enable(V_DEST_STR, 'P_FILIAL_RES');
				else
					[CSMD].Disable(V_DEST_STR, 'P_FILIAL_RES');
				end if;
			end if;
		else
			[CSMD].Hide(V_DEST_STR, 'P_FILIAL_RES');
			-- проверим соответствие значения признака и настройки RES_IN_OTHER_FILIAL (только для договоре)
			if ::[PRODUCT].[L_RES].get_res_fil_sign(this.[RES_OTHER_FIL]) and rLoanPort is null then
				[CSMD].Command(V_DEST_STR, NL$||'msgbox "На договоре установлен признак Формировать доходы/расходы при урегулировании резерва в другом филиале, но не действует настройка RES_IN_OTHER_FILIAL!"'||NL$);
			end if;
		end if;
	end;

	function ISBalloon return boolean is
	begin
		if (P_KIND_CREDIT is not null and P_KIND_CREDIT.[BALLOON_PAYMENT]) or (P_KIND_CREDIT is null and DECL_ON_CRED_REF.[KIND_CREDIT].[BALLOON_PAYMENT]) then
			&debug('FUNCTION ISBalloon returned TRUE',0)
			return true;
		else
			&debug('FUNCTION ISBalloon returned FALSE',0)
			return false;
		end if;
	end;

	procedure balloon_validate is
	begin
		if ISBalloon then
			[CSMD].Command(V_DEST_STR, 'balloon_payment.Visible = True');
			[CSMD].Command(V_DEST_STR, 'balloon_label.Visible = True');
		else
			[CSMD].Command(V_DEST_STR, 'balloon_payment.Visible = False');
			[CSMD].Command(V_DEST_STR, 'balloon_label.Visible = False');
			P_BALLOON_PAYMENT := NULL;
		end if;
	end;
	
	procedure mop_validate is
	begin
		if this.[COM_STATUS] != &LCONST.STATUS_WAIT_CONF then
			P_MOP_TYPE := ::[CR_CALC_HIST].[LIB].fGetMop(this, Oper_day);
			[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = False');
			return;
		end if;
		if p_message = 'DEFAULT' then
			P_MOP_TYPE := ::[CR_CALC_HIST].[LIB].fGetMop(this, Oper_day);
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if (P_MOP_TYPE is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
				if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = true');
				else
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = False');
				end if;

			else
				[CSMD].Command(V_DEST_STR, 'FrameMOP.Visible = False');
				bMop := false;
			end if;
		elsif p_message = 'VALIDATE' then
			if p_info = 'TarifMOP' then
				stdio.put_line_buf('<% PLPCALL %THIS%.[SET_IND_MOP]() %>');
			elsif p_info = 'P_KIND_CREDIT' then
				-- если пользователь выбрал новый вид кредита, проверять наличие алгоритма МОП только на этом виде кредита
				bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(null, P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				if (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = true');
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Visible = true');
					P_MOP_TYPE := P_KIND_CREDIT.[MOP_TYPE];

				else
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = false');
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Visible = false');
					P_MOP_TYPE := null;
					bMop := false;
					
				end if;
			end if;
		end if;
	end;
	
	-- Процедура для обновления реквизитов клиента.
	procedure setClient is
	begin
		this.[CLIENT]	:= CLIENT;
		this.[CLIENT_REQ] := null;
		V_CLIENT_REQ	:= this.[GET_CUST_PROPS];
		
		if V_CLIENT_REQ.[1].[1] is null then
			V_CLIENT_REQ.[1].[1] := CLIENT;
		end if;
	end;

	--- переменные ------------------
	i				integer;
	sField			varchar2(100);
	fPenMainRate	number;
	fPenPrcRate		number;
	rDECL_EARLY_P	ref [DECL_EARLY_P];
	v_kind_early 	ref [EARLY_PAY];
	
	reqs_cl_tmp	[PR_CRED].[CLIENT_REQ]%type;
	
	prc_date_beg_tune number;
	m_date date;
	sADDS varchar(300);
	sErrMess varchar(2000);
	nIdxCmsRow 		number; --Индекс для массива V_COMISS_TBL
	rTypeDebt		ref [TYPE_DEBT];
	nOldPrior		number;
	sCalendar		varchar2(100);
-----------------------------------------------------------------------------------------------------------------
-- ТЕЛО ВАЛИДАТОРА
-----------------------------------------------------------------------------------------------------------------
begin
	&debug('.validate: p_message '||p_message||' p_info '||p_info, 0)
-- DEFAULT
	if p_message = 'DEFAULT' then
		::[PR_CRED].[NEW_DOG_N].FillPrc_Arr(Prc_Arr);
		prc_date_beg_tune := nvl( ::[FP_TUNE].[LIB].get_num_value('PRC_DATE_BEG'), 0);
		-- Инициализация параметров и переменных
		NUM_DOG 			:= this.[NUM_DOG];
		CLIENT 				:= this.[CLIENT];
		FT_CREDIT 			:= this.[FT_CREDIT];
		SUMMA 				:= this.[SUMMA_DOG];
		DATE_BEGIN 			:= this.[DATE_BEGIN];
		DATE_ENDING 		:= this.[DATE_ENDING];
		DIC_TYPE_CRED 		:= this.[DIC_TYPE_CRED];
		P_OBJECTS_CRED 		:= this.[OBJECTS_CRED];
		NOTES 				:= this.[NOTES];
		P#LIST_PLAN_PAY 	:= this.[LIST_PLAN_PAY];
		P_TURNOVER 			:= this.[TURNOVER];
		P_FILIAL 			:= this.[FILIAL];
		P_KIND_CREDIT 		:= this.[KIND_CREDIT];
		P_FOR_OPEN_PAY 		:= this.[FOR_OPEN_PAY];
		P_FOR_OPEN_BOOL 	:= this.[FOR_OPEN_BOOL];
		P_FOR_OPEN_YEAR 	:= this.[FOR_OPEN_YEAR];
		P_SUMMA_PAY 		:= this.[SUMMA_PAY];
		P_NUM_CONTR 		:= this.[NUM_CONTR];
		P_DEPART 			:= this.[DEPART];
		P_OPER_WAY_OUT 		:= this.[OPER_WAY_OUT];
		P_ISSUE_VEK 		:= this.[ISSUE_VEK];
		P_PERIOD_UNIT 		:= this.[PERIOD_UNIT];
		P_PRODUCT 			:= this.[OVER_ON_PROD];
		P_DATE_PAYOUT_LTD 	:= this.[DATE_PAYOUT_LTD];
		P_CALENDAR_NAME 	:= this.[CALENDAR_NAME];
		V_GEN_AGR 			:= this.[GEN_AGR];
		V_LIMIT_SALDO 		:= this.[LIMIT_SALDO];
		V_DATE_GIVE 		:= this.[DATE_GIVE];
		P_HIGH_LEVEL_CR 	:= this.[HIGH_LEVEL_CR];
		V_CLIENT_REQ 		:= this.[CLIENT_REQ];
		if V_CLIENT_REQ.[1].[1] is null
			then V_CLIENT_REQ.[1].[1] := CLIENT;
		end if;
		
		--Считать Количество дней для уплаты комиссии из продуктового свойства
		P_LMT_DAY_TO_PAY := to_number(::[PROPERTY_PROD].[LIB].GetPropVal(
			 p_prod == this
			,p_on_date == DATE_BEGIN
			,p_kind_prop == &propLimitDayToPay)
		);
		--
		V_ONE_DAY 			:= this.[ONE_DAY];
		V_INVOICE 			:= this.[INVOICE];
		V_COM_STATUS 		:= this.[COM_STATUS];
		P_FOR_OPEN_FN 		:= this.[FOR_OPEN_FN];
		V_PARAM_FOR_PLAN_A 	:= this.[PARAM_FOR_PLAN];
		V_LIST_PLAN_PAY_ARR := this.[LIST_PLAN_PAY];
		V_COPY_TO_TRANSH 	:= this.[COPY_TO_TRANSH];
		V_OKONH 			:= this.[OKOHX];
		V_DEBTORS 			:= this.[DEBTORS];
		V_EARLY_PAY 		:= this.[EARLY_PAY];
		V_PROPERTIES 		:= this.[PROPERTIES];
		V_DATE_ENDING_MAX 	:= this.[DATE_ENDING_MAX];
		P_ACCOUNT 			:= this.[ACCOUNT];
		V_KIND_CREDIT 		:= this.[KIND_CREDIT];
		V_MAX_LIMIT_SALDO 	:= this.[MAX_LIMIT_SALDO];
		V_LIST_EXP_PAY_ARR	:= this.[LIST_PLAN_PAY];
		-- Конец инициализации

		V_THIS	:= this;
		
		dateHist := DATE_BEGIN;
		V_CAN_PRC_SCH := 9;

		-- vv Редактирование составного продукта --
		bComposit := ::[TUNE_COMPOSITE].[LIB].IsComposit(rCred == this.[HIGH_LEVEL_CR]);

		if p_info is null then
			if ::[TUNE_COMPOSITE].[LIB].IsComposit(rCred == this) then
				pragma error('Ошибка! Операция не предназначена для исполнения над составным продуктом.');
			end if;
			if bComposit then
				if nvl(this.[COM_STATUS], &LCONST.STATUS_WAIT_CONF) = &LCONST.STATUS_WAIT_CONF then
					pragma error('Ошибка! Редактирование частей составного продукта до подписания возможно только операцией "Редактирование составного продукта".');
				end if;
			end if;
		end if;
		-- ^^ Редактирование составного продукта --

		-- флаг создания составного продукта
		bCreateComposit := bComposit and nvl(::[PR_CRED].[EDIT_COMPOSIT].V_BUS_PROCESS = ::[BUS_PROCESS]([CODE]='РЕГИСТРАЦИЯ'), false);

		[CSMD].Init_Form(V_DEST_STR, &METHOD$CLASS, &METHOD$SNAME);

		Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
		
		executor.set_context('CRED_BUS_PROC', &cBP_EDIT%id);
		
		V_DO_FACTORING := coalesce(::[PROPERTY_PROD].[LIB].GetPropVal(coalesce(this.[HIGH_LEVEL_CR], this), greatest(Oper_Day, coalesce(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING')), true);
		
		if P_FILIAL != V_CLIENT_REQ.[1].[2].[FILIAL] then
			[CSMD].Command(V_DEST_STR, 'label38.Caption = "Расчетный счет открыт в филиале ' || V_CLIENT_REQ.[1].[2].[FILIAL].[CODE] || '"');			
			[CSMD].Command(V_DEST_STR, 'label38.Visible = true');
		else
			[CSMD].Command(V_DEST_STR, 'label38.Visible = false');
		end if;
		
		if this.[HIGH_LEVEL_CR] is not null then
			[CSMD].command( V_DEST_STR, 'Factoring.Enabled = false');
		end if;
		
		bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
		
		if bMop and this.[COM_STATUS] != ::[COM_STATUS_PRD]([CODE]='WAIT_CONF') then
			[CSMD].command( V_DEST_STR, 'ButtonDefaultCreate.Enabled = false');
			
			for --если есть ПО Гашения МОП, то запретим перепланирование, т.к. собьется дата следующего гашения МОП
			( select x(1)
			  in [LIST_PLAN_PAY]
			  where x.[OPER] = ::[VID_OPER_DOG]([CODE]='ГАШЕНИЕ_МОП')
			)
			loop
				[CSMD].command( V_DEST_STR, 'Button10.Enabled = false');
				exit;
			end loop;			
		end if;
		
		for oUID in ::[UID] all where oUID.[PRODUCT]%id = this%id and rownum<2 loop
			V_UID%id:=oUID%id;
		end loop;
		
		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290076', 'v_calendar,P_CALENDAR_NAME');
		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290055', 'SET_TUNE_LIMIT');
		&HIDE_APP_CONTROLS(V_DEST_STR, '1B290033', 'FrameFactor');

		if nvl(::[FP_TUNE].[LIB].get_bool_value('CHECK_PSK'), false) then
			[CSMD].command( V_DEST_STR, 'ButtonCredCategory.Visible = true');
		else
			[CSMD].command( V_DEST_STR, 'ButtonCredCategory.Visible = false');
		end if;
		
		if ::[PR_CRED].[NEW_DOG_N].check_User_Access then
			[CSMD].Enable(V_DEST_STR, 'V_TO_BKI', 'V');
		else
			[CSMD].Disable(V_DEST_STR, 'V_TO_BKI', 'V');
		end if;

		if isNUK is null then
			isNUK := nvl(::[FP_TUNE].[LIB].get_bool_value('RT_NUK_ON'), false);
		end if;
		
		if not isNUK  then
			[CSMD].Command(V_DEST_STR, 'Frame_Restr.VISIBLE = true');		
			[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.VISIBLE = false');	
			
			if [COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
				[CSMD].command( V_DEST_STR, 'Frame_Restr.Enabled = true');
			else
				[CSMD].command( V_DEST_STR, 'Frame_Restr.Enabled = false');
			end if;
		else			
			[CSMD].Command(V_DEST_STR, 'Frame_Restr.VISIBLE = false');			
			[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.VISIBLE = true');
			if [COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
				[CSMD].Command(V_DEST_STR, 'Array14.Enabled = true');
				[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.Enabled = true');
			else
				[CSMD].Command(V_DEST_STR, 'Array14.Enabled = false');
				[CSMD].Command(V_DEST_STR, 'FrameRestrNUK.Enabled = false');
			end if;
		end if;
		
		V_CHANGE_RULE := null;	
		
		if this%class = 'KRED_CORP' then
			declare
				cr_corp	ref [KRED_CORP];
			begin
				cr_corp%id := this%id;
				gen_frame := null;
				for (select g(g : id) in ::[GEN_AGREEM_FRAME] all where g.[CRED_LINES] = cr_corp%collection)
				loop
					gen_frame := g.id;
					disable_when_gen_frame;
				end loop;
			end;
		end if;
		V_CR_CLASS := this%class;
		if V_CR_CLASS = 'KRED_PERS' then
			CL_CLASS := 'CL_PRIV';
		elsif V_CR_CLASS = 'KRED_CORP' then
			CL_CLASS := 'CL_ORG';
		elsif V_CR_CLASS = 'KRED_BANK' then
			CL_CLASS := 'CL_BANK_N CL_PART';
		elsif V_CR_CLASS = 'OVERDRAFTS' then
			CL_CLASS := 'CL_ORG CL_PRIV';
			P_G_AGRIMENT:= this%parent;
			P_CALC_TYPE := this->(::[OVERDRAFTS])[CALC_TYPE];
			::[PR_CRED].[NEW_DOG_N].validate_gen_arg( P_G_AGRIMENT, V_DEST_STR);
		end if;
		if P_PRODUCT is not null then
			P_OVD_ACCOUNT := P_PRODUCT.[GET_ACC_PROD](::[TIP_ACC]([COD]='MAIN_PROD_ACCOUNT'));
		end if;
		v_old_kind := P_KIND_CREDIT;
		V_ADD_CLASS := null;
		pragma IF_DEF (FACTORING);
			if ::[CRED_INTERFACE].[PRX_FACTORING].Get_v_redeem_unit_arr is not null
				or nvl(::[CRED_INTERFACE].[PRX_FACTORING].IsCredBuySale (this),false)
			then
				V_ADD_CLASS := 'FACTORING';
			end if;
		pragma END_IF;

		if V_CR_CLASS = 'OVERDRAFTS' and V_ADD_CLASS is null then
			V_ADD_CLASS := 'OVERDRAFTS';
		end if;
		
		if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then
			rPsOrg := CLIENT->(::[CL_CORP])[FORMA].[PS];
		else
			rPsOrg := null;	-- BFS00027399
		end if;

		V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		::[CRED_INTERFACE].[PRX_ZALOG].Set_ref_prod(this);
		executor.set_context('ZALOG_PROD', this%id);
		V_PL_CRED	:= nvl(P_HIGH_LEVEL_CR%id, this%id);

        -- Параметры планирования
		V_PLAN_ALL := true;				-- Крыжик "планировать все"
		V_PARAM_FOR_PLAN_REF := null;   -- Ссылка на текущий параметр планирования
		V_P4P_IDX := 0;					-- Индекс текущего параметра планирования в таблице параметров
		Update_P4P_Grid;
		V_DEST_STR := V_DEST_STR || NL$ ||
		'
			GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
		' || NL$;

		V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(SUMMA, FT_CREDIT.[CUR_SHORT]);
		if P_HIGH_LEVEL_CR is not null  then
			V_LIMIT_CR	:= ::[PR_CRED].[L].GetSumDebt(P_HIGH_LEVEL_CR, &LCONST.VD_LIMIT, Oper_Day);
		end if;
		V_RISK_GROUP%id := [L].GetInfo (this, 'ГРУППА_РИСКА');

		declare
			rScheme 	ref [PRC_SCHEME];
			rSchemeHLC	ref [PRC_SCHEME];
			Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
		begin
			rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
			if not (this.[HIGH_LEVEL_CR] is null) then
				rSchemeHLC := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[HIGH_LEVEL_CR].[COMISS_ARR], Scheme_Name);
			end if;
			if rScheme is null then
				V_PRC_RATE := null;
				V_CREDIT_ARR := null;
			else
				V_CREDIT_ARR := rScheme.[LIST_SCH_PRC];
				V_PRC_RATE := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
			end if;

			-- Если у транша и у линии одна процентная схема, то
			-- запретить редактировать ставку на первой закладке
			if not(rSchemeHLC is null) and not(rScheme is null) and rScheme = rSchemeHLC
			then [CSMD].Disable	(V_DEST_STR, 'V_PRC_RATE','V');
			else [CSMD].Enable	(V_DEST_STR, 'V_PRC_RATE','V');
			end if;

		end;

		P_PERIOD_UNIT := nvl(P_PERIOD_UNIT,::[UNITS_OF_TIME]([CODE] = 'D'));

		P_PERIOD_WD := nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE')) = '1', false);	

		P_TURNOVER_WD := nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD')) = '1', false);	

		P_BALLOON_PAYMENT := ::[PROPERTY_PROD].[LIB].GetPropVal(this,greatest(Oper_Day,nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'BALLOON_PAYMENT'));

		if P_TURNOVER.UNIT_INTERVALS = ::[UNITS_OF_TIME]([CODE]='D') then
			[CSMD].Enable(V_DEST_STR, 'P_TURNOVER_WD');
		else
			[CSMD].Disable(V_DEST_STR, 'P_TURNOVER_WD');
			P_TURNOVER_WD := false;
		end if;

		if P_PERIOD_UNIT = ::[UNITS_OF_TIME]([CODE]='D') then
			[CSMD].Enable(V_DEST_STR, 'P_PERIOD_WD');
		else
			[CSMD].Disable(V_DEST_STR, 'P_PERIOD_WD');
			P_PERIOD_WD := false;
		end if;
		V_CALENDAR := this.[CALENDAR_NAME];
		sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(this, V_CALENDAR%id);
		::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
		
		if &IsCredLine then
			if V_COPY_TO_TRANSH then
				[CSMD].Disable(V_DEST_STR, 'V_TRANSH_PERIOD_NUM', 'V');
			end if;
			V_TRANSH_PERIOD_UNIT := P_PERIOD_UNIT;
			V_TRANSH_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(this
																	, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day))
																	, propTRANSH_PERIOD_NUM
																	);
			if V_TRANSH_PERIOD_NUM is not null then
				[CSMD].Disable(V_DEST_STR, 'V_COPY_TO_TRANSH', 'V');
			end if;
		end if;
		
		if P_HIGH_LEVEL_CR is not null then
			glHL_PERIOD_UNIT:= null;
			glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																, [DATE_BEGIN]
																, propTRANSH_PERIOD_NUM
																);
			if glHL_PERIOD_NUM is not null then
				glHL_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
			end if;
		end if;

		-- Настройка по сдвигу гашений
		nShift_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_FIRST_PLAN', this%class, this.[DEPART],
			null, this.[PRJ_KIND_CRED], this.[KIND_CREDIT]).[NUMBER_VALUE];
		nAdd_First := ::[CRED_INTERFACE].[PRX_PLAN].PFP_GetPlanTune('SHIFT_PLAN_CRED', this%class, this.[DEPART],
			null, this.[PRJ_KIND_CRED], this.[KIND_CREDIT]).[NUMBER_VALUE];


		V_TO_BKI := ::[PR_CRED].[NEW_DOG_N].into_bki(this, Oper_Day);	-- <Akil> -- разрешение на предоставление информации в БКИ
		
		V_INVOICE_COND.delete;
		cnt := 1;
		for
		( select x(x.[DATE_BEGIN]	: DATE_BEGIN
				 , x.[DATE_END]		: DATE_END
				 , x.[SUMMA]		: SUMMA
				 )
		  in [LIST_PLAN_PAY]
		  where x.[OPER] = &LCONST.VO_INVOICE_CRED
		  order by x.[DATE_BEGIN], x%id		-- BS00135391. Записи в гриде будут упорядочены по дате начала и ID записи
		)
		loop
			V_INVOICE_COND(cnt).[DELEY] 		:= true;
			V_INVOICE_COND(cnt).[PLAN_PERCENT] 	:= false;
			V_INVOICE_COND(cnt).[PAY_BEGIN_DATE]:= x.[DATE_BEGIN];
			V_INVOICE_COND(cnt).[END_DATE] 		:= x.[DATE_END];
			V_INVOICE_COND(cnt).[START_SUMMA] 	:= x.[SUMMA];
			
			cnt := cnt + 1;
		end loop;
		if P_FOR_OPEN_FN is null then
			[FOR_OPEN_FN] = P_FOR_OPEN_FN := FT_CREDIT;
		end if;
		V_PRJ_KIND_CRED		:= [PRJ_KIND_CRED];
		V_IS_FOR_CRED_CARD	:= [KIND_CREDIT].[IS_FOR_CRED_CARD];
		
		V_OPEN_DEP := false;
		bDisableOverOnProd := false;
		declare
			cl_parent	varchar2(16);
			rStatus		ref [COM_STATUS_PRD];
		begin
			for(
				select p(p%class cl, p.[COM_STATUS] st)
					in ::[PRODUCT] all
					where p = [OVER_ON_PROD]
			)loop
				cl_parent := p.cl;
				rStatus	  := p.st;
			end loop;
			
			if cl_parent in ('DEPN', 'DEPOSIT_MULT', 'DEPOSIT_PRIV', 'DEPOSIT_ORG')  and rStatus = &LCONST.STATUS_WAIT_CONF then
				[CSMD].Disable(V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Disable(V_DEST_STR, 'P_PRODUCT');
				[CSMD].Disable(V_DEST_STR, 'V_OPEN_DEP', 'V');
				bDisableOverOnProd := true;
			end if;
		end;
		init_decl(this);
		::[PR_CRED].[NEW_DOG_N].validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR, true);
		
		if V_INVOICE then	-- BFS00027595
			V_DATE_ENDING_MAX := null;
			[DATE_ENDING_MAX] := null;
		end if;
		::[PR_CRED].[NEW_DOG_N].validate_invoice(V_INVOICE, V_DEST_STR, V_CR_CLASS);
		if bComposit then
				::[PR_CRED].[NEW_DOG_N].validate_status(&LCONST.STATUS_WORK, V_DEST_STR); -- всегда блокируем, как буд-то работает
				if p_info = '%PLPCALL%' then
					bIgnorCheck := true;
					isEditCompositPart:=true;
					[CSMD].Enable(V_DEST_STR, 'V_DATE_GIVE', 'V');
					[CSMD].Enable(V_DEST_STR, 'P_BALLOON_PAYMENT', 'P');
					[CSMD].Enable(V_DEST_STR, 'P_OPER_WAY_OUT', 'P');
					[CSMD].Hide(V_DEST_STR, 'P_SIGN_UP', 'V');
					[CSMD].Hide(V_DEST_STR, 'P_OPEN_ACC', 'V');
					[CSMD].Hide(V_DEST_STR, 'P_DEF_IFRS', 'P');
					[CSMD].Hide(V_DEST_STR, 'DECL_ON_CRED_REF', 'V');
					[CSMD].Hide(V_DEST_STR, 'P_DATE_PAYOUT_LTD', 'P');
					[CSMD].Hide(V_DEST_STR, 'V_DATE_ENDING_MAX', 'V');
					[CSMD].Hide(V_DEST_STR, 'V_PROPERTIES', 'V');
					[CSMD].Hide(V_DEST_STR, 'V_DEBTORS', 'V');
					[CSMD].Hide(V_DEST_STR, 'V_CALENDAR', 'V');
					[CSMD].Hide(V_DEST_STR, 'P_CALENDAR_NAME', 'P');
					[CSMD].Hide(V_DEST_STR, 'V_ONE_DAY', 'V');
					[CSMD].Hide(V_DEST_STR, 'V_LIMIT_CR', 'V');
					[CSMD].Disable(V_DEST_STR, 'P_OBJECTS_CRED', 'P');
					[CSMD].Disable(V_DEST_STR, 'V_OBJ_CRED', 'V');
					[CSMD].Command(V_DEST_STR, 'Form1.ScriptShowTab Form5, False'); -- Условия востребования
					[CSMD].Command(V_DEST_STR, 'Frame13.Visible = false'); -- Плата за открытие лимита
					[CSMD].Command(V_DEST_STR, 'Array17.Visible = false'); -- БОК
					[CSMD].Command(V_DEST_STR, 'Button13.Visible = false'); -- "+"
					[CSMD].Command(V_DEST_STR, 'Frame18.Enabled = false'); -- Реквизиты клиента
					[CSMD].Command(V_DEST_STR, 'Frame17.Visible = false'); -- Обеспечение
				end if;
				[CSMD].Command(V_DEST_STR, 'Frame14.Enabled = false'); -- БКИ
				[CSMD].Command(V_DEST_STR, 'Array11.Visible = false'); -- БКИ
				[CSMD].Command(V_DEST_STR, 'Array12.Visible = false'); -- БКИ
				
		else
			::[PR_CRED].[NEW_DOG_N].validate_status(V_COM_STATUS, V_DEST_STR);
		end if;
		
		P_LOAN_PORT := ::[SIM_LOAN_PORT].[LIB].GetPortByCred(this);

		--v-- BS00133979 Перед заполнение таблицы процентных ставок, определяем нужно ли заполнять реквизиты для Плавающих ставок
		if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR) or [FL_RATE_RULE].[LIB].FindPrcRule(this) then
			fl_rule_on;
		else
			fl_rule_off;
		end if;
		--^-- BS00133979

		::[PR_CRED].[NEW_DOG_N].FillPrcTable(this.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, true, this, P_KIND_CREDIT, vUseFLRule);
		::[PR_CRED].[NEW_DOG_N].FillComissTable (this.[COMISS_ARR], V_COMISS_TBL);			

		V_OBJ_CRED := ::[PR_CRED].[L_ALEX].get_main_obj(this);
		if not (V_PRC_SCH_TBL.first is null) then
			for idxSch in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last where V_PRC_SCH_TBL(idxSch).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
				V_PRC_SCH_TBL(idxSch).[PRC]		:= V_PRC_RATE;
			end loop;
		end if;
		if DECL_ON_CRED_REF is not null then
			[CSMD].Disable(V_DEST_STR, 'DECL_ON_CRED_REF','V');
		end if;
		
		if [COM_STATUS] = &LCONST.STATUS_WORK then	-- BFS00027399 Если договор в состоянии "Работает", кнопки "X" и "Заявка" делаем недоступными
			[CSMD].Command(V_DEST_STR, 'X.Enabled = false');
			[CSMD].Disable(V_DEST_STR, 'DECL_ON_CRED_REF','V');
			[CSMD].Disable(V_DEST_STR, 'V_CALENDAR', 'V');	-- смену календаря также делаем недоступным
			[CSMD].Disable(V_DEST_STR, 'P_DEF_IFRS', 'P');
		end if;

		V_SCHM_CHANGE := null; -- запрос пользователю на вариант обновления схем не делали
		if	(this%class in ('KRED_CORP', 'KRED_PERS') and P_KIND_CREDIT.[REG_RULES].[PS] is not null)
			or (nvl(V_INVOICE, false))
			or (this%class = 'OVERDRAFTS' and P_KIND_CREDIT.[REG_RULES] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and P_KIND_CREDIT.[LINE_TRANSH] is not null)
		then
			[CSMD].Command(V_DEST_STR, 'Gridcol34.Visible = true');
		else
			[CSMD].Command(V_DEST_STR, 'Gridcol34.Visible = false');
		end if;
					
		Check_Res_Filial;	-- BS00140713
		
	 	-- поищем условия реструктуризации
		if V_CR_CLASS = 'OVERDRAFTS' or V_INVOICE then
			[CSMD].command( V_DEST_STR, 'Frame_Restr.Visible = false');
			[CSMD].command( V_DEST_STR, 'FrameRestrNUK.Visible = false');
			V_RESTR_KIND := null;
		else			
		 	oChangeRuleHR := null;
		 	for (select c(c.[KIND] 		: kind
		 				, c.[MIN_PAY] 	: min_pay
		 				, c.[RT_NUK] 	: rt_nuk
		 				, c%id		 	: rt_id)
		 		in ::[CHANGE_RULE] all where c.[CRED] = this and c.[DATE_REG] = DATE_BEGIN)
		 	loop
		 		V_CHANGE_RULE := c.rt_id;
		 		if not isNUK then
					V_RESTR_KIND := c.kind;
					V_RESTR_MIN_PAY := c.min_pay;
			 	else
					V_RT_NUK := c.rt_nuk;
			 	end if;
		 		exit;
		 	end loop;
		end if;
		
		V_COPY_HL_PP := null;
		
		if (V_CR_CLASS = 'OVERDRAFTS') then
			[CSMD].Disable(V_DEST_STR, 'V_DATE_ENDING_MAX','V');
		end if;

		balloon_validate;
		
		-- определим профиль гашения
		v_distr_profile := ::[PR_CRED].[NEW_DOG_N].get_profile(this%id, Oper_day, P_KIND_CREDIT);
		
		InitFactorTune();
		
		-- vv МОП vv --
			mop_validate();
		-- ^^ МОП ^^ --
		-- заполним грид прочих свойств
		for (	select	prp	( prp : pr_id
							, prp.[KIND_PROP].[TYPE_VALUE] : pr_type
							)
				in ::[PROPERTY_PROD]
				where	prp.[PROD]%id = this%id
						and prp.[KIND_PROP].[OTHERS_TERM]
				order by prp.[DATE_BEGIN]
			)
		loop
			V_OTHERS_TERM(nvl(V_OTHERS_TERM.last,0)+1) := prp.pr_id;
			if prp.pr_type='BOOLEAN' then
				if V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]='1' then
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Да';
				else
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Нет';
				end if;
			end if;
		end loop;
		
		if not (V_CR_CLASS in ('KRED_PERS', 'OVERDRAFTS')
			and CLIENT%class = 'CL_PRIV'
			and this.[HIGH_LEVEL_CR] is null
			and not ::[TUNE_COMPOSITE].[LIB].IsComposit(rCred == this)
			)
		then
			[CSMD].COMMAND(V_DEST_STR,'ButtonCredCategory.Visible = false');
		end if;
		
		--если на кредитном договоре установлен признак "Подключен к комплексному договору", то выводим сообщение
		if this.[CONNECT_CO_PROD] then
			P_CO_PROD := ::[CRED_INTERFACE].[PRX_TARIF_PLAN].GetCoProdOnProduct(this, Oper_Day);
			if not P_CO_PROD is null then
				stdio.put_line_buf('Кредитный договор подключен к комплексному договору '||P_CO_PROD.[NUM_DOG]||' на дату '||to_char(Oper_Day));
			end if;
		end if;
		
		--конструктор планирования
		--при редактировании договора устанавливаем признак "Конструктор планирования" если на договоре указан конструктор или на виде кредита указан конструктор
		V_USE_PLAN_RULE := (this.[PR_DEBT]%size(0) > 0
							or (this.[PARAM_FOR_PLAN]%size(0) = 0
								and not this.[KIND_CREDIT] is null
								and this.[KIND_CREDIT].[PR_DEBT]%size(0) > 0));
		
		if not ::[PR_CRED].[LIB_SERVICE].check_app('1B290078') then
			if V_USE_PLAN_RULE then
				stdio.put_line_buf('Не включено приложение "Конструктор планирования".');
			end if;
			[CSMD].Disable(V_DEST_STR, 'V_USE_PLAN_RULE', 'V');
		end if;						
		
		::[PR_CRED].[NEW_DOG_LIB].validateUsePlanRule(V_USE_PLAN_RULE, V_DEST_STR);
		V_P4P_PLAN_RULE := this.[PARAM_FOR_PLAN];
		bRebuildParam4Plan := false;
		
		--пересчета не было
		bRecalcOnChangeLimit := false;
		
		--валидация МОП
		if V_USE_PLAN_RULE then
			[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = false');
			P_MOP_TYPE := null;
			bMop := false;
		end if;
		
		g_needDropPoint := false;
		g_clickBtnRule := false;
		
		--заполним подразделения для выбора вида кредита
		set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR, false);
		
		--МСФО. Определение наличия первоначального признания
		V_INI_RECOG := [IFRS_LIB].isInitialRecognition(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)));
		
		::[PR_CRED].[NEW_DOG_N].validate_comis(
			p_nForOpenPay == P_FOR_OPEN_PAY,
			ft_cred == FT_CREDIT,
			bIsDisable == V_INI_RECOG or V_COM_STATUS <> &LCONST.STATUS_WAIT_CONF,
			p_info == p_info,
			p_rCred == this,
			ft_comis == P_FOR_OPEN_FN,
			bool_comis == P_FOR_OPEN_BOOL,
			bool_year == P_FOR_OPEN_YEAR,
			V_VALID == V_DEST_STR,
			p_tCurrComis == V_COMISS_TBL
		);
	end if;

-- VALIDATE
	if P_MESSAGE = 'VALIDATE' then
		V_DEST_STR := null;

		if p_info = 'CHANGE_PRC_ARR' then
			--Обработка события, которое будет сгенерировано через таймер после добавления массива процентных ставок
			::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(	 'A'
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR]
														,this
														,DATE_BEGIN
														,greatest(Oper_Day,DATE_BEGIN)
														,V_ANNUITET
														,V_ONE_DAY
														,FT_CREDIT);	-- BS00133030
			V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day);
			-- обновить на форме
			if V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_CREDIT_ARR	:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR];
				V_PRC_RATE		:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC];
				V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
			end if;
		end if;
		
		--пересчет конструктора планирования выполняется при валидации следующих контролов
		--или при валидации на вкладке "Планирование"
		if p_info in ('P_KIND_CREDIT', '%VAR%.P_HIGH_LEVEL_CR', '%VAR%.V_PRJ_KIND_CRED', 'Умолчание', '%VAR%.V_USE_PLAN_RULE') then
			bRebuildPlanRule := true;
		end if;
		
		if p_info = 'P_DEPART' then
			P_FILIAL := nvl(P_DEPART.[FILIAL], P_FILIAL);--Филиал заменить на филиал выбранного подразделения
			set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);
		end if;

		if p_info = 'P_FILIAL' then
			-- Читаем дату Oper_Day ДО того, как будем ее применять ниже --
			Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
			P_DEPART := null;
			set_departs(P_DEPART, V_STRING_DEPARTS, P_KIND_CREDIT, V_DEST_STR);
		end if;
		
		if p_info = 'P_FILIAL' or p_info like '%V_CLIENT_REQ.1%' then
			if P_FILIAL != V_CLIENT_REQ.[1].[2].[FILIAL] then
				[CSMD].Command(V_DEST_STR, 'label38.Caption = "Расчетный счет открыт в филиале ' || V_CLIENT_REQ.[1].[2].[FILIAL].[CODE] || '"');			
				[CSMD].Command(V_DEST_STR, 'label38.Visible = true');
			else
				[CSMD].Command(V_DEST_STR, 'label38.Visible = false');
			end if;
		end if;
		
		if p_info = 'P_TURNOVER.UNIT_INTERVALS' then
			if P_TURNOVER.UNIT_INTERVALS = ::[UNITS_OF_TIME]([CODE]='D') then
				[CSMD].Enable(V_DEST_STR, 'P_TURNOVER_WD');
			else
				[CSMD].Disable(V_DEST_STR, 'P_TURNOVER_WD');
				P_TURNOVER_WD := false;
			end if;
		elsif p_info = 'P_TURNOVER_WD' then
			if P_TURNOVER_WD then
				P_TURNOVER.UNIT_INTERVALS := ::[UNITS_OF_TIME]([CODE]='D');
			end if;
		end if;
		
		-- необходимость выбрать вариант изменения %% схем если сменили вид кредита, вид проекта, КВУ
		if p_info in ('P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED') and not P_HIGH_LEVEL_CR is null then
			if ((p_info ='P_KIND_CREDIT' and P_KIND_CREDIT is not null) or (p_info ='%VAR%.V_PRJ_KIND_CRED' and V_PRJ_KIND_CRED.[CRED] is not null))
				and [COMISS_ARR]%size(1)>0
			then
			 	-- выдадим запрос через клиент-скрипт и отправим результат окна в сервер-валидатор
				V_DEST_STR := V_DEST_STR || NL$ ||'Call Form1.ScriptServerValidate(Nothing, "SCHM_" & Form1.ScriptPlayEx("<% PLPCALL [PR_CRED].[SCHM_CHANGE_VAR](P_SELECT => %VAR%.V_SCHM_CHANGE) %>"))';
				v_old_info := p_info; -- запомнил что изменял пользователь
				p_info := null; -- отменяем все валидации до ответа пользователя
			end if;
		end if;

		if p_info like 'SCHM_%' then -- результат окна запроса (0 - закрыл/1 - нажал ОК)
			if substr(p_info, 6, 1) = '0' then -- пользователь закрыл запрос или нажал отмену
				P_KIND_CREDIT := v_old_kind;
			else
				-- возвращаем валидацию которая была до запроса пользователю
				-- результат выбора пользователя через in out V_SCHM_CHANGE
				p_info := v_old_info;
				v_old_info := null;
			end if;
			v_old_kind := P_KIND_CREDIT;
		end if;
	
		if p_info in ('P_KIND_CREDIT', '%VAR%.V_PRJ_KIND_CRED') then
			declare
				bKindCred_change boolean;
				bPrjKindCred_change boolean;
				kindCred_before_skk P_KIND_CREDIT%type;
			begin
				if P_INFO = 'P_KIND_CREDIT' then
					bKindCred_change := true;
				else
					bKindCred_change := false;
				end if;
				if P_INFO = '%VAR%.V_PRJ_KIND_CRED' then
					bPrjKindCred_change := true;
				else
					bPrjKindCred_change := false;
				end if;
				kindCred_before_skk := P_KIND_CREDIT;

				if bPrjKindCred_change then
					if v_prj_kind_cred.[CRED] is not null then						
						p_info := 'P_KIND_CREDIT';
						p_kind_credit := v_prj_kind_cred.[CRED];
					elsif p_kind_credit.[TYPE_PROJECT] != v_prj_kind_cred then					
						p_info := 'P_KIND_CREDIT';
						p_kind_credit := null;
					end if;
				end if;
				
				if (kindCred_before_skk is null and P_KIND_CREDIT is null) or (kindCred_before_skk = P_KIND_CREDIT) then
					null;	-- BFS00027399 Если вид кредита не изменился, путь выдачи не изменяем
				elsif not(P_KIND_CREDIT is null) then
					-- BFS00027399 Если в виде кредита указан путь выдачи, то устанавливаем этот путь выдачи
					b_Kind_Cred_Changed := true;
				end if;				

				if bKindCred_change OR (bPrjKindCred_change AND kindCred_before_skk <> P_KIND_CREDIT) then
						-- С целью исключения изменений в процентной схеме, "принадлежащей" другому виду кредита

					declare
						Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
						psPRC__CREDIT ref [PRC_SCHEME];
					begin
						psPRC__CREDIT := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
						if V_CREDIT_ARR is not null OR psPRC__CREDIT is not null then
								for	( select vk(vk) in ::[KIND_CREDITS],(::[DEBT_COMISS_PRC] all : pss),(::[PRC_SCHEME] all : ps) all
										where (P_KIND_CREDIT is null or vk <> P_KIND_CREDIT)
										and vk.[COMISS_ARR] = pss%collection
										and pss.[PRC_SCHEME] = ps
										and (psPRC__CREDIT = ps or ps.[list_sch_prc] = V_CREDIT_ARR)
								)
								loop
									::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
									V_CREDIT_ARR := null;
									V_PRC_RATE := null;
									exit;
								end loop;
						end if;
					end;
				end if;
				if b_Kind_Cred_Changed then
					on_change_kind_credit(this
										, P_KIND_CREDIT
										, P_CALENDAR_NAME
										, DATE_BEGIN
										, DATE_ENDING
										, DECL_ON_CRED_REF
										, DIC_TYPE_CRED
										, FT_CREDIT
										, NUM_DOG
										, PERIOD
										, P_CALC_TYPE
										, P_DEPART
										, P_HIGH_LEVEL_CR
										, P_OPER_WAY_OUT
										, P_OVD_ACCOUNT
										, P_PERIOD_UNIT
										, P_PRODUCT
										, V_COMISS_TBL
										, V_CREDIT_ARR
										, V_CR_CLASS
										, V_DATE_ENDING_MAX
										, V_DATE_GIVE
										, V_DEST_STR
										, V_EARLY_PAY
										, V_GEN_AGR
										, V_INVOICE
										, V_IS_FOR_CRED_CARD
										, V_OPEN_DEP
										, V_PRC_ADD
										, V_PRC_RATE
										, V_PRC_SCH_TBL
										, V_PRJ_KIND_CRED
										, V_SCHM_CHANGE
										, V_WAY_OUT_CODE
										, P_PERIOD_WD);
				end if;
			end;

			-- Дополнительные свойства --
			V_PROPERTIES%delete;
			if not nvl(::[HOOK].[CRED_COPY_PROPS](this, DECL_ON_CRED_REF), false) then
				::[PROD_PROPERTY].L.make_default_properties( V_PROPERTIES, V_CR_CLASS, DATE_BEGIN, P_KIND_CREDIT.[CODE]);
			end if;
		end if;

		if p_info = '%THIS%.TO_BKI' then -- <Akil> -- разрешение на предоставление информации в БКИ
			V_TO_BKI := ::[PR_CRED].[NEW_DOG_N].into_bki(this, Oper_Day);
		end if;

		if p_info = 'SAVE_RATE_TBL_YES' and V_PRC_SCH_TBL_IDX>0 then -- пользователь подтвердил сохранение ставки из грида
			if ::[PROL_CONTRACT].[LIB_FIND_REF].is_exists_scheme_in_tp(V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]) then	
				stdio.put_line_buf('Схема начисления процентов сформирована автоматически. Ручное редактирование запрещено!');
				V_PRC_RATE = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC]	= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE]	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF] , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
				return;
			end if;
			if V_CAN_PRC_SCH = 2 then
				--выбрали копирование схемы
				::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[DEBT]);
				V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF] := null;
				V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR] := null;
			end if;

			if prc_date_beg_tune = 1 then
				m_date := DATE_BEGIN;
			else
				m_date := greatest(Oper_Day,DATE_BEGIN);
			end if;
	
			::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(	 'R'
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF]
														,V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR]
														,this
														,m_date
														,greatest(Oper_Day,DATE_BEGIN)
														,V_ANNUITET
														,V_ONE_DAY
														,FT_CREDIT);
															
			V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day);
			
			if V_CAN_PRC_SCH = 2 then
				::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[DEBT]);
			end if;
				
			-- обновить на форме
			if V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_CREDIT_ARR	:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_ARR];
				V_PRC_RATE		:= V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC];
				V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
			end if;

		end if;
		
		if p_info = 'SAVE_RATE_TBL_NO' then
			-- вернуть ставку на форму
			if V_PRC_SCH_TBL_IDX>0 and V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
				V_PRC_RATE = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[PRC] = V_PRC_SCH_TBL(V_PRC_SCH_TBL_IDX).[RES_RATE]	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
			end if;
		end if;		

		-- процентные схемы/ставки/истории ставок
		if p_info like '%VAR%.V_PRC_SCH_TBL.%[%]' then
			i := GetIndexPrc(p_info, sField);
			V_PRC_SCH_TBL_IDX := i; --сохраним индекс изменяемой строки, для последующей обработки в SAVE_RATE_TBL_YES
			&debug('validate: i = '||i, 0)

			if i is not null then
				if sField = 'PRC_REF' then		-- процентная схема
					if V_PRC_SCH_TBL(i).[PRC_REF] is not null then	-- прописать
						declare
							rScheme 	ref [PRC_SCHEME];
						begin
							rScheme := V_PRC_SCH_TBL(i).[PRC_REF];
	
							V_PRC_SCH_TBL(i).[PRC]		:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, Oper_Day, 0, 0, false, false);
							V_PRC_SCH_TBL(i).[RES_RATE] := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( rScheme, Oper_Day );
							V_PRC_SCH_TBL(i).[PRC_ARR]	:= rScheme.[LIST_SCH_PRC];
							::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, V_PRC_SCH_TBL(i).[DEBT]);
						end;
					elsif V_PRC_SCH_TBL(i).[PRC_REF] is null then	-- очистить
						V_PRC_SCH_TBL(i).[PRC]		:= null;
						V_PRC_SCH_TBL(i).[PRC_ARR]	:= null;
						V_PRC_SCH_TBL(i).[RES_RATE] := null;
						-- После удаления схемы всегда позволяем на первой закладки редактировать ставку
						-- Сделано для траншей, для которых этот контрол блокируется
						[CSMD].Enable(V_DEST_STR, 'V_PRC_RATE','V');
					end if;


					--v-- BS00133979. При изменении в гриде процентной схемы обновляем тип ставки, если осуществляется работа с Пл. ставками					
					if vUseFLRule then
						V_PRC_SCH_TBL(i).[FL_RULE_TYPE] := ::[PR_CRED].[NEW_DOG_N].get_RateType(this, V_PRC_SCH_TBL(i).[DEBT], V_PRC_SCH_TBL(i).[PRC_REF], Oper_Day);
					end if;
					--^-- BS00133979 				
					
				elsif sField = 'PRC' then					-- процентная ставка
					--Сначала сработает серверный валидатор и установит значение V_CAN_PRC_SCH
					--Потом клиентский, в котором задаем вопрос пользователю, что делать со схемой
					--Затем снова серверный SAVE_RATE_TBL_YES, где уже сохранение ставки
					V_CAN_PRC_SCH := 9;
					if V_PRC_SCH_TBL(i).[PRC_REF] is not null then
						--проверка на общую схему
						for
						(
							select comisar('1')
							in ::[DEBT_COMISS_PRC] collections
							where comisar%collection != this.[COMISS_ARR]
								and comisar.[PRC_SCHEME] = V_PRC_SCH_TBL(i).[PRC_REF]
						)
						loop
							--Проверим права пользователя на операцию PRC_SCH_ACCESS
							if [RUNTIME].[SECURITY].Is_Method_Accessible('PRC_SCHEME', 'PRC_SCH_ACCESS', [stdlib].userid.[USERNAME]) then
								--есть права, предоставим выбор что сделать со ставкой
								V_CAN_PRC_SCH := 1;
							else
								V_CAN_PRC_SCH := 0;
							end if;
							exit;
						end loop;
					end if;
					
					&debug('validate: V_CAN_PRC_SCH = '||V_CAN_PRC_SCH||', V_PRC_SCH_TBL(i).[PRC_ARR] = '||V_PRC_SCH_TBL(i).[PRC_ARR], 0)
					-- если можно изменять, то проверим что придется изменять простую ставку или сложную ставку с простыми процентами
					if V_PRC_SCH_TBL(i).[PRC_ARR] is not null and V_CAN_PRC_SCH <> 0 then
						declare
							oArcSchPrc	[ARC_SCH_PRC];
						begin
							oArcSchPrc := ::[PR_CRED].[NEW_DOG_LIB].getCurrentArcPrc(V_PRC_SCH_TBL(i).[PRC_ARR], nvl(DATE_BEGIN, Oper_Day));
							if not nvl(oArcSchPrc.[L_SIMPLE_PRC], false) then
								V_CAN_PRC_SCH := 2;
							end if;
						end;
					end if;
					
				elsif sField = 'PRC_ARR' then				-- история ставок
					--Добавить генерацию события CHANGE_PRC_ARR через таймер, чтобы ИД массива процентных ставок успело записаться в ячейку грида
					[CSMD].Command(V_DEST_STR, 'Form1.SetTimer 1, 500');

				elsif sField = 'STOP_CALC' then		-- существенность
					-- Менять существенность можно только для затрат/комиссий по которым заданы процентные схемы
					if	V_PRC_SCH_TBL(i).[PRC_REF] is null or coalesce(V_PRC_SCH_TBL(i).[DEBT].[TYPE_DEBT], -1) not in (&LCONST.TD_EXPENSE, &LCONST.TD_COMMISS_PRC) then
						V_PRC_SCH_TBL(i).[STOP_CALC] := null;
					end if;

				end if;
				-- обновить на форме
				if V_PRC_SCH_TBL(i).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' then
					V_CREDIT_ARR	:= V_PRC_SCH_TBL(i).[PRC_ARR];
					V_PRC_RATE		:= V_PRC_SCH_TBL(i).[PRC];
					V_PRC_ADD       := 'Ставка: '||to_char((::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(i).[PRC_REF], Oper_Day)), '99990D00000000')||' %';
				end if;

				::[RUNTIME].[CSMD].Command(V_DEST_STR, 'Call CheckCalcImpPrc()');
			end if;
		end if;
		
		if P_INFO in ('CLIENT', 'OK') then
			-- контроль операций по клиентам-банкротам
			::[CR_B_CHECK_TUNE].[LIB].checkCredClient
					( CLIENT
					, ::[SYSTEM].[VARIABLES].Br2OpDate(coalesce(P_FILIAL%id, this.[FILIAL], ::[SYSTEM].[VARIABLES].OurBranch%id))
					, this
					, coalesce(NUM_DOG, this.[NUM_DOG])
					, &METHOD$CLASS
					, &METHOD$SNAME
					, P_INFO
					, this%class
					, V_DEST_STR
			);
		end if;

		if P_INFO = 'CLIENT' then
			setClient();
			
			if not bDisableOverOnProd then
		 		if V_CR_CLASS = 'OVERDRAFTS' and CLIENT is not null and CLIENT%class != 'CL_PRIV' then
					V_OPEN_DEP := false;
		 			[CSMD].Disable(V_DEST_STR, 'V_OPEN_DEP', 'V');
					[CSMD].Enable (V_DEST_STR, 'P_OVD_ACCOUNT');
					[CSMD].Enable (V_DEST_STR, 'P_PRODUCT');
		 		else
		 			[CSMD].Enable(V_DEST_STR, 'V_OPEN_DEP', 'V');
		 		end if;
			end if;	 		
		
		end if;

		if	P_INFO in ('CLIENT', 'FT_CREDIT') and FT_CREDIT is not null and CLIENT is not null then		-- BFS00027399
			if P_KIND_CREDIT is null or (not(P_KIND_CREDIT is null) and P_KIND_CREDIT.[WAY_CRED] is null) then	-- Путь выдачи в виде кредита не указан - установим его
				if V_CR_CLASS = 'KRED_PERS' and FT_CREDIT = ::[SYSTEM].[VARIABLES].NatCur then
					-- Установим 'Через кассу' (В справочнике может быть указано только одно значение с кодом 02)
					P_OPER_WAY_OUT := ::[PR_CRED].[NEW_DOG_N].get_way('02');
				else
					-- Установим 'Перечислением' (В справочнике может быть указано только одно значение с кодом 01)
					P_OPER_WAY_OUT := ::[PR_CRED].[NEW_DOG_N].get_way('01');
				end if;
			end if;
			if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then		-- BFS00027399
				rPsOrg := CLIENT->(::[CL_CORP])[FORMA].[PS];
			else
				rPsOrg := null;
			end if;
			V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		end if;

		if	P_INFO in ('CLIENT', 'FT_CREDIT') and FT_CREDIT is not null and V_CLIENT_REQ.[1].[2] is null and V_CLIENT_REQ.[2].[1] is null then
			
			this.[FT_CREDIT]:= FT_CREDIT;
			setClient();
			
			for my_count
				in CLIENT.[OKONH_IN_PERIOD]
				where (my_count.[DATE_BEGIN] is null or DATE_BEGIN is null or my_count.[DATE_BEGIN] <= DATE_BEGIN)
				and   (my_count.[DATE_END] is null or DATE_BEGIN is null or my_count.[DATE_END] > DATE_BEGIN)
			loop
				V_OKONH := my_count.[OKONH]; exit;
			end loop;

			if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then
				rPsOrg := CLIENT->(::[CL_CORP])[FORMA].[PS];
			else
				rPsOrg := null;
			end if;
			V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);

		end if;
		if p_info in ('P_FOR_OPEN_BOOL', 'P_FOR_OPEN_YEAR', '%VAR%.P_FOR_OPEN_FN', 'FT_CREDIT', 'P_FOR_OPEN_PAY')	then
			presaveThis();
			::[PR_CRED].[NEW_DOG_N].validate_comis(
				p_nForOpenPay == P_FOR_OPEN_PAY,
				ft_cred == FT_CREDIT,
				bIsDisable == V_INI_RECOG or V_COM_STATUS <> &LCONST.STATUS_WAIT_CONF,
				p_info == p_info,
				p_rCred == this,
				ft_comis == P_FOR_OPEN_FN,
				bool_comis == P_FOR_OPEN_BOOL,
				bool_year == P_FOR_OPEN_YEAR,
				V_VALID == V_DEST_STR,
				p_tCurrComis == V_COMISS_TBL
			);
			
			V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way(V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
			if p_info = 'FT_CREDIT' then
				::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes(P_KIND_CREDIT.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);
				
				v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);
				if V_EARLY_PAY.[USE_PRIVATE] and ::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY') then
					begin
						V_EARLY_PAY.[DELETE#AUTO];
					exception
						when others then
							null;
					end;
				end if;
				V_EARLY_PAY := ::[PR_CRED].[NEW_DOG_LIB].MakeEarlyPeny( nvl(DECL_ON_CRED_REF.[EARLY_PAY], v_kind_early), 'по договору № '||NUM_DOG );				
			end if;
 		end if;
 		-- сделаем обработку ответа пользователя до основных обработчиков чтобы не дублировать код
 		-- а подставить нужный p_info
		if p_info = 'SAVE_RATE_YES' then -- пользователь подтвердил сохранение ставки
			bCanSaveRate := true;
		elsif p_info = 'SAVE_RATE_NO' then
			-- вернуть ставку на форму
			V_PRC_RATE := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
			-- обновить в таблице значение ставки
			if not (V_PRC_SCH_TBL.first is null) then
				for idxSch in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
					where V_PRC_SCH_TBL(idxSch).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
					V_PRC_SCH_TBL(idxSch).[PRC] = V_PRC_SCH_TBL(idxSch).[RES_RATE]	:= V_PRC_RATE;
				end loop;
			end if;
		end if;
 		
		if P_INFO = 'P_OPER_WAY_OUT' and P_OPER_WAY_OUT is not null then
			V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		
		elsif P_INFO = 'P_KIND_CREDIT' then
			
			bCopyMPTune := null;
			b_Kind_Cred_Changed := true;
			on_change_kind_credit(this
								, P_KIND_CREDIT
								, P_CALENDAR_NAME
								, DATE_BEGIN
								, DATE_ENDING
								, DECL_ON_CRED_REF
								, DIC_TYPE_CRED
								, FT_CREDIT
								, NUM_DOG
								, PERIOD
								, P_CALC_TYPE
								, P_DEPART
								, P_HIGH_LEVEL_CR
								, P_OPER_WAY_OUT
								, P_OVD_ACCOUNT
								, P_PERIOD_UNIT
								, P_PRODUCT
								, V_COMISS_TBL
								, V_CREDIT_ARR
								, V_CR_CLASS
								, V_DATE_ENDING_MAX
								, V_DATE_GIVE
								, V_DEST_STR
								, V_EARLY_PAY
								, V_GEN_AGR
								, V_INVOICE
								, V_IS_FOR_CRED_CARD
								, V_OPEN_DEP
								, V_PRC_ADD
								, V_PRC_RATE
								, V_PRC_SCH_TBL
								, V_PRJ_KIND_CRED
								, V_SCHM_CHANGE
								, V_WAY_OUT_CODE
								, P_PERIOD_WD);

			balloon_validate;
			
		--v-- BS00133979 Работа с плавающими ставками на ЭФО
		elsif P_INFO like '%.V_PRC_SCH_TBL.FL_RULES[%]' then
			-- Обновим запись по которой редактировались правила в гриде процентных схем
			declare
				vIdx 			pls_integer := to_number(substr(P_INFO,30,length(P_INFO)-30));
				vFindPrcRule	boolean;
				vMessage varchar2(500);
			begin
				-- Если процентная схема задана то не обновляем ее, т.к. значение из базы может перетереть изменения сделанные на ЭФО
				
				if V_PRC_SCH_TBL(vIdx).[PRC_REF] is null then
					for
					(
						select x( x.[PRC_SCHEME] : rSchema
							, x.[FROM_HL_CRED] : sFromHL)
						in this.[COMISS_ARR]
						where x.[DEBT] = V_PRC_SCH_TBL(vIdx).[DEBT]
					)
					loop
						V_PRC_SCH_TBL(vIdx).[PRC_REF]		:= x.rSchema;
						V_PRC_SCH_TBL(vIdx).[PRC_ARR]		:= V_PRC_SCH_TBL(vIdx).[PRC_REF].[LIST_SCH_PRC];
						V_PRC_SCH_TBL(vIdx).[PRC]	 	  	:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(vIdx).[PRC_REF], Oper_Day, 0, 0, false, false);
						V_PRC_SCH_TBL(vIdx).[FROM_HL_CRED] := x.sFromHL;
						exit;
					end loop;					
				end if;

				-- Для неучтенных процентов обновим ставку и историю на первой вкладке ЭФО
				if V_PRC_SCH_TBL(vIdx).[PRC_REF] is not null then
					if V_PRC_SCH_TBL(vIdx).[DEBT] = ::[VID_DEBT]([CODE] = 'НЕУЧТЕН_ПРОЦЕНТЫ') then
						V_CREDIT_ARR	:= V_PRC_SCH_TBL(vIdx).[PRC_ARR];
						V_PRC_RATE		:= V_PRC_SCH_TBL(vIdx).[PRC];
					end if;
		
					vFindPrcRule := [FL_RATE_RULE].[LIB].FindPrcRule(this, V_PRC_SCH_TBL(vIdx).[DEBT]);
						
					if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR, V_PRC_SCH_TBL(vIdx).[DEBT]) or vFindPrcRule then
						-- Есть правила или вид кредита допускает их использование					
						
						-- определим тип ставки
						V_PRC_SCH_TBL(vIdx).[FL_RULE_TYPE] := ::[PR_CRED].[NEW_DOG_N].get_RateType(this, V_PRC_SCH_TBL(vIdx).[DEBT], V_PRC_SCH_TBL(vIdx).[PRC_REF], Oper_Day);
							
						if vFindPrcRule then
							-- правила есть, отображаем массив как (***)
							V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := this%id;
						else
							-- правил нет, отметим массив для обнуления (***)
							V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := '0';
								
							-- проверим если массив был доступен только из-за наличия правил то заблокируем его
							if not [FL_RATE_RULE].[LIB].Check_UseFLR2ProdDebt(this, V_PRC_SCH_TBL(vIdx).[DEBT], vMessage, V_PRC_SCH_TBL(vIdx).[PRC_REF]) then
								[CSMD].Command(V_DEST_STR, 'Gridcol36.Enabled = false');
							end if;
						end if;
					end if;
				end if;
			end;
			
		elsif P_INFO like 'SET_FLR_CONTEXT%' then
			declare
				vIdx integer := to_number(substr(P_INFO,16));
			begin
				executor.set_context('$FL_RATE$SET$PROD', this%id);
				executor.set_context('$FL_RATE$SET$DEBT', V_PRC_SCH_TBL(vIdx).[DEBT]%id);
				executor.set_context('$FL_RATE$SET$CLCALSS', CLIENT%class);
				executor.set_context('$FL_RATE$SET$SCHEME', V_PRC_SCH_TBL(vIdx).[PRC_REF]%id);
				
				if V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection = '0' then
					-- обнулим массив (будет отображаться как (...))
					V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := null;
				else
					-- заполним коллекцию для работы с массивом
					V_PRC_SCH_TBL(vIdx).[FL_RULES]%collection := this%id;
				end if;
			end;
		elsif P_INFO like 'PRCSCH_ROW_CHANGE%' then
			-- При смене записи в гриде заблокируем/разблокируем массив правил
			declare
				vMessage varchar2(1000);
				vIdx integer := to_number(substr(P_INFO,18));
			begin
				-- Определим доступен ли массив для работы
				if [FL_RATE_RULE].[LIB].Check_UseFLR2ProdDebt(this, V_PRC_SCH_TBL(vIdx).[DEBT], vMessage, V_PRC_SCH_TBL(vIdx).[PRC_REF]) or [FL_RATE_RULE].[LIB].FindPrcRule(this, V_PRC_SCH_TBL(vIdx).[DEBT]) then
					V_SCHM_FOR_RULE := '1';
				else
					V_SCHM_FOR_RULE := '0';
				end if;
				
				if vMessage is not null then
					-- добавим сообщение для клиент-скрипта
					V_SCHM_FOR_RULE := V_SCHM_FOR_RULE || vMessage;
				end if;
			end;
		--^-- BS00133979

		elsif P_INFO = '%VAR%.V_OPEN_DEP' then
			if V_OPEN_DEP then
				P_PRODUCT = P_OVD_ACCOUNT := null;
				V_CLIENT_REQ.[0] := 1;
				V_CLIENT_REQ.[1].[1] := null;
				V_CLIENT_REQ.[1].[2] := null;
				[CSMD].Disable(V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Disable(V_DEST_STR, 'P_PRODUCT');
			else
				[CSMD].Enable (V_DEST_STR, 'P_OVD_ACCOUNT');
				[CSMD].Enable (V_DEST_STR, 'P_PRODUCT');
			end if;
		
		elsif p_info = '%VAR%.P_SIGN_UP' then
			if not nvl(P_SIGN_UP, false) then
				P_OPEN_ACC	:= false;
				P_DEF_IFRS	:= false;
			elsif P_SIGN_UP then
				P_DEF_IFRS := coalesce(this.[GET_BOOL_TUNE](::[PRODUCT].[TUNE_CODES].CODE_IFRS_DEFAULT), false);
			end if;
		elsif p_info = '%VAR%.P_OPEN_ACC' and P_OPEN_ACC then
			P_SIGN_UP	:= true;
			P_DEF_IFRS := coalesce(this.[GET_BOOL_TUNE](::[PRODUCT].[TUNE_CODES].CODE_IFRS_DEFAULT), false);
		elsif p_info = 'P_DEF_IFRS' and coalesce(P_DEF_IFRS,false) then
			P_SIGN_UP	:= true;
		elsif P_INFO in	('FT_CREDIT', 'SUMMA', '%VAR%.V_LIMIT_SALDO') then
			if SUMMA is null then	-- BFS00027399
				V_SUM_STR := null;
			else
				V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(SUMMA, FT_CREDIT.[CUR_SHORT]);
			end if;
			if nvl([DIC_TYPE_CRED],P_KIND_CREDIT.[REG_RULES]) = &LCONST.TC_CRED_OVER then
				if V_MAX_LIMIT_SALDO is not null and V_LIMIT_SALDO > V_MAX_LIMIT_SALDO then
					pragma error('Значение максимального лимита задолженности должно быть больше лимита задолженности');
				end if;
			end if;	
			if SUMMA < nvl(P_BALLOON_PAYMENT, SUMMA) then
				P_BALLOON_PAYMENT := SUMMA;
			end if;
			bRebuildParam4Plan := true;
			presaveThis();
			::[PR_CRED].[NEW_DOG_N].recalcImportance(V_COMISS_TBL, V_PRC_SCH_TBL, this);
			
		elsif P_INFO in ('P_BALLOON_PAYMENT') then	
			if SUMMA < nvl(P_BALLOON_PAYMENT, SUMMA) then
				P_BALLOON_PAYMENT := SUMMA;
			end if;
			bRebuildParam4Plan := true;
		elsif P_INFO in ('%VAR%.V_MAX_LIMIT_SALDO') then	
			if V_MAX_LIMIT_SALDO is not null and V_LIMIT_SALDO > V_MAX_LIMIT_SALDO then
				pragma error('Значение максимального лимита задолженности должно быть больше лимита задолженности');
			end if;
			
		elsif p_info in ('DATE_BEGIN','%VAR%.V_DATE_GIVE') then
	 		if V_DATE_GIVE < DATE_BEGIN and P_INFO='%VAR%.V_DATE_GIVE' then	-- BFS00027399
	 			pragma error ('Дата выдачи не может быть меньше даты начала действия договора');
	 		end if; 		

			if p_info = 'DATE_BEGIN' then
				V_DATE_GIVE := DATE_BEGIN;
			
				for r_plan_hist in this.[PLAN_HIST]
					where r_plan_hist.[DATE_BEG] = [DATE_BEGIN]
				loop
					r_plan_hist.[DATE_BEG]:= DATE_BEGIN;
				end loop;
			
				if P_HIGH_LEVEL_CR is not null then
					-- определим значение свойства на дату начала транша --
					glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																		, DATE_BEGIN
																		, propTRANSH_PERIOD_NUM
																		);
					if glHL_PERIOD_NUM is not null then
						PERIOD := glHL_PERIOD_NUM;
						glHL_PERIOD_UNIT = P_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
						P_PERIOD_WD := false;
					end if;
				end if;
			end if;
			
			[DATE_BEGIN] := DATE_BEGIN;
			[DATE_GIVE] := V_DATE_GIVE;
			if PERIOD > 0 then
				DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar);
				if P_HIGH_LEVEL_CR is not null and not bCreateComposit then
					DATE_ENDING	:= least(DATE_ENDING, P_HIGH_LEVEL_CR.[DATE_ENDING]);
					::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
				end if;
				::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			end if;
			kind_cred := P_KIND_CREDIT;
			if kind_cred.[MAX_PERIOD_NUM] is not null and kind_cred.[MAX_PERIOD_MS] is not null then
				V_DATE_ENDING_MAX := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), kind_cred.[MAX_PERIOD_NUM], kind_cred.[MAX_PERIOD_MS], null, null, kind_cred.[PERIOD_WD], sCalendar);
			end if;
			
				for	(	select rSchemes	( rSchemes.[PRC_SCHEME]: PRC_SCHEME
										, rSchemes.[DEBT]: DEBT
										, rSchemes.[JOURNAL_PRC] : journalPrc
										,	(	select hist(min(hist.[DATE_BEG]))
												in rSchemes.[PRC_SCHEME].[LIST_SCH_PRC]
										 	) : SCH_DATE_BEGIN
										)
						in this.[COMISS_ARR]
						where not rSchemes.[PRC_SCHEME] is null
					)
				loop
					if DATE_BEGIN < nvl(rSchemes.SCH_DATE_BEGIN, DATE_BEGIN + 1) then
						::[PR_CRED].[NEW_DOG_LIB].EditDateBegPrc(DATE_BEGIN
													,rSchemes.[PRC_SCHEME]
													,Prc_Arr(::[PR_CRED].[NEW_DOG_N].Find_Prc_Arr(rSchemes.[DEBT].[CODE], Prc_Arr)).[Proc_Arr]);
						
							-- Удалить схему начисленных процентов, т.к. изменилась дата действия процентной ставки
							delete journalPrc
							in ::[STRING_CALC_PRC] all
							where journalPrc%collection = rSchemes.journalPrc;
					end if;
				end loop;
				
			if p_info = '%VAR%.V_DATE_GIVE' and bCreateComposit then
				call_make_plan_pr(false);
			else
				bRebuildParam4Plan := true;
			end if;
				
	  	elsif p_info in ('PERIOD', 'P_PERIOD_UNIT', 'P_PERIOD_WD') then
			if p_info = 'P_PERIOD_UNIT' then
				if P_PERIOD_UNIT = ::[UNITS_OF_TIME]([CODE]='D') then
					[CSMD].Enable(V_DEST_STR, 'P_PERIOD_WD');
				else
					[CSMD].Disable(V_DEST_STR, 'P_PERIOD_WD');
					P_PERIOD_WD := false;
				end if;
			elsif p_info = 'P_PERIOD_WD' then
				if P_PERIOD_WD then
					P_PERIOD_UNIT := ::[UNITS_OF_TIME]([CODE]='D');
				end if;
			end if;

			DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), PERIOD, P_PERIOD_UNIT, null, null, P_PERIOD_WD, sCalendar);
	  		if glHL_PERIOD_NUM is not null then
	  			if DATE_ENDING > P_HIGH_LEVEL_CR.[DATE_ENDING] then
	  				pragma error('Ошибка! Срок транша превышает срок договора верхнего уровня.');
	  			end if;
	  		end if;
			::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			bRebuildParam4Plan := true;
		
		elsif p_info = 'DATE_ENDING' then
	  		if glHL_PERIOD_NUM is not null then
	  			if DATE_ENDING > P_HIGH_LEVEL_CR.[DATE_ENDING] then
	  				pragma error('Ошибка! Срок транша превышает срок договора верхнего уровня.');
	  			end if;
	  		end if;
			::[PR_CRED].[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
			bRebuildParam4Plan := true;
			
		elsif p_info = 'NUM_DOG'	then
			[NUM_DOG]	:= NUM_DOG;
			::[PR_CRED].[NEW_DOG_N].change_scheme_name ( this);

			v_kind_early := ::[PR_CRED].[NEW_DOG_LIB].Get_Early_Pay(P_KIND_CREDIT, FT_CREDIT);			
			if   nvl(v_kind_early.[USE_PRIVATE], false)
			 and not(V_EARLY_PAY is null)
			 and nvl(::[FP_TUNE].[LIB].get_bool_value('USE_IND_EARLY_PENY'), false)
			then					
				V_EARLY_PAY.[NAME] := v_kind_early.[NAME] || ' по договору № ' || NUM_DOG;
			end if;	
						
		elsif p_info = '%VAR%.P_HIGH_LEVEL_CR' then
			-- Независимо от того удалили ссылку на КВУ или изменили ее, очистим массив счетов договора
			-- чтобы избежать ситуации дублирования счетов с разных КВУ
			-- Также почистим реквизиты-ссылки счетов, которые заполнились со старого КВУ
			if not [HIGH_LEVEL_CR] is null and (P_HIGH_LEVEL_CR is null or P_HIGH_LEVEL_CR != [HIGH_LEVEL_CR]) then
				[ARRAY_DOG_ACC]%delete;
				[VNB_UNUSED_LINE] := null;
				[VNB_EXCEED_PRC] := null;
				[VNB_DEMAND_PRC] := null;
				[ACCOUNT] := null;
				[ACC_SETTLEMENT] := null;
				[ACC_DEBTS_CR] := null;
				[ACC_DEBTS_PRC] := null;
				[ACC_RESERV] := null;
				[ACC_RESERV_DEBTS] := null;
				[ACC_DEMAND_PRC] := null;
				P_ACCOUNT := null;
			end if;
			if P_HIGH_LEVEL_CR is null then
				glHL_PERIOD_NUM = glHL_PERIOD_UNIT := null;
				
			elsif P_HIGH_LEVEL_CR is not null then
				FT_CREDIT	:= P_HIGH_LEVEL_CR.[FT_CREDIT];
				V_GEN_AGR	:= null;
				CLIENT		:= P_HIGH_LEVEL_CR.[CLIENT];
				V_LIMIT_CR	:= ::[PR_CRED].[L].GetSumDebt(P_HIGH_LEVEL_CR, &LCONST.VD_LIMIT, Oper_Day);
				
				glHL_PERIOD_UNIT:= null;
				glHL_PERIOD_NUM := ::[PROPERTY_PROD].[LIB].GetPropVal(P_HIGH_LEVEL_CR
																	, DATE_BEGIN
																	, propTRANSH_PERIOD_NUM
																	);
				if glHL_PERIOD_NUM is not null then
					PERIOD := glHL_PERIOD_NUM;
					glHL_PERIOD_UNIT = P_PERIOD_UNIT := P_HIGH_LEVEL_CR.[PERIOD_UNIT];
					P_PERIOD_WD := false;
					DATE_ENDING := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd
																	(coalesce(V_DATE_GIVE, DATE_BEGIN)
																	,PERIOD
																	,P_PERIOD_UNIT
																	,null, null
																	,P_PERIOD_WD
																	,sCalendar);
					DATE_ENDING	:= least(DATE_ENDING, P_HIGH_LEVEL_CR.[DATE_ENDING]);
					::[PR_CRED].[NEW_DOG_LIB].calc_period_units( coalesce(V_DATE_GIVE, DATE_BEGIN), DATE_ENDING, PERIOD, P_PERIOD_UNIT, P_PERIOD_WD, sCalendar);
				end if;
			end if;
			
			bRebuildParam4Plan := true;
		
		elsif p_info = '%VAR%.DECL_ON_CRED_REF' then
			if P_HIGH_LEVEL_CR is not null then
				DECL_ON_CRED_REF	:= null;
			end if;
			if not DECL_ON_CRED_REF is null then
				::[CRED_INTERFACE].[PRX_DECL_ON_GET].SET_GLOBAL_DECL(null);
				::[CRED_INTERFACE].[PRX_DECL_ON_GET].set_from_decl(
					DECL_ON_CRED_REF
					,this
					,FT_CREDIT
					,CLIENT
					,P_KIND_CREDIT
					,P_HIGH_LEVEL_CR
					,SUMMA
					,V_SUM_STR
					,PERIOD
					,V_PRC_RATE
					,P_OBJECTS_CRED
					,V_ANNUITET
					,V_DATE_GIVE
					,DIC_TYPE_CRED
					,DATE_ENDING
					,DATE_BEGIN
					,P_FILIAL
					,P_DEPART
					,P_PERIOD_UNIT
					,fPenMainRate
					,fPenPrcRate
					,P_NUM_CONTR
					,V_EARLY_PAY
					,NUM_DOG
					,P_PERIOD_WD
					,P_BALLOON_PAYMENT);
				Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
				if DIC_TYPE_CRED is null then
					pragma error('Не указано правило учета договора!');
				end if;
				if not(CLIENT is null) and not(FT_CREDIT is null) then
					-- Устанавливаем клиента и валюту по заявке
					this.[FT_CREDIT] := FT_CREDIT;					
					reqs_cl_tmp := null;
					setClient();
				end if;
				::[PR_CRED].[NEW_DOG_N].get_def_prc_schemes (kind_cred.[COMISS_ARR], FT_CREDIT, DATE_BEGIN, this.[COMISS_ARR], P_DEPART, V_PRC_SCH_TBL, V_CREDIT_ARR, V_PRC_RATE, this);

				declare
					rScheme ref [PRC_SCHEME];
					Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
				begin
					rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme_R(
							'НЕУЧТЕН_ПРОЦЕНТЫ',
							V_PRC_RATE,
							rScheme,
							V_CREDIT_ARR,
							this,
							Oper_Day,
							Oper_Day,
							V_ANNUITET,
							V_ONE_DAY,
							FT_CREDIT);	-- BS00133030
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
				end;

				if not (fPenMainRate is null) then			
					declare
						rScheme ref [PRC_SCHEME];
						Scheme_Name ref [VID_DEBT] := &LCONST.VD_CREDIT_PENY;
					begin
						rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
						Prc_Arr(::[PR_CRED].[NEW_DOG_N].Find_Prc_Arr('ПЕНЯ_КРЕДИТ', Prc_Arr)).[Proc_Arr] := rScheme.[LIST_SCH_PRC];
						::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
								'R',
								'ПЕНЯ_КРЕДИТ',
								fPenMainRate,
								rScheme,
								Prc_Arr(::[PR_CRED].[NEW_DOG_N].Find_Prc_Arr('ПЕНЯ_КРЕДИТ', Prc_Arr)).[Proc_Arr],
								this,
								Oper_Day,
								Oper_Day,
								V_ANNUITET,
								V_ONE_DAY,
								FT_CREDIT);	-- BS00133030
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
					end;

				end if;
				if not (fPenPrcRate is null) then
					declare
						rScheme ref [PRC_SCHEME];
						Scheme_Name ref [VID_DEBT] := &LCONST.VD_PRC_PENY;
					begin
						rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
						Prc_Arr(::[PR_CRED].[NEW_DOG_N].Find_Prc_Arr('ПЕНЯ_ПРОЦЕНТЫ', Prc_Arr)).[Proc_Arr] := rScheme.[LIST_SCH_PRC];
						::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(
								'R',
								'ПЕНЯ_ПРОЦЕНТЫ',
								fPenPrcRate,
								rScheme,
								Prc_Arr(::[PR_CRED].[NEW_DOG_N].Find_Prc_Arr('ПЕНЯ_ПРОЦЕНТЫ', Prc_Arr)).[Proc_Arr],
								this,
								Oper_Day,
								Oper_Day,
								V_ANNUITET,
								V_ONE_DAY,
								FT_CREDIT);	-- BS00133030
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
					end;			

				end if;
				kind_cred := P_KIND_CREDIT;
	
				--v-- BS00133979. После определения вида кредита через КВУ проверим возможность работы с правилами	
				if [FL_RATE_RULE].[LIB].Check_UseFLR2KindCred(P_KIND_CREDIT, P_HIGH_LEVEL_CR) or [FL_RATE_RULE].[LIB].FindPrcRule(this) then
					fl_rule_on;
				else
					fl_rule_off;
				end if;
				--^-- BS00133979
	
				::[PR_CRED].[NEW_DOG_N].Fill_COMISS_ARR(this.[COMISS_ARR], kind_cred.[COMISS_ARR], P_DEPART);	
				::[PR_CRED].[NEW_DOG_N].FillPrcTable(this.[COMISS_ARR], V_PRC_SCH_TBL, V_PRC_ADD, true, this, P_KIND_CREDIT, vUseFLRule);				
				
				::[PR_CRED].[NEW_DOG_N].FillComissTable (this.[COMISS_ARR], V_COMISS_TBL);			

				V_INVOICE := nvl( kind_cred.[INVOICE], false);
				if kind_cred.[MAX_PERIOD_NUM] is not null and kind_cred.[MAX_PERIOD_MS] is not null then
					V_DATE_ENDING_MAX := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].DayPeriodAdd( coalesce(V_DATE_GIVE, DATE_BEGIN), kind_cred.[MAX_PERIOD_NUM], kind_cred.[MAX_PERIOD_MS], null, null, kind_cred.[PERIOD_WD]);
				end if;
				if not(kind_cred.[WAY_CRED] is null) then
					P_OPER_WAY_OUT := kind_cred.[WAY_CRED];
				end if;
			end if;
			if V_INVOICE then	-- BFS00027595
				V_DATE_ENDING_MAX := null;
				[DATE_ENDING_MAX] := null;
			end if;
			::[PR_CRED].[NEW_DOG_N].validate_form( P_HIGH_LEVEL_CR, DIC_TYPE_CRED, V_CR_CLASS, V_IS_FOR_CRED_CARD, V_OPEN_DEP, V_DEST_STR);
			::[PR_CRED].[NEW_DOG_N].validate_invoice(V_INVOICE, V_DEST_STR, V_CR_CLASS);
			if V_CR_CLASS != 'KRED_PERS' and CLIENT%class != 'CL_PRIV' then		-- BFS00027399
				rPsOrg := CLIENT->(::[CL_CORP])[FORMA].[PS];
			else
				rPsOrg := null;
			end if;
			V_WAY_OUT_CODE := ::[PR_CRED].[NEW_DOG_N].validate_oper_way( V_CR_CLASS, FT_CREDIT, P_OPER_WAY_OUT, V_DEST_STR, rPsOrg);
		elsif p_info in ('%VAR%.V_GEN_AGR') then
			if V_GEN_AGR is not null then
				V_LIMIT_CR	:= V_GEN_AGR.[SUMMA];
				P_NUM_CONTR	:= V_GEN_AGR.[NUM_CONTRACT];
				P_OBJECTS_CRED%delete;
				P_OBJECTS_CRED.[NEW#AUTO](V_GEN_AGR.[AIM], null, null);
			end if;
     	elsif p_info = 'P_OBJECTS_CRED' then
			V_OBJ_CRED := [L_ALEX].get_main_obj(this);
		elsif p_info in ( 'OK', 'CANCEL') then
			::[CRED_INTERFACE].[PRX_ZALOG].Set_ref_prod(null);
			executor.set_context('ZALOG_PROD', null);
			executor.set_context('CRED_BUS_PROC', null);
			executor.set_context('$FL_RATE$SET$PROD', null);
			executor.set_context('$FL_RATE$SET$DEBT', null);
			executor.set_context('$FL_RATE$SET$CLCALSS', null);
			executor.set_context('$FL_RATE$SET$SCHEME', null);
			V_THIS := null;
		--v-- BS00140713
			if p_info = 'OK' then
				if Gl_rDepart_Res is not null and P_LOAN_PORT is null then -- используется настройка, и признак можно изменять на договоре
					declare
						iSign1 integer := 0;
						iSign2 integer := 0;
					begin					
						if nvl(::[PRODUCT].[L_RES].get_res_fil_sign(this.[RES_OTHER_FIL]),false) then
							iSign1 := 1;
						end if;
						if P_FILIAL_RES.[0] = 2 then
							iSign2 := 1;
						end if;
						
						if iSign1 + iSign2 = 1 then		-- значение признака было изменено на ЭФО	
							if this.[COM_STATUS] in (::[COM_STATUS_PRD]([CODE] = 'WORK'), ::[COM_STATUS_PRD]([CODE] = 'LOCK')) then		-- требуется перенос резерва
								-- может потребоваться перенос резервов в другой филиал, сделаем запрос на подтверждение
								[CSMD].ShowMsgDlg
										( V_DEST_STR
										, 'Form1'
										, 'Перенос резервов в другой филиал'
										, 'Будет списан резерв в текущем филиале и сформирован в новом. Продолжить?'
										, 'CHANGE_RES_FIL'
								);
							else
								-- достаточно просто изменить признак
								Gl_Change_Res_Fil := true;
							end if;
						end if;
					end;
				end if;
			else
				Gl_Change_Res_Fil := null;
				Gl_rDepart_Res := null;
			end if;
			
		elsif p_info = 'MAKE_DEPAULT_PP' then
			-- Запуск пересчета параметров планирования, если это необходимо (по ОК или при переходе на вкладку "Планирование")			
			
			--Чтобы корректно рассчитать ПП по комиссиям, нужно сохранить таблицы процентов и тарифов на договоре
			::[PR_CRED].[NEW_DOG_N].SaveComissTable(this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);
			pragma get_this;
			
			if bRebuildParam4Plan then
				begin
					call_make_plan_pr();
					V_DEST_STR := V_DEST_STR || NL$ || ' Call Form1.ScriptServerValidate(Nothing, "Планировать")';
				exception
					when others then
						bRebuildParam4Plan := false;
						raise;
				end;
			end if;
			
		elsif p_info = 'CHANGE_RES_FIL' then
			Gl_Change_Res_Fil := true;	
		--^-- BS00140713
		elsif P_INFO = '%VAR%.V_INVOICE' then
			V_INVOICE	:= nvl(V_INVOICE, false);
			if V_INVOICE then
				DATE_ENDING		:= null;
				PERIOD			:= null;
				DIC_TYPE_CRED	:= &LCONST.TC_CRED_CONT;
				P_HIGH_LEVEL_CR	:= null;
			end if;

		elsif  P_INFO like '%VAR%.V_INVOICE_COND.PAY_BEGIN_DATE%'
			or P_INFO like '%VAR%.V_INVOICE_COND.END_DATE%'
			or P_INFO like '%VAR%.V_INVOICE_COND.START_SUMMA%'
			or P_INFO like '%VAR%.V_INVOICE_COND.PLAN_PERCENT%'
		then
			if V_INVOICE_COND.exists(V_INVOICE_IDX) then
				if V_INVOICE_COND(V_INVOICE_IDX).PAY_BEGIN_DATE is null then
					V_INVOICE_COND(V_INVOICE_IDX).PAY_BEGIN_DATE := DATE_BEGIN;
				end if;
				if V_INVOICE_COND(V_INVOICE_IDX).END_DATE is null then
					V_INVOICE_COND(V_INVOICE_IDX).END_DATE := to_date('01/01/4012','dd/mm/yyyy');
				end if;
			end if;

	--v-- Параметры планирования (начало)

		-- Нажали кнопку "Добавить"
		elsif p_info = 'AddP4P' then
			::[CRED_INTERFACE].[PRX_PLAN].PFP_Set_Edit_Auto_v_Cred( this );
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				if Form1.ScriptPlayEx("<% PLPCALL %VAR%.V_PARAM_FOR_PLAN_REF := [PARAM_FOR_PLAN].[NEW#AUTO]() %>") then
					Call Form1.ScriptServerValidate(Nothing, "ADDING_P4P")
					Execute DEST_STR.TEXT
					GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
				end if
			' || NL$;
		
		-- Добавили новый параметр планирования, обрабатываем это
		elsif p_info = 'ADDING_P4P' then
			V_PARAM_FOR_PLAN_A%insert(V_PARAM_FOR_PLAN_REF);
			Update_P4P_Grid;

		-- Нажали кнопку "Изменить"
		elsif p_info = 'EditP4P' then
			if V_P4P_IDX > 0 then
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_Set_Edit_Auto_v_Cred( this );
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					if Form1.ScriptPlayEx("<% CALL PARAM_FOR_PLAN EDIT#AUTO '||V_PARAM_FOR_PLAN_REF||' %>") then
						tmpIdx = V_P4P_IDX.TEXT
						GridParam4Plan.DeleteRow(GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT))
						Call Form1.ScriptServerValidate(Nothing, "EDITING_P4P")
						Execute DEST_STR.TEXT
						V_P4P_IDX.TEXT = tmpIdx
						GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
					end if
				' || NL$;
			end if;

		-- Изменили параметр планирования, обрабатываем это
		elsif p_info = 'EDITING_P4P' then
			Update_P4P_Grid;

		-- Удалили параметр планирования, обрабатываем это
		elsif p_info = 'DELETING_P4P' then
			if V_P4P_GRID.exists(V_P4P_IDX) then
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_DELETE_AUTO(V_PARAM_FOR_PLAN_REF);
				V_PARAM_FOR_PLAN_REF := null;
				Update_P4P_Grid;
			end if;
		
		-- Нажали кнопку "Умолчание"
		elsif p_info = 'Умолчание' then
			-- Если имеется заявка на досрочное погашение/перепланирование по данному договору, сообщаем об этом пользователю
			rDECL_EARLY_P := null;
			for
			(
				select zayavka(zayavka : z)
				in ::[DECL_EARLY_P] all
				where zayavka.[CRED_REF] = this
			)
			loop
					rDECL_EARLY_P := zayavka.z;
					exit;
			end loop;
			
			if rDECL_EARLY_P is null then	-- заявок нет
				if V_USE_PLAN_RULE then
					--если конструктор планирования, то индивидуальные настройки сбрасываются, восстанавливается конструктор с вида кредита
					call_make_plan_pr();
					
				else
					if V_COPY_HL_PP is null then
						V_COPY_HL_PP := true; --если не зайдем в цикл
						for
						(	
							select pp(pp.[OPER] : oper)
							in P_HIGH_LEVEL_CR.[PARAM_FOR_PLAN]
							where pp.[COPY_TO_TRANSH] = true
						)
						loop
							if [FP_TUNE].[LIB].get_bool_value('COPY_HIGH_LEVEL_PP',
												::[FP_TUNE].[LIB].set_canons('METACLASS', this%class
																			, 'DEPART', P_HIGH_LEVEL_CR.[DEPART]%id
																			, 'KIND_PROJECT', P_KIND_CREDIT.[TYPE_PROJECT]%id
																			, 'KIND_CREDITS', P_KIND_CREDIT%id)
											, '0')
							then
								V_DEST_STR := V_DEST_STR || NL$ || ' vAns = MsgBox ("Копировать параметры планирования из КВУ?", vbYesNo)'
													||nl$||'if vAns = vbYes then'||nl$||'V_COPY_HL_PP = true'||nl$||'else'||nl$||'V_COPY_HL_PP = false'||nl$||'end if'
													||nl$||'Call Form1.ScriptServerValidate(Nothing, "Умолчание")';
								V_COPY_HL_PP := null; -- чтобы не вызвать первый раз call_make_plan_pr
								exit;
							end if;
						end loop;
					end if;
					
					if V_COPY_HL_PP is not null then
						call_make_plan_pr(false);
						V_COPY_HL_PP := null;
					end if;
				end if;
			else
				[CSMD].Command(V_DEST_STR, 'MsgBox "По договору имеется заявка на досрочное погашение/перепланирование", ,"Сообщение"');	
			end if;
			
		-- Нажали кнопку "Планировать"
		elsif p_info = 'Планировать' then
			if V_P4P_GRID.exists(V_P4P_IDX) then
				::[PR_CRED].[NEW_DOG_N].SaveComissTable(this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);
				pragma get_this;
				
				-- установим вид льготного периода, именно перед началом планирования так как мы могли менять вид кредита и заходить при этом на вкладку планирования
				if [COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
 					if P_KIND_CREDIT.[GRACE_VAR] is not null then
	 					-- чтобы не добавлялись некорректные записи в историю почистим историю
				 		if coalesce(dateHist, DATE_BEGIN)	< DATE_BEGIN then
				 			::[GRACE_VAR_HIST].[LIB].DelGrace(this);
				 		end if;
				 		::[GRACE_VAR_HIST].[LIB].pSetGrace(this, DATE_BEGIN, P_KIND_CREDIT.[GRACE_VAR]);
				 		dateHist := DATE_BEGIN;
				 	else
				 		::[GRACE_VAR_HIST].[LIB].DelGrace(this);
				 	end if;	
				end if;
				
				--МОП
				dCalcMop := GetDateCalcMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				if bMop and dCalcMop is not null then
					::[CRED_INTERFACE].[PRX_PLAN].PLAN_MOP(this, dCalcMop);
				end if;
				V_PARAM_FOR_PLAN_REF := V_P4P_GRID(V_P4P_IDX);
				::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, V_PARAM_FOR_PLAN_REF, nvl(V_PLAN_ALL, false), null);
				::[CRED_INTERFACE].[PRX_PLAN].PFP_delete_all_plan_dates(V_PARAM_FOR_PLAN_A, V_PARAM_FOR_PLAN_REF, V_PLAN_ALL, null, P_KIND_CREDIT);
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					Do While GridParam4Plan.Rows > 1
						GridParam4Plan.DeleteRow(GridParam4Plan.Rows - 1)
					Loop
					Call Form1.ScriptServerValidate(Nothing, "PLAN_P4P")
					GridParam4Plan.Row = GridParam4Plan.RowByIndex(V_P4P_IDX.TEXT)
				' || NL$;
				
			end if;

		-- Спланировали, обновляем грид
		elsif p_info = 'PLAN_P4P' then
			Update_P4P_Grid();

		-- Пересчитали сумму аннуитета, обрабатываем это
		elsif p_info = 'RECALC_RAP' then
			Update_P4P_Grid();
			
		elsif p_info = '%VAR%.V_USE_PLAN_RULE' then
			--изменение значение признака "Конструктор планирования"
			--валидация фрейма с возможными действиями по конструктору планирования
			::[PR_CRED].[NEW_DOG_LIB].validateUsePlanRule(V_USE_PLAN_RULE, V_DEST_STR);
			
			--валидация МОП
			if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
				bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				if not V_USE_PLAN_RULE and (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = true');
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Visible = true');
					P_MOP_TYPE := P_KIND_CREDIT.[MOP_TYPE];
				else
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Enabled = false');
					[CSMD].Command(V_DEST_STR, 'FrameMOP.Visible = false');
					P_MOP_TYPE := null;
					bMop := false;
				end if;
			end if;
			
			--пересоздаем параметры планирования
			call_make_plan_pr();
			
		elsif p_info = 'BtnPRGeneral' then
			--настройка общих правил планирования
			&sp(ChangeRule)
			g_clickBtnRule := true;
			
			tPeriodPlanOnCred.delete;
			tPeriodPlanOnCred := ::[PR_DEBT].[LIB_GENERAL_RULE].getPeriodTuneOnPrCred(this, coalesce(DATE_GIVE, DATE_BEGIN), DATE_ENDING);
			&debug('.validate: tPeriodPlanOnCred '||tPeriodPlanOnCred.count,0)
			
			::[PR_CRED].[NEW_DOG_LIB].clickBtnGeneral(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
			
		elsif p_info = 'BtnPRSeason' then
			--настройка правил сезонности
			g_clickBtnSeason := true;
			&sp(prSeason)
			::[PR_CRED].[NEW_DOG_LIB].clickBtnSeason(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
				
		elsif p_info = 'SEASON_CANCEL' then
			--отмена в сезонности
			g_clickBtnSeason := false;
			&rb(prSeason)
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
		
		elsif p_info = 'BtnPRPoint' then
			--настройка дополнительных точек
			::[PR_CRED].[NEW_DOG_LIB].clickBtnPoint(this, V_DEST_STR);
			&debug('.validate: V_DEST_STR '||V_DEST_STR, 0)
			
		elsif p_info = 'BtnPRRecalc' then
			--пересоздаем параметры планирования
			call_make_plan_pr();
		
		elsif p_info = 'CHANGE_PLAN_RULE' then
			
			--вышли из общих правил
			if g_clickBtnRule then
				declare
					bChangeDayPay			boolean;
					bChangePeriod			boolean;
					bChangePrSum			boolean;
				begin
					--доступность "Настроить заново"
					V_NEED_DROP := false;
					::[PR_DEBT].[PR_DROP_POINT].dropGeneralPoint(null, this, bChangeDayPay, bChangePeriod, bChangePrSum, null, tPeriodPlanOnCred);
					if bChangeDayPay or bChangePeriod or bChangePrSum then
						g_needDropPoint := true;
					end if;
				end;
			end if;
			
			--вышли из форм операций по настройке конструктора планирования. необходимо пересчитать параметры планирования
			call_make_plan_pr();
			
		elsif p_info = 'CANCEL_DROP' then
			V_NEED_DROP 	:= false;
			g_needDropPoint := false;
			deleteSavepoint();
			tPeriodPlanOnCred.delete;
			
		elsif p_info = 'BtnPlanOnLine' then
			--вызов операции по визуализации графика на линии
			stdio.put_line_buf('<% PLPCALL [PLAN_OPER].[PLAN_ON_LINE](%PARAM%.P_CRED =>'''|| this%id || ''') %>');
			
	--^-- Параметры планирования (конец)



-- Ставка по кредиту
		elsif p_info in ('%VAR%.V_PRC_RATE', '%VAR%.V_CREDIT_ARR', 'SAVE_RATE_YES') then
			if p_info = '%VAR%.V_CREDIT_ARR' then
				sign := 'A';
			else
				sign := 'R';
			end if;

			declare
				rScheme ref [PRC_SCHEME];
				Scheme_Name ref [VID_DEBT] := &LCONST.VD_CALC_PRC;
			begin
				rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], Scheme_Name);
				
				-- проверим использование схемы другими договорами
				if p_info = '%VAR%.V_PRC_RATE' then
					bCanSaveRate := true;
					V_CAN_PRC_SCH := 1;
					for
					(
						select comisar('1') in ::[DEBT_COMISS_PRC] collections
						where comisar%collection != this.[COMISS_ARR]
							and comisar.[PRC_SCHEME] = rScheme
					)
					loop
						bCanSaveRate := false; -- запрещаем текущее обновление ставки
						V_CAN_PRC_SCH := 0;
						--Проверим права пользователя на операцию PRC_SCH_ACCESS
						if [RUNTIME].[SECURITY].Is_Method_Accessible('PRC_SCHEME', 'PRC_SCH_ACCESS', [stdlib].userid.[USERNAME]) then
							--есть права, предоставим выбор что сделать со ставкой
							V_DEST_STR := V_DEST_STR || NL$ ||
							'
							if Form1.ScriptPlayEx("<% PLPCALL [PRC_SCHEME].[PRC_SCH_ACCESS](%PARAM%.P_COPY_SCH => ''FALSE'', %PARAM%.P_VALUE => %VAR%.V_CAN_PRC_SCH) %>") then
								Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_YES")
							else
								Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_NO")
							end if
							' || NL$;						
						else
							--нет прав, откатываем изменение ставки
							V_DEST_STR := V_DEST_STR || NL$ ||
							'
							if MsgBox("У вас нет прав на изменение общей процентной схемы.", vbOKOnly, "Внимание!") = vbOK then
								Call Form1.ScriptServerValidate(Nothing, "SAVE_RATE_NO")
							end if
							' || NL$;
						end if;
						exit;
					end loop;
				end if;
				
				-- если пользователь сохраняет ставку
				if bCanSaveRate then
					if ::[PROL_CONTRACT].[LIB_FIND_REF].is_exists_scheme_in_tp(rScheme) then			
						stdio.put_line_buf('Схема начисления процентов сформирована автоматически. Ручное редактирование запрещено!');
						V_PRC_RATE := ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC) , greatest(Oper_Day, DATE_BEGIN), 0, 0, false, false);
						-- обновить в таблице значение ставки
						if not (V_PRC_SCH_TBL.first is null) then
							for idxSch in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
								where V_PRC_SCH_TBL(idxSch).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
								V_PRC_SCH_TBL(idxSch).[PRC]	= V_PRC_SCH_TBL(idxSch).[RES_RATE]	:= V_PRC_RATE;
							end loop;
						end if;
						return;
					end if;
					&debug('Пользователь выбрал вариант изменения процентной схемы V_CAN_PRC_SCH = '||V_CAN_PRC_SCH,0)
					if V_CAN_PRC_SCH = 2 then
						--выбрали копирование схемы
						::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], null, Scheme_Name);
						rScheme := null;
						V_CREDIT_ARR := null;
					end if;
				
					::[PR_CRED].[NEW_DOG_LIB].Set_Prc_Scheme(sign
												,'НЕУЧТЕН_ПРОЦЕНТЫ'
												,V_PRC_RATE
												,rScheme
												,V_CREDIT_ARR
												,this
												,DATE_BEGIN
												,greatest(Oper_Day, DATE_BEGIN)
												,V_ANNUITET
												,V_ONE_DAY
												,FT_CREDIT);	-- BS00133030
					::[PR_CRED].[NEW_DOG_LIB].Set_Scheme_In_Arr(this.[COMISS_ARR], rScheme, Scheme_Name);
		
					-- обновить в таблице
					if not (V_PRC_SCH_TBL.first is null) then
						for idxSch in V_PRC_SCH_TBL.first .. V_PRC_SCH_TBL.last
							where V_PRC_SCH_TBL(idxSch).[REQ_NAME] = 'НЕУЧТЕН_ПРОЦЕНТЫ' loop
							V_PRC_SCH_TBL(idxSch).[PRC_REF]	:= ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC);
							V_PRC_SCH_TBL(idxSch).[PRC]		:= V_PRC_RATE;
							V_PRC_SCH_TBL(idxSch).[PRC_ARR]	:= V_CREDIT_ARR;
							V_PRC_SCH_TBL(idxSch).[RES_RATE]:= ::[CRED_INTERFACE].[PRX_PRC_SCHEME].GetPrcRate( V_PRC_SCH_TBL(idxSch).[PRC_REF], Oper_Day);
							V_PRC_ADD                   	:= 'Ставка: '||to_char(V_PRC_SCH_TBL(idxSch).[RES_RATE], '99990D00000000')||' %';
						end loop;
					end if;
				end if;
			end;
			
			bRebuildParam4Plan := true;

		elsif p_info = '+' then
			if	NUM_DOG is null then
				if not(P_KIND_CREDIT.[NUM_SHABL] is null) then
					if P_OVD_ACCOUNT is not null then
						[OVER_ON_PROD] := P_PRODUCT;
					end if;
					NUM_DOG := [GET_NEW_NUM_DOG](P_KIND_CREDIT.[NUM_SHABL]);
				end if;
				if NUM_DOG is null and P_G_AGRIMENT is not null then
					for over in P_G_AGRIMENT.[OVERDRAFTS]
					loop
						cnt := cnt + 1;
					end loop;
					NUM_DOG := P_G_AGRIMENT.[NUM_DOG]||'-'||to_char(cnt);
				end if;
				[NUM_DOG]	:= NUM_DOG;
			else
				[STDIO].put_line_buf('Уже заполнен номер договора, удалите его для генерации нового!');
			end if;
		elsif p_info = 'X' then
			if P_OVD_ACCOUNT is not null then
				SUMMA := ::[PR_CRED].[CALC_LIMIT](P_OVD_ACCOUNT, null, DATE_BEGIN);
				if not (SUMMA is null) and not(FT_CREDIT is null) then
					V_SUM_STR := ::[RUNTIME].[STDLIB].N2Str(SUMMA, FT_CREDIT.[CUR_SHORT]);
				end if;
			else
				pragma error ('Не указан счет, по которому предоставлен овердрафт');
			end if;
		end if;

		-- если на ЭФО изменили номер КВУ (вид кредита, даты), массив "Варианты расчета индивидуальных приоритетов"
		-- скопируем/удалим в договор в зависимости от заполненности номера КВУ
		if P_INFO in ('P_KIND_CREDIT', 'DATE_BEGIN', 'DATE_ENDING', '%VAR%.P_HIGH_LEVEL_CR') then
			if (P_HIGH_LEVEL_CR is null or nvl(P_HIGH_LEVEL_CR.[INVOICE], false)) and P_KIND_CREDIT is not null then
				::[PR_CRED].[NEW_DOG_N].get_calc_vertion (this, P_KIND_CREDIT, DATE_BEGIN, DATE_ENDING);
			else
				::[PR_CRED].[NEW_DOG_N].delete_calc_version(this);
			end if;
		end if;
		
		if V_CR_CLASS = 'OVERDRAFTS' then
			if	p_info = 'P_OVD_ACCOUNT' and P_OVD_ACCOUNT is not null then
				P_PRODUCT := ::[PR_CRED].[NEW_DOG_N].locate_product (P_OVD_ACCOUNT);
				::[PR_CRED].[NEW_DOG_N].locate_over_by_product(P_PRODUCT);
				if not P_OVD_ACCOUNT is null then
					CLIENT := P_OVD_ACCOUNT.[CLIENT_V];
					FT_CREDIT := P_OVD_ACCOUNT.[FINTOOL];
					V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
					V_CLIENT_REQ.[1].[1] := CLIENT;
					V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;
				end if;
				
			elsif p_info = 'P_G_AGRIMENT' then
				P_ACCOUNT		:= null;
				[LIB_EXT].delete_acc_ref (this);
				if P_G_AGRIMENT is null then
					this%collection := null;
					::[PR_CRED].[NEW_DOG_N].validate_gen_arg(P_G_AGRIMENT, V_DEST_STR);
				else
					insert this into P_G_AGRIMENT.[OVERDRAFTS];
					set_from_gen_agr;
				end if;
			elsif p_info = 'P_PRODUCT' then
				if P_PRODUCT is null then
					P_OVD_ACCOUNT := null;
					V_CLIENT_REQ.[0] := 1;
					V_CLIENT_REQ.[1].[1] := null;
					V_CLIENT_REQ.[1].[2] := null;
				else
					::[PR_CRED].[NEW_DOG_N].locate_over_by_product(P_PRODUCT);
					P_OVD_ACCOUNT := P_PRODUCT.[GET_ACC_PROD](::[TIP_ACC]([COD]='MAIN_PROD_ACCOUNT'));
					if not P_OVD_ACCOUNT is null then
						CLIENT := P_OVD_ACCOUNT.[CLIENT_V];
						FT_CREDIT := P_OVD_ACCOUNT.[FINTOOL];
						V_CLIENT_REQ.[0] := 1;  -- По умолчанию для расчетов по кредиту используем счет, по которому предоставлен овердрафт
						V_CLIENT_REQ.[1].[1] := CLIENT;
						V_CLIENT_REQ.[1].[2] := P_OVD_ACCOUNT;
					end if;
				end if;
				
			end if;
			if p_info != 'CANCEL' then
				if not P_G_AGRIMENT is null then
					if DATE_BEGIN is not null and DATE_BEGIN < P_G_AGRIMENT.[DATE_BEGINING] then
						pragma error('Дата начала не может быть меньше даты начала Ген. Соглашения');
					end if;
					if DATE_ENDING is not null and DATE_ENDING > P_G_AGRIMENT.[DATE_ENDING] then
						DATE_ENDING := P_G_AGRIMENT.[DATE_ENDING];
					end if;
					if P_G_AGRIMENT.[SUMMA] is not null and SUMMA is not null and SUMMA > P_G_AGRIMENT.[SUMMA] then
						pragma error ('Сумма договора '||SUMMA||' не может быть больше лимита кредитования генерального соглашения '||P_G_AGRIMENT.[SUMMA]);
					end if;
				end if;
			end if;
		end if;

		if p_info = '%VAR%.V_CLIENT_REQ.1.1' then
			if V_CLIENT_REQ.[1].[1] is null or V_CLIENT_REQ.[1].[2].[CLIENT_V] != V_CLIENT_REQ.[1].[1] then
				V_CLIENT_REQ.[1].[2] := null;				
			end if;
		elsif p_info = '%VAR%.V_CLIENT_REQ.1.2' then
			if V_CLIENT_REQ.[1].[1] is null or V_CLIENT_REQ.[1].[2].[CLIENT_V] != V_CLIENT_REQ.[1].[1] then
				V_CLIENT_REQ.[1].[1] := V_CLIENT_REQ.[1].[2].[CLIENT_V];
			end if;
		-- OscaR - Проверка счета на правильность заполнения
		elsif p_info in ('%VAR%.V_CLIENT_REQ.2.1', '%VAR%.V_CLIENT_REQ.2.3', '%VAR%.V_CLIENT_REQ.2.FRIENDS') then
			sErrMess := ::[PR_CRED].[L_2].check_client_req(V_CLIENT_REQ, p_info);
			if sErrMess is not null then
				[CSMD].Command(V_DEST_STR, 'MsgBox "'||sErrMess||'", , "Предупреждение"');
			end if;			
		end if;
		-- End OscaR - Проверка счета на правильность заполнения
		
		-- поработаем со сроком для транша, устанавливаемом на КВУ --
		if p_info in ('%VAR%.V_TRANSH_PERIOD_NUM'
					, '%VAR%.V_COPY_TO_TRANSH'
					, 'P_KIND_CREDIT'
					, 'DATE_BEGIN'
					, 'DATE_ENDING'
					, '%VAR%.V_DATE_GIVE'
					, 'P_PERIOD_UNIT'
					, 'PERIOD'
					)
		and coalesce(this.[COM_STATUS], &LCONST.STATUS_WAIT_CONF) = &LCONST.STATUS_WAIT_CONF
		then
			::[PR_CRED].[NEW_DOG_N].ValidateTranshPeriodNum(p_info
															,V_DEST_STR
															,V_TRANSH_PERIOD_NUM
															,PERIOD
															,V_TRANSH_PERIOD_UNIT
															,P_PERIOD_UNIT
															,V_COPY_TO_TRANSH
															,V_DATE_GIVE
															,DATE_BEGIN
															,DATE_ENDING
															,DIC_TYPE_CRED
															,V_CR_CLASS
															,P_PERIOD_WD
															,sCalendar
															);
				
		end if;
		----------------------------------------------------------------		
		
		if p_info in ('DATE_BEGIN', 'DATE_ENDING', 'PERIOD', 'P_PERIOD_UNIT','FT_CREDIT','SUMMA','P_BALLOON_PAYMENT') then
			if ISBalloon then
				pragma set_this;
	  			[STR].set_par(sADDS,'P_INFO',P_INFO);
				::[HOOK].[CRED_CALC_BAL](SUMMA,P_BALLOON_PAYMENT,this,sADDs);
			end if;
		end if;
		if p_info in ('P_KIND_CREDIT', '%VAR%.V_INVOICE') then
			if	(this%class in ('KRED_CORP', 'KRED_PERS') and P_KIND_CREDIT.[REG_RULES].[PS] is not null)
				or V_INVOICE
				or (this%class = 'OVERDRAFTS' and P_KIND_CREDIT.[REG_RULES] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and P_KIND_CREDIT.[LINE_TRANSH] is not null)
			then
				[CSMD].Command(V_DEST_STR, 'Gridcol34.Visible = true');
			else
				[CSMD].Command(V_DEST_STR, 'Gridcol34.Visible = false');
			end if;
		end if;
		--v-- BS00140713 Если филиал поменялся, проверим настройку RES_IN_OTHER_FILIAL
		if p_info = 'P_FILIAL' then
			Check_Res_Filial;	-- BS00140713
		end if;
		--^-- BS00140713
		
		if p_info = '%VAR%.V_CALENDAR' then
			sCalendar := ::[PRODUCT].[LIB_01].GetCurCalendarName(this, V_CALENDAR%id);
			P_CALENDAR_NAME := sCalendar;
			PR_CRED.[L_2].strong_check_hollydays_err_msg(DATE_ENDING, this%class, sCalendar);
			this.[CALENDAR_NAME] := P_CALENDAR_NAME;
		end if;
		if p_info = 'SET_PROD_TUNE' then
			--индивидуальные настройки планирования
			V_DEST_STR := V_DEST_STR||NL$||
				'
				if Form1.ScriptPlayEx("<% PLPCALL %VAR%.V_SET_TUNE_CR_CHANGE := %THIS%.[SET_TUNE_CR](%PARAM%.P_PR_CRED => '''||this%id||''') %>") then
					Call Form1.ScriptServerValidate(Nothing, "SET_TUNE_CR_CHANGE")
				end if
				'
				||NL$;
		
		elsif p_info = 'SET_TUNE_CR_CHANGE' then
			--если изменились индивидуальные настройки, то нужно перестроить параметры планирования
			&debug('.validate: V_SET_TUNE_CR_CHANGE '||V_SET_TUNE_CR_CHANGE, 0)
			if not V_SET_TUNE_CR_CHANGE is null and V_USE_PLAN_RULE then
				--пересоздаем параметры планирования
				call_make_plan_pr();
			end if;
		end if;
		if p_info = 'SET_TUNE_LIMIT' then
			stdio.put_line_buf('<% PLPCALL %THIS%.[SET_TUNE_LIMIT]() %>');
		end if;
		
		if p_info = '%VAR%.V_RT_NUK' then
			if V_CHANGE_RULE is null then
				V_CHANGE_RULE := constructor('CHANGE_RULE');
				V_CHANGE_RULE.[RT_NUK] := V_RT_NUK;
				V_CHANGE_RULE.[RT_VALUE_HIST].[ADD_CURRENT]();
			else
				V_CHANGE_RULE.[RT_NUK] := V_RT_NUK;
				rValueHist := ::[RT_VALUE_HIST].[LIB].get_actual(V_CHANGE_RULE.[RT_VALUE_HIST]);
				rValueHist.[RT_NUK] := V_RT_NUK;
			end if;
			
			if not V_CHANGE_RULE.[RT_NUK] is null then
				V_CHANGE_RULE.[CRED] := this;
				[CHANGE_RULE]::[NEW#AUTO].reloadTuneValue(V_CHANGE_RULE, V_CHANGE_RULE.[RT_NUK]);
			else
				V_CHANGE_RULE := null;
			end if;
		end if;
		if p_info = '%VAR%.V_CHANGE_RULE.RT_TUNE_VALUE' then
			dDate_reg := V_CHANGE_RULE.[DATE_REG];
			if DATE_BEGIN != dDate_reg then
				pragma error ('Дата регистрации условий реструктуризации должна быть равна дате начала договора!');
			end if;
		end if;
		if p_info = 'SET_IND_RATES' then
			stdio.put_line_buf('<% PLPCALL [IND_RATES].[SET_IND_RATES](%PARAM%.P_PRODUCT =>'''|| this%id || ''') %>');
		end if;
		
		if p_info in ('DATE_BEGIN', 'P_KIND_CRED') then
			-- определим профиль гашения
			v_distr_profile := ::[PR_CRED].[NEW_DOG_N].get_profile(this%id, Oper_day, P_KIND_CREDIT);
		end if;
		
		if p_info = 'P_KIND_CREDIT' then
			if V_FACTOR_MP is not null then
				if V_FACTOR_MP.[CRED] = this then
					V_FACTOR_MP.[DELETE_AUTO]();
					V_FACTOR_MP := null;
				end if;
			end if;
			InitFactorTune();
		end if;
		
		if p_info = 'DATE_ENDING' and V_FACTOR_MP is not null then
			this.[DATE_ENDING] := DATE_ENDING;
			RecalcFactorTune();
		end if;

		if p_info = '%VAR%.V_SUM_PAYMENT' then
			if ::[FACTOR_MP].[LIB].IsFactorMPForCred(rFirstFactorMPRec) then
				V_FACTOR_MP := this.[MAKE_DEF_MP]
					( P_KIND_CREDIT	== P_KIND_CREDIT
					, P_DATE_BEGIN	== coalesce(V_DATE_GIVE, DATE_BEGIN)
					, P_PLAN		== false
					, P_DATE_SYNCH	== null
					, P_SUM_PAYMENT	== V_SUM_PAYMENT
					);
				InitFactorTune();
				&msg(&METHOD$ || '.Validate: После изменения первого платежа: Дата начала = ' || to_char(rFirstFactorMPRec.[DATE_BEGIN], 'dd/mm/yy') || ', Сумма = ' || rFirstFactorMPRec.[SUM_PAYMENT]);
			end if;
			
		end if;
		
		if p_info = 'FACTOR_MP_DEFAULT' then
			V_FACTOR_MP := this.[MAKE_DEF_MP]
				( P_KIND_CREDIT	== P_KIND_CREDIT
				, P_DATE_BEGIN	== coalesce(V_DATE_GIVE, DATE_BEGIN)
				, P_PLAN		== false
				, P_DATE_SYNCH	== null
				, P_SUM_PAYMENT	== V_SUM_PAYMENT
				);
			if (V_FACTOR_MP is not null) then
				V_FACTOR_MP_ARR := V_FACTOR_MP.[FACTOR_MP_ARR];
			end if;
			RecalcFactorTune();
		end if;
		
		-- vv МОП vv --
		if p_info in ('P_KIND_CREDIT', 'DATE_BEGIN', 'TarifMOP') then
			mop_validate();
		end if;
		-- ^^ МОП ^^ --
		if p_info='Add_prop' then
			V_DEST_STR := V_DEST_STR || NL$ ||
			'
				if Form1.ScriptPlayEx("<%  PLPCALL %VAR%.V_REF_PROP:= [PROPERTY_PROD].[NEW_AUTO](%PARAM%.P_PROD =>'''|| this%id||''', %PARAM%.P_DATE_BEGIN => '''|| null || ''', %PARAM%.P_DATE_END => ''' || null|| ''', %PARAM%.P_KIND_PROP => ''' || null ||''',  %PARAM%.P_VALUE_PROP => '''|| null||''') %>") then
					Call Form1.ScriptServerValidate(Nothing, "AFTER_ADD_PROP")
					V_OTHERS_TERM.Row = V_OTHERS_TERM.RowByIndex(V_OTHERS_TERM_IDX.TEXT)
				end if
			' || NL$;
		end if;
		if p_info='AFTER_ADD_PROP' then
			V_OTHERS_TERM(nvl(V_OTHERS_TERM.last,0)+1) := V_REF_PROP;
			if V_REF_PROP.[KIND_PROP].[TYPE_VALUE]='BOOLEAN' then
				if V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]='1' then
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Да';
				else
					V_OTHERS_TERM(V_OTHERS_TERM.last).[VALUE_PROP]:='Нет';
				end if;
			end if;
			V_OTHERS_TERM_IDX := V_OTHERS_TERM.last;
		end if;
		if p_info='Edit_prop' then
			if V_OTHERS_TERM.count != 0 then
				V_REF_PROP%id := V_OTHERS_TERM(V_OTHERS_TERM_IDX)%id;
				V_DEST_STR := V_DEST_STR || NL$ ||
				'
					if Form1.ScriptPlayEx("<%  PLPCALL  %VAR%.V_REF_PROP.[EDIT_AUTO](%PARAM%.P_PROD =>'''|| this%id||''', %PARAM%.P_DATE_BEGIN => '''|| V_REF_PROP.[DATE_BEGIN] || ''', %PARAM%.P_DATE_END => ''' || V_REF_PROP.[DATE_END]|| ''', %PARAM%.P_KIND_PROP => ''' || V_REF_PROP.[KIND_PROP] ||''',  %PARAM%.P_VALUE_PROP => '''|| V_REF_PROP.[VALUE_PROP]||''') %>") then
						Call Form1.ScriptServerValidate(Nothing, "AFTER_EDIT_PROP")
					end if
				' || NL$;
			end if;
		end if;
		if p_info='AFTER_EDIT_PROP' then
			V_OTHERS_TERM(V_OTHERS_TERM_IDX) := V_REF_PROP;
			if V_REF_PROP.[KIND_PROP].[TYPE_VALUE]='BOOLEAN' then
				if V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]='1' then
					V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]:='Да';
				else
					V_OTHERS_TERM(V_OTHERS_TERM_IDX).[VALUE_PROP]:='Нет';
				end if;
			end if;
		end if;
		if p_info = 'Del_prop' then
			if V_OTHERS_TERM.count != 0 then
				V_REF_PROP%id := V_OTHERS_TERM(V_OTHERS_TERM_IDX)%id;
				V_DEST_STR := V_DEST_STR || NL$ ||
					'
						V_OTHERS_TERM.DeleteRow(V_OTHERS_TERM.RowByIndex(V_OTHERS_TERM_IDX.TEXT))
						V_OTHERS_TERM_IDX.TEXT = V_OTHERS_TERM.IndexByRow(V_OTHERS_TERM.Row)
					' || NL$;
				V_REF_PROP.[DELETE_AUTO];
			end if;
		end if;
		if p_info in ('ADDING_P4P', 'EDITING_P4P', 'DELETING_P4P' ) then
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if not V_USE_PLAN_RULE and (P_KIND_CREDIT.[MOP_TYPE] is not null or bMop) and ::[PR_CRED].[LIB_SERVICE].check_app('1B290079') then
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = true');
			else
				[CSMD].COMMAND(V_DEST_STR,'FrameMOP.Visible = false');
				P_MOP_TYPE := null;
			end if;
		end if;
		if p_info='CRED_ASSURED' then
			stdio.put_line_buf('<% PLPCALL %THIS%.[SET_OBESP_CRED]() %>');
		end if;
		if p_info='CRED_CATEGORY' then
			stdio.put_line_buf('<% PLPCALL %THIS%.[CALC_CR_CATEGORY]() %>');
		end if;
		
		-- событие расчета существенности комиссий
		if p_info like 'CALC_IMPT_COM_%' then
			begin
				nIdxCmsRow := substr(p_info, 15);
				&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
				if V_COMISS_TBL.exists(nIdxCmsRow) and V_COMISS_TBL(nIdxCmsRow).[PRIORITY] is not null then
					presaveThis();
					V_COMISS_TBL(nIdxCmsRow).[IMPORTANCE] := ::[PR_CRED].[NEW_DOG_N].setImportanceDebt(V_COMISS_TBL(nIdxCmsRow), this);
				end if;
			exception
				when INVALID_NUMBER then
					--не смогли определить номер строки - ничего не делаем
					&debug('.validate: не определилась строка массива комиссий ' || p_info, 0)
					null;
			end;
		end if;

		-- событие расчета существенности процентов
		if p_info like 'CALC_IMPT_PRC_%' then
			declare
				oDebtComis		[DEBT_COMISS_PRC];
			begin
				nIdxCmsRow := substr(p_info, 15);
				&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
				if V_PRC_SCH_TBL.exists(nIdxCmsRow) and V_PRC_SCH_TBL(nIdxCmsRow).[PRIORITY] is not null then
					oDebtComis.[PRC_SCHEME] := V_PRC_SCH_TBL(nIdxCmsRow).[PRC_REF];
					oDebtComis.[DEBT] := V_PRC_SCH_TBL(nIdxCmsRow).[DEBT];
					V_PRC_SCH_TBL(nIdxCmsRow).[STOP_CALC] := ::[PR_CRED].[NEW_DOG_N].setImportanceDebt(oDebtComis, this);
				end if;
			exception
				when INVALID_NUMBER then
					-- не смогли определить номер строки - ничего не делаем
					&debug('.validate: не определили строку массива процентных схем ' || p_info, 0)
					null;
			end;
		end if;

		--событие изменения данных в таблице комиссий и тарифов
		if p_info like 'GRID_COMISS_CHNG%' then
			nIdxCmsRow := substr(p_info, 18);
			&debug('.validate: строка массива комиссий '||nIdxCmsRow, 0)
			if V_COMISS_TBL.exists(nIdxCmsRow) then
				rTypeDebt := V_COMISS_TBL(nIdxCmsRow).[DEBT].[TYPE_DEBT];
				&debug('.validate: тип задолженности '||rTypeDebt.[CODE], 0)
				-- 1) затрата, 2) комиссия, null) - прочее
				nOldPrior := V_COMISS_TBL(nIdxCmsRow).[PRIORITY];
				V_COMISS_TBL(nIdxCmsRow).[PRIORITY] := case rTypeDebt
											when &LCONST.TD_EXPENSE then 1
											when &LCONST.TD_COMMISS_PRC then 2
											else null
										end;
				--если первоначальное признание ФИ выполнено, то у всех добавляемых комиссий и затрат признак существенности устанавливается в "Нет"
				if nOldPrior is null and V_COMISS_TBL(nIdxCmsRow).[PRIORITY] is not null and V_INI_RECOG then
					V_COMISS_TBL(nIdxCmsRow).[IMPORTANCE] := false;
				end if;
				&debug('.validate: тип задолженности '||rTypeDebt.[CODE]||' Затрата='||V_COMISS_TBL(nIdxCmsRow).[CHK], 0)
			end if;
		end if;
		
	end if;
end;

execute is
	err_mess		varchar2(32000);
	sAdds 			varchar2(32000);
	iPeriod			integer;
	oChange_Rule	[CHANGE_RULE];

begin
	iPeriod := PERIOD;
	P_DEF_IFRS := coalesce (P_DEF_IFRS, false);

	if P_DEPART is null then
		P_DEPART := [STDLIB].userid.[DEPART];
		P_FILIAL := P_DEPART.[FILIAL];
		stdio.put_line_buf('Внимание! Выбранный филиал был заменен на "'||P_FILIAL.[SHORTLABEL]||'", поскольку подразделение не было заполнено.');
	end if;
	
	P_FILIAL := coalesce(P_FILIAL, P_DEPART.[FILIAL]);
	if P_FILIAL is null then
		pragma error ('Не указан филиал.');
	end if;

	Oper_Day := ::[PR_CRED].[SQL_LIB_CR_001].GetOpDateByFilial(P_FILIAL);
	
		
	if 	P_FILIAL		<> this.[FILIAL] 				--Филиал	
		or P_DEPART		<> this.[DEPART] 				--Подразделения
		or P_KIND_CREDIT<> this.[KIND_CREDIT] 			--Вид кредита
		or DATE_BEGIN	<> this.[DATE_BEGIN]			--Дата Начала
		or DATE_ENDING  <> this.[DATE_ENDING]			--Дата окончания
		or CLIENT		<> this.[CLIENT]				--Клиент
		or FT_CREDIT	<> this.[FT_CREDIT] then		--Валюта

		::[CRED_INTERFACE].[PRX_UU_NCB_INT].InsRecTA( pObj 		== this%id
													,pObjClass	== this%class
													,pClient 	== this.[CLIENT]
													,pVidOper	== ::[CRED_INTERFACE].[PRX_UU_NCB_INT].P_IR_CRED_EDIT_CRED
													);									
	end if;	
	
	if this.[DIC_TYPE_CRED] = ::[TYPES_CRED]([SHORT_NAME] = 'CRED_OVER') and (this%class = 'OVERDRAFTS' or nvl(this.[LIMIT_SALDO], 0) = 0) then
		V_LIMIT_SALDO := SUMMA;
	end if;

	if gen_frame is not null then
		if ::[PR_CRED].[NEW_DOG_LIB].check_gen_agreem_frame(this, DATE_BEGIN, DATE_ENDING, iPeriod, FT_CREDIT, CLIENT, SUMMA, P_FILIAL, P_DEPART, P_OBJECTS_CRED, V_LIMIT_SALDO, P_HIGH_LEVEL_CR, P_KIND_CREDIT, err_mess) = false then
			pragma error(err_mess);
		end if;
	end if;
	
	-- Условия востребования ---
	if V_INVOICE then
		declare
			nInvoiceSum	[SUMMA];
			iIdx		number;
		begin
	  		nInvoiceSum := 0;
	  		iIdx := V_INVOICE_COND.first;
			loop
				exit when iIdx is null;
				
				if nvl(V_INVOICE_COND(iIdx).[PLAN_PERCENT], false) then
					if V_INVOICE_COND(iIdx).START_SUMMA is null or V_INVOICE_COND(iIdx).START_SUMMA > 100 then
						pragma error('Не корректно указаны условия востребования');
					end if;
					V_INVOICE_COND(iIdx).START_SUMMA := SUMMA*V_INVOICE_COND(iIdx).START_SUMMA/100;
				end if;

				nInvoiceSum := nInvoiceSum + nvl(V_INVOICE_COND(iIdx).START_SUMMA,0);
				iIdx := V_INVOICE_COND.next(iIdx);
			end loop;
			
			if nInvoiceSum > SUMMA then
				pragma error('Общая сумма востребования превышает сумму договора');
			end if;
			
			::[PR_CRED].[NEW_DOG_LIB].FillOpersInvoice(this.[LIST_PLAN_PAY], FT_CREDIT, SUMMA, V_INVOICE_COND);
		end;
	end if;
	this.[INVOICE] := V_INVOICE;
	
	-- Запишем срок транша до смены даты начала договора --
	if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF and &IsCredLine then
		declare
			rRecPropTPN 	ref [PROPERTY_PROD];
		begin
			rRecPropTPN := ::[PROPERTY_PROD]%locate(x where x.[PROD] = this and x.[KIND_PROP] = propTRANSH_PERIOD_NUM and x.[DATE_BEGIN] = this.[DATE_BEGIN]);
			if V_TRANSH_PERIOD_NUM is null then
				delete x in ::[PROPERTY_PROD] all where x = rRecPropTPN;
			else
				update x(x.[VALUE_PROP] = V_TRANSH_PERIOD_NUM, x.[DATE_BEGIN] = DATE_BEGIN)
				in ::[PROPERTY_PROD] all
				where x = rRecPropTPN;
			end if;
		exception
			when NO_DATA_FOUND then
				if V_TRANSH_PERIOD_NUM is not null then
					::[PROPERTY_PROD].[LIB].AddProperty(this, DATE_BEGIN, null, propTRANSH_PERIOD_NUM, V_TRANSH_PERIOD_NUM);
				end if;
		end;
	end if;
	
	this.[DATE_BEGIN]		:= DATE_BEGIN;
	this.[DATE_GIVE]		:= V_DATE_GIVE;
	this.[PERIOD_UNIT]		:= P_PERIOD_UNIT;
	this.[NOTES]			:= NOTES;
	this.[FT_CREDIT]		:= FT_CREDIT;
	this.[DATE_ENDING]		:= DATE_ENDING;
	this.[DATE_ENDING_MAX]	:= V_DATE_ENDING_MAX;
	--Для контроля реквизита PN в структурах МСФО перебьем значением с нового клиента
	if this.[CLIENT]%id != CLIENT%id then
		::[CRED_INTERFACE].[PRX_IFRS].updateObjClientPN( this%id
														,this%class
														,CLIENT.[PN]);		
		
	end if;
	this.[CLIENT]			:= CLIENT;
	this.[SUMMA_DOG]		:= SUMMA;
	this.[DIC_TYPE_CRED]	:= DIC_TYPE_CRED;
	this.[OBJECTS_CRED]		:= P_OBJECTS_CRED;
	this.[SUMMA_PAY]		:= P_SUMMA_PAY;
	
	this.[DEPART]			:= P_DEPART;
	this.[FILIAL]			:= P_FILIAL;

	--	Для вексельной подсистемы
	pragma IF_DEF(VEKS_INST);
		if this.[ISSUE_VEK] is not null and this.[ISSUE_VEK] != nvl(P_ISSUE_VEK, -1) then
			this.[ISSUE_VEK].[MAIN_PROD] := null;
		end if;
		if P_ISSUE_VEK is not null then
			P_ISSUE_VEK.[MAIN_PROD] := this;
		end if;
		this.[ISSUE_VEK] := P_ISSUE_VEK;
	pragma END_IF;
	
	if P_DATE_PAYOUT_LTD is not null then
		if DATE_ENDING is not null and P_DATE_PAYOUT_LTD > DATE_ENDING then
			err_mess := err_mess || 'Предельная дата выдач не может быть больше даты окончания договора';
		end if;
		if nvl(DATE_GIVE, DATE_BEGIN) > P_DATE_PAYOUT_LTD then
			err_mess := err_mess || 'Предельная дата выдач не может быть меньше даты выдачи или даты начала действия';
		end if;
	end if;
	
	if DIC_TYPE_CRED is null then
		err_mess := err_mess || 'Не заполнено правило учета договора.';
	elsif this.[DIC_TYPE_CRED] = &LCONST.TC_CRED_OVER then
		if V_MAX_LIMIT_SALDO is not null and V_LIMIT_SALDO > V_MAX_LIMIT_SALDO then
			err_mess := err_mess || 'Значение максимального лимита задолженности должно быть больше лимита задолженности';
		end if;
	end if;
	if err_mess is not null then	pragma error (err_mess); end if;

	-- проверка заполнения реквизитов в режиме "Не клиент банка"
	if V_CLIENT_REQ.[0] = 2 then
		err_mess := ::[PR_CRED].[L_2].check_client_req(V_CLIENT_REQ);
		if err_mess is not null then
			pragma error(err_mess);
		end if;
	end if;
	
	-- зачистка неактивных реквизитов
	::[REQ_CLIENT].[LIBS].Refresh(V_CLIENT_REQ);

	this.[NUM_DOG]			:= NUM_DOG;
	this.[TURNOVER]			:= P_TURNOVER;
	this.[KIND_CREDIT]		:= P_KIND_CREDIT;

	this.[FOR_OPEN_PAY]		:= P_FOR_OPEN_PAY;
	this.[FOR_OPEN_BOOL]		:= P_FOR_OPEN_BOOL;
	this.[FOR_OPEN_YEAR]		:= P_FOR_OPEN_YEAR;
	this.[FOR_OPEN_FN]		:= P_FOR_OPEN_FN;
	if nvl(P_LMT_DAY_TO_PAY, 0) > 0 then
		::[PROPERTY_PROD].[LIB].AddProperty(
			  rProd == this
			, dDateBeg == DATE_BEGIN
			, dDateEnd == null
			, rKindProp == &propLimitDayToPay
			, sValueProp ==	to_char(P_LMT_DAY_TO_PAY)
		);
	else
		::[PROPERTY_PROD].[LIB].DelProperty(
			  rProd == this
			, rKindProp == &propLimitDayToPay
		);	
	end if;

	this.[GEN_AGR]			:= V_GEN_AGR;
	this.[SUMMA_PAY]			:= P_SUMMA_PAY;
	this.[DATE_GIVE]			:= V_DATE_GIVE;
	this.[NUM_CONTR]			:= P_NUM_CONTR;
	this.[HIGH_LEVEL_CR]		:= P_HIGH_LEVEL_CR;
	this.[COPY_TO_TRANSH]	:= nvl(V_COPY_TO_TRANSH, false);
	this.[OKOHX]				:= V_OKONH;
	this.[PRJ_KIND_CRED]  	:= V_PRJ_KIND_CRED;
	this.[ACCOUNT]			:= P_ACCOUNT;
	this.[CALENDAR_NAME]		:= P_CALENDAR_NAME;

	this.[CLIENT_REQ]	:= V_CLIENT_REQ;
	::[PRODUCT].[LIB_01].SetMainReqClient(this, V_CLIENT_REQ);

	::[PR_CRED].[NEW_DOG_N].SaveComissTable (this.[COMISS_ARR], V_COMISS_TBL, V_PRC_SCH_TBL);

	if ::[FACTOR_MP].[LIB].ParamUseFactor(this.[PARAM_FOR_PLAN]) then
		::[FACTOR_MP].[LIB].RecalcAnnuityPayments(this, V_FACTOR_MP_ARR);
	end if;

	if this.[DIC_TYPE_CRED] = &LCONST.TC_CRED_OVER then
		this.[LIMIT_SALDO]	:= V_LIMIT_SALDO;
		this.[MAX_LIMIT_SALDO] := V_MAX_LIMIT_SALDO;
	else
		this.[LIMIT_SALDO]	:= null;
		this.[MAX_LIMIT_SALDO] := null;
	end if;
	
	declare
		rScheme ref [PRC_SCHEME];
	begin
		rScheme := ::[PR_CRED].[NEW_DOG_LIB].Find_Scheme(this.[COMISS_ARR], &LCONST.VD_CALC_PRC);
		if V_ONE_DAY then
			rScheme.[PROC_RECORDS]	:= ::[PROC_RECS]([CODE] = 'МАКС_ЗА_ДЕНЬ');
		else
			-- Если убран признак однодневного кредита, очистим способ обработки выписки
			if nvl(this.[ONE_DAY], false) = true then		-- Был установлен признак однодневного кредита
				rScheme.[PROC_RECORDS]	:= null;
			end if;
		end if;
	end;
	
	this.[ONE_DAY]	:= V_ONE_DAY;
	
	this.[DATE_PAYOUT_LTD] := P_DATE_PAYOUT_LTD;
	this.[HIGH_LEVEL_CR]	:= P_HIGH_LEVEL_CR;
	this.[OPER_WAY_OUT]	:= P_OPER_WAY_OUT;
	this.[EARLY_PAY] 	:= V_EARLY_PAY;

	-- особенности овердрафтов
	if V_CR_CLASS = 'OVERDRAFTS' then
		this->(::[OVERDRAFTS])[CALC_TYPE] := P_CALC_TYPE;--вид сальдирования овердрафта
		if not P_G_AGRIMENT is null then				-- копирование счетов в рамках ген. соглашения
			for over	in P_G_AGRIMENT.[OVERDRAFTS]
						where over%id != this%id
						and (over.[COM_STATUS]!=&LCONST.STATUS_CLOSE and over.[DATE_CLOSE] is null)
						order by over.[DATE_BEGIN] desc
			loop
				::[PR_CRED].[LIB_EXT].copy_acc_dog ( over, this);
			end loop;
		end if;
	end if;

	if V_OPEN_DEP then
		P_PRODUCT := ::[PR_CRED].[NEW_DOG_LIB].CreateDepnContract(this);
	end if;
	this.[OVER_ON_PROD] := P_PRODUCT;	-- продукт, по которому предоставлен кредит
	
	-- если продукт не составной или составной, но проверить надо --
	if not bIgnorCheck then
		[STR].set_par(sAdds, 'P_HIST_DATE', Oper_Day );
		this.[CHECK_CRED_DOG]( P_BUS_PROC == &cBP_EDIT, ADD_PAR == sAdds);
	end if;
	
	if not nvl(bComposit, false) then
		::[PR_CRED].[NEW_DOG_N].update_bki(this, V_TO_BKI, Oper_Day);
	end if;
	
	-- установим вид льготного периода, именно перед началом планирования так как мы могли менять вид кредита и заходить при этом на вкладку планирования
	if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
 		if P_KIND_CREDIT.[GRACE_VAR] is not null then
	 		-- чтобы не добавлялись некорректные записи в историю почистим историю
	 		if coalesce(dateHist, DATE_BEGIN)	< DATE_BEGIN then
	 			::[GRACE_VAR_HIST].[LIB].DelGrace(this);
	 		end if;
	 		::[GRACE_VAR_HIST].[LIB].pSetGrace(this, DATE_BEGIN, P_KIND_CREDIT.[GRACE_VAR]);
	 	else
	 		::[GRACE_VAR_HIST].[LIB].DelGrace(this);
	 	end if;
	end if;

	--v-- реструктуризация в начале договора (сохраним значения если есть, до подписания)	
	dCalcMop := GetDateCalcMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
	if not isNUK then
		V_CHANGE_RULE.[DATE_REG] := DATE_BEGIN;
		oChange_Rule := V_CHANGE_RULE;
		
		if not V_RESTR_KIND is null and nvl(oChange_Rule.[STATUS], ::[COM_STATUS_PRD]([CODE] = 'WAIT_CONF')) != ::[COM_STATUS_PRD]([CODE] = 'WORK')
			and this.[DIC_TYPE_CRED].[PS] is null
		then		
			begin
				bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
				
				if bMop and dCalcMop is not null then
					::[CRED_INTERFACE].[PRX_PLAN].PLAN_MOP(this, dCalcMop);
				end if;
				-- принудительно обновим план
				::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, null, true, null);
				
				if this.[LIST_PLAN_PAY]%size(0) > 0 then
					-- рассчитаем даты исходя из вида реструктуризации
					V_CHANGE_RULE.[DATE_FROM] := nvl(this.[DATE_GIVE], this.[DATE_BEGIN]);
					V_CHANGE_RULE.[KIND] := V_RESTR_KIND;
					oChange_Rule := V_CHANGE_RULE;
					::[CHANGE_RULE].[NEW#AUTO].Set_PrcRestr_Dates(this, oChange_Rule);
					::[CHANGE_RULE].[NEW#AUTO].check_req(this, V_RESTR_MIN_PAY, oChange_Rule.[DATE_FROM], oChange_Rule.[DATE_TO], true, V_RESTR_KIND, (nAdd_First = 0));
					V_CHANGE_RULE := oChange_Rule;
				end if;
			end;
		end if;
		::[PR_CRED].[NEW_DOG_N].SetRestr(this, V_RESTR_KIND, V_RESTR_MIN_PAY, oChange_Rule);
		
	else
		if V_CHANGE_RULE is not null and nvl(V_CHANGE_RULE.[STATUS], ::[COM_STATUS_PRD]([CODE] = 'WAIT_CONF')) != ::[COM_STATUS_PRD]([CODE] = 'WORK') then
			bMop := ::[PR_CRED].[LIB_EXT].fCheckMop(this.[PARAM_FOR_PLAN], P_KIND_CREDIT.[PARAM_FOR_PLAN]);
			if bMop and dCalcMop is not null then
				::[CRED_INTERFACE].[PRX_PLAN].PLAN_MOP(this, dCalcMop);
			end if;
			-- принудительно обновим план
			::[CRED_INTERFACE].[PRX_PLAN].PLAN(this, null, true, null);
			
			dDate_reg := V_CHANGE_RULE.[DATE_REG];
			if DATE_BEGIN != dDate_reg then
				pragma error ('Дата регистрации условий реструктуризации должна быть равна дате начала договора!');
			end if;
			::[RT_NUK].[LIB_TUNE].calc_tune(p_change_rule == V_CHANGE_RULE, p_bus_process == ::[BUS_PROCESS]([CODE] = 'RT_СОХРАНИТЬ'), p_validator_lines == V_DEST_STR, p_adds == V_ADDS);
		end if;	
	end if;
	--^-- реструктуризация в начале договора (сохраним значения если есть, до подписания)

	if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
		if P_SIGN_UP then
			this.[SIGN_UP](nvl(P_OPEN_ACC, false),null,null,null,null, P_DEF_IFRS);
		end if;
	else
		if P_OPEN_ACC and this.[COM_STATUS] = &LCONST.STATUS_WORK then
			begin
				&sp(OPEN_ACCS)
				this.[NEW_ONLY_ACC]();
			exception when others then
				&rb(OPEN_ACCS)
				[STDIO].put_line_buf('<% CALL PR_CRED NEW_ONLY_ACC '|| this%id ||' %>');
			end;
		end if;
	end if;
	
	V_CR_CLASS := null;
	if DECL_ON_CRED_REF is not null then
		DECL_ON_CRED_REF.[DECL_PRD] := this;
	end if;
	
	--v-- BS00140713 Изменение признака в массиве RES_OTHER_FIL
  	if Gl_Change_Res_Fil then
  		-- вызов операции переноса резерва по продукту
		this.[CHANGE_RES_FIL](Oper_Day, P_FILIAL_RES);
  	end if;
	Gl_Change_Res_fil := null;
	Gl_rDepart_Res := null;
	--^-- BS00140713
	
	if P_HIGH_LEVEL_CR is not null then
		this.[NEW_REQ_CLIENT].copy_accs_to_transh(this);
	end if;

	P_PERIOD_WD := nvl(P_PERIOD_WD, false);
	-- сохраняем только если были изменения по галочкам
	if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE')) = '1', false) <> P_PERIOD_WD then
		-- сначала удаляем исходное значение в настройке
		::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE'));
		-- затем добавляем
		::[PROPERTY_PROD].[LIB].AddProperty(this,
						DATE_BEGIN,
						null,
						::[KIND_PROP_PROD]([CODE] = 'TUNE_WORK_DATE'),
						P_PERIOD_WD);
	end if;
	P_TURNOVER_WD := nvl(P_TURNOVER_WD, false);
	
	if nvl(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, nvl(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD')) = '1', false) <> P_TURNOVER_WD then
		-- сначала удаляем исходное значение в настройке
		::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'));
		-- затем добавляем
		::[PROPERTY_PROD].[LIB].AddProperty(this,
						DATE_BEGIN,
						null,
						::[KIND_PROP_PROD]([CODE] = 'TUNE_TURNOVER_WD'),
						P_TURNOVER_WD);	
	end if;

	set_balloon_payment(this, DATE_BEGIN, P_BALLOON_PAYMENT);
	
 	if v_distr_profile is not null then
 		if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF or nvl(P_SIGN_UP, false) then
 			::[CR_DISTR_PR_HIST].[LIB].Set_Hist(this				--Продукт
												, date_begin		--Дата начала действия
												, null				--Дата окончания действия
												, nvl(v_distr_profile, -1));
 		end if;
 	end if;
 	
	-- Если договор в статусе "Ожидает подтверждения",
	if this.[COM_STATUS] = &LCONST.STATUS_WAIT_CONF then
	
		-- если алгоритм МОП заполнен на виде кредита,
	 	-- то сохранять это значение, даже если пользователь удалил на ЭФ ссылку на алгоритм МОП.
	 	P_MOP_TYPE := coalesce(P_MOP_TYPE, P_KIND_CREDIT.[MOP_TYPE]);

		-- Если алгоритм МОП задан, сохранение значения в историю	
		if bMop and P_MOP_TYPE is not null then
			::[CR_CALC_HIST].[LIB].pSetTypeMop(this, this.[DATE_BEGIN], P_MOP_TYPE, ::[CR_CALC_HIST].[LIB].fGetTarifMop(this, this.[DATE_BEGIN]));
		-- иначе,
		elsif not bMop then
			-- удаление записей из истории алгоритмов МОП
			delete rec in ::[CR_CALC_HIST] all where rec.[CRED] = this;
		end if;				
	end if;
 	
	if this.[HIGH_LEVEL_CR] is null then
		if not coalesce(V_DO_FACTORING, true) and coalesce(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, coalesce(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING')), true) then
			::[PROPERTY_PROD].[LIB].AddProperty(this, Oper_Day, null, ::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING'), false);
		elsif coalesce(V_DO_FACTORING, true) and not coalesce(::[PROPERTY_PROD].[LIB].GetPropVal(this, greatest(Oper_Day, coalesce(DATE_BEGIN, Oper_Day)),::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING')), true) then
 			::[PROPERTY_PROD].[LIB].DelProperty(this, ::[KIND_PROP_PROD]([CODE] = 'DO_FACTORING'));	
		end if;
	end if;

 	--Категория информации
	::[CATEGORY_INFO].[LIB].GetCategoryInfo(null,this,null,null,this.[CATEGORY_INFO]);

end;
end;
end;
